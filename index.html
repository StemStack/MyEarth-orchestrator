<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CesiumJS Globe Viewer</title>
    
    <!-- CesiumJS CSS -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background-color: #000;
        }

        /* Cesium container takes full viewport */
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }

        /* Hide Cesium's default credit container for cleaner look */
        .cesium-widget-credits {
            position: absolute !important;
            bottom: 0 !important;
            left: 0 !important;
            background: rgba(0, 0, 0, 0.7) !important;
            padding: 2px 5px !important;
            font-size: 10px !important;
            color: #fff !important;
            border-radius: 0 3px 0 0 !important;
        }

        /* Ensure toolbar is positioned correctly */
        .cesium-viewer-toolbar {
            position: absolute !important;
            top: 10px !important;
            right: 10px !important;
        }

        /* Style the navigation help button */
        .cesium-navigation-help-button {
            background-color: rgba(42, 42, 42, 0.8) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
        }

        /* Loading indicator styling */
        .cesium-viewer-loadingIndicator {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }

        /* Custom zoom controls */
        .zoom-controls {
            position: absolute;
            top: 60px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background-color: rgba(42, 42, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .zoom-button:hover {
            background-color: rgba(68, 68, 68, 0.9);
        }

        .zoom-button:active {
            background-color: rgba(85, 85, 85, 1);
        }



        /* Universal search bar */
        .search-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 350px;
        }

        .search-input-wrapper {
            display: flex;
            align-items: center;
            background-color: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .search-container input {
            width: 300px;
            height: 35px;
            background-color: transparent;
            border: none;
            color: #fff;
            font-size: 14px;
            padding: 0 10px;
            outline: none;
        }

        .search-container input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .suggestions-dropdown {
            background-color: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-height: 300px;
            overflow-y: auto;
        }

        .suggestion-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item.selected {
            background-color: rgba(68, 68, 68, 0.8);
        }

        .suggestion-name {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .suggestion-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }

        /* Bottom left panel with scale bar and coordinates */
        .bottom-left-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Scale bar styling */
        .scale-bar-container {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            padding: 8px 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .scale-bar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scale-line {
            height: 2px;
            background-color: #000;
            position: relative;
            min-width: 60px;
        }

        .scale-line::before,
        .scale-line::after {
            content: '';
            position: absolute;
            width: 1px;
            height: 8px;
            background-color: #000;
            top: -3px;
        }

        .scale-line::before {
            left: 0;
        }

        .scale-line::after {
            right: 0;
        }

        .scale-text {
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #000;
            font-weight: 500;
            white-space: nowrap;
        }

        /* Coordinates info styling */
        .coordinates-info {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            padding: 6px 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .coordinates-text {
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #000;
            font-weight: 400;
        }

        /* North arrow compass styling */
        .north-arrow-container {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .north-arrow {
            position: relative;
            width: 36px;
            height: 36px;
            transition: transform 0.1s ease-out;
        }

        .arrow-needle {
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 24px solid #d32f2f;
            z-index: 2;
        }

        .arrow-needle::after {
            content: '';
            position: absolute;
            top: 24px;
            left: -6px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 9px solid #666;
        }

        .arrow-label {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            font-family: Arial, sans-serif;
            font-size: 12px;
            font-weight: bold;
            color: #000;
            z-index: 3;
        }

        .search-button {
            width: 35px;
            height: 35px;
            background-color: rgba(68, 68, 68, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            margin-left: 5px;
        }

        .search-button:hover {
            background-color: rgba(85, 85, 85, 0.9);
        }

        .search-button:active {
            background-color: rgba(100, 100, 100, 1);
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .cesium-viewer-toolbar {
                top: 5px !important;
                right: 5px !important;
            }
            
            .cesium-widget-credits {
                font-size: 8px !important;
                padding: 1px 3px !important;
            }

            .zoom-controls {
                top: 60px;
                left: 5px;
            }

            .zoom-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            .search-container {
                top: 5px;
                left: 5px;
                transform: none;
                width: calc(100vw - 20px);
                max-width: 300px;
            }

            .search-container input {
                width: calc(100% - 50px);
                font-size: 12px;
            }

            .suggestion-item {
                padding: 10px 12px;
            }

            .suggestion-name {
                font-size: 13px;
            }

            .suggestion-details {
                font-size: 11px;
            }

            .bottom-left-panel {
                bottom: 5px;
                left: 5px;
                gap: 6px;
            }

            .scale-bar-container,
            .coordinates-info {
                padding: 6px 8px;
            }

            .scale-text,
            .coordinates-text {
                font-size: 10px;
            }

            .scale-line {
                min-width: 50px;
            }

            .north-arrow-container {
                width: 48px;
                height: 48px;
                padding: 8px;
            }

            .north-arrow {
                width: 32px;
                height: 32px;
            }

            .arrow-needle {
                border-left-width: 5px;
                border-right-width: 5px;
                border-bottom-width: 20px;
                top: 2px;
            }

            .arrow-needle::after {
                left: -5px;
                border-left-width: 5px;
                border-right-width: 5px;
                border-top-width: 8px;
                top: 20px;
            }

            .arrow-label {
                font-size: 11px;
            }
        }

        /* Center crosshair styling */
        .center-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            pointer-events: none;
        }

        .crosshair-horizontal {
            position: absolute;
            top: -1px;
            left: -10px;
            width: 20px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.5);
        }

        .crosshair-vertical {
            position: absolute;
            top: -10px;
            left: -1px;
            width: 2px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.5);
        }

        /* Layer controls styling */
        .layer-controls {
            position: absolute;
            top: 70px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            min-width: 120px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .layer-toggle:last-child {
            margin-bottom: 0;
        }

        .layer-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .layer-toggle label {
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: #000;
            cursor: pointer;
            user-select: none;
        }

        /* Model upload section */
        .model-upload-section {
            margin-top: 8px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .model-upload-button {
            width: 100%;
            padding: 5px 8px;
            background-color: rgba(76, 175, 80, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: #fff;
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .model-upload-button:hover {
            background-color: rgba(69, 160, 73, 0.9);
        }

        .model-upload-hint {
            font-size: 7px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin: 2px 0;
            line-height: 1.1;
        }

        .sample-models-button {
            width: 100%;
            padding: 4px 6px;
            background-color: rgba(33, 150, 243, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: #fff;
            font-size: 9px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 3px;
        }

        .sample-models-button:hover {
            background-color: rgba(25, 118, 210, 0.9);
        }

        /* Measurement tool styles */
        .measurement-controls {
            position: absolute;
            top: 200px;
            right: 10px;
            background: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 12px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .measurement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .measurement-title {
            font-weight: bold;
            font-size: 13px;
            color: #ffa500;
        }

        .measurement-mode-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .measurement-mode-btn {
            flex: 1;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .measurement-mode-btn.active {
            background: #ffa500;
            border-color: #ffa500;
            color: black;
            font-weight: bold;
        }

        .measurement-mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        .measurement-units {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .measurement-units label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }

        .measurement-units select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: white;
            font-size: 11px;
            padding: 3px 6px;
            cursor: pointer;
        }

        .measurement-results {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 10px;
            min-height: 60px;
        }

        .measurement-result-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 11px;
        }

        .measurement-result-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .measurement-result-value {
            color: #ffa500;
            font-weight: bold;
        }

        .measurement-actions {
            display: flex;
            gap: 6px;
        }

        .measurement-btn {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .measurement-btn.primary {
            background: #ffa500;
            color: black;
            font-weight: bold;
        }

        .measurement-btn.primary:hover {
            background: #ff8c00;
        }

        .measurement-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .measurement-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .measurement-instructions {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin: 8px 0;
            line-height: 1.3;
        }

        /* Base map switcher styles */
        .basemap-switcher {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 12px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .basemap-title {
            font-weight: bold;
            font-size: 13px;
            color: #4CAF50;
            margin-bottom: 8px;
            text-align: center;
        }

        .basemap-dropdown {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 11px;
            padding: 6px 8px;
            cursor: pointer;
            outline: none;
        }

        .basemap-dropdown option {
            background: #2a2a2a;
            color: white;
            padding: 6px;
        }

        .basemap-dropdown:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .basemap-attribution {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 8px;
            line-height: 1.2;
            text-align: center;
        }

        @media (max-width: 768px) {
            .zoom-controls {
                top: 55px;
                right: 8px;
            }

            .zoom-button {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }

            .layer-controls {
                top: 60px;
                left: 8px;
                padding: 8px;
                min-width: 100px;
            }

            .layer-toggle label {
                font-size: 11px;
            }
        }

        /* Drag and drop overlay styling */
        .drag-drop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .drag-drop-content {
            background-color: rgba(255, 255, 255, 0.95);
            border: 3px dashed #4CAF50;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            max-width: 300px;
        }

        .drag-drop-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .drag-drop-text {
            font-family: Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .drag-drop-subtext {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #666;
        }

        @media (max-width: 768px) {
            .drag-drop-content {
                padding: 30px;
                max-width: 250px;
            }

            .drag-drop-icon {
                font-size: 36px;
            }

            .drag-drop-text {
                font-size: 16px;
            }

            .drag-drop-subtext {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <!-- Main Cesium container -->
    <div id="cesiumContainer"></div>
    
    <!-- Custom zoom controls -->
    <div class="zoom-controls">
        <button class="zoom-button" id="zoomIn" title="Zoom In">+</button>
        <button class="zoom-button" id="zoomOut" title="Zoom Out">‚àí</button>
    </div>

    <!-- Center crosshair -->
    <div class="center-crosshair" id="centerCrosshair">
        <div class="crosshair-horizontal"></div>
        <div class="crosshair-vertical"></div>
    </div>

    <!-- Layer toggle controls -->
    <div class="layer-controls" id="layerControls">
        <div class="layer-toggle">
            <input type="checkbox" id="baseLayerToggle" checked>
            <label for="baseLayerToggle">Base Map</label>
        </div>
        <div class="layer-toggle">
            <input type="checkbox" id="atmosphereToggle" checked onchange="toggleAtmosphere()">
            <label for="atmosphereToggle">Fog Effects</label>
        </div>
        <div class="model-upload-section">
            <button class="model-upload-button" id="modelUploadButton">
                üìÅ Upload
            </button>
            <div class="model-upload-hint">
                Drag files or <span style="opacity: 0.9;">GLB/GLTF only</span>
            </div>
            <button class="sample-models-button" onclick="showSampleModels()">
                üì¶ Samples
            </button>
        </div>
        
        <!-- Measurement tool toggle -->
        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <button onclick="toggleMeasurementTool()" style="width: 100%; padding: 5px 8px; background-color: rgba(255, 165, 0, 0.9); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 3px; color: white; font-size: 10px; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease;">
                üìè Measure
            </button>
        </div>
    </div>

    <!-- Drag and drop overlay -->
    <!-- Measurement Controls -->
    <div class="measurement-controls" id="measurementControls" style="display: none;">
        <div class="measurement-header">
            <div class="measurement-title">üìè Measurement Tool</div>
            <button onclick="toggleMeasurementTool()" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">‚úï</button>
        </div>
        
        <div class="measurement-mode-buttons">
            <button class="measurement-mode-btn active" data-mode="line" onclick="setMeasurementMode('line')">Line</button>
            <button class="measurement-mode-btn" data-mode="area" onclick="setMeasurementMode('area')">Area</button>
            <button class="measurement-mode-btn" data-mode="vertical" onclick="setMeasurementMode('vertical')">Vertical</button>
        </div>
        
        <div class="measurement-units">
            <label>Units:</label>
            <select id="measurementUnits" onchange="updateMeasurementUnits()">
                <option value="metric">Metric (m)</option>
                <option value="imperial">Imperial (ft)</option>
            </select>
        </div>
        
        <div class="measurement-results" id="measurementResults">
            <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 15px;">
                No measurements yet
            </div>
        </div>
        
        <div class="measurement-instructions" id="measurementInstructions">
            Click two points to measure distance
        </div>
        
        <div class="measurement-actions">
            <button class="measurement-btn primary" onclick="newMeasurement()">New</button>
            <button class="measurement-btn secondary" onclick="clearMeasurements()">Clear All</button>
        </div>
    </div>

    <div class="drag-drop-overlay" id="dragDropOverlay" style="display: none;">
        <div class="drag-drop-content">
            <div class="drag-drop-icon">üìÅ</div>
            <div class="drag-drop-text">Drop 3D Model Here</div>
            <div class="drag-drop-subtext">Supported: GLB, GLTF, OBJ, FBX, DAE, STL, PLY, LAS, DXF, USDZ</div>
        </div>
    </div>

    <!-- File input (hidden) -->
    <input type="file" id="modelFileInput" accept=".gltf,.glb,.obj,.fbx,.dae,.stl,.ply,.las,.dxf,.usdz" style="display: none;">

    <!-- Universal search bar -->
    <div class="search-container">
        <div class="search-input-wrapper">
            <input type="text" id="searchInput" placeholder="Search address, place, or coordinates..." autocomplete="off">
            <button class="search-button" id="searchButton">üîç</button>
            <div class="loading-spinner" id="loadingSpinner" style="display: none;"></div>
        </div>
        <div class="suggestions-dropdown" id="suggestionsDropdown" style="display: none;"></div>
    </div>

    <!-- Scale bar and coordinates display -->
    <div class="bottom-left-panel" id="bottomLeftPanel">
        <!-- North arrow compass -->
        <div class="north-arrow-container" id="northArrowContainer">
            <div class="north-arrow" id="northArrow">
                <div class="arrow-needle"></div>
                <div class="arrow-label">N</div>
            </div>
        </div>
        
        <!-- Scale bar -->
        <div class="scale-bar-container" id="scaleBarContainer">
            <div class="scale-bar" id="scaleBar">
                <div class="scale-line" id="scaleLine"></div>
                <div class="scale-text" id="scaleText">1 km</div>
            </div>
        </div>
        
        <!-- Coordinates display -->
        <div class="coordinates-info" id="coordinatesInfo">
            <span class="coordinates-text" id="coordinatesText">Coordinates (¬∞) ---.------, ---.------</span>
        </div>
    </div>

    <!-- Base Map Switcher -->
    <div class="basemap-switcher" id="basemapSwitcher">
        <div class="basemap-title">üó∫Ô∏è Base Maps</div>
        <select class="basemap-dropdown" id="basemapSelect" onchange="switchBaseMap()">
            <option value="osm">OpenStreetMap</option>
            <option value="otm">OpenTopoMap</option>
            <option value="stamen-terrain">Stamen Terrain</option>
            <option value="cartodb-positron">CartoDB Positron</option>
            <option value="esri-imagery">ESRI World Imagery</option>
        </select>
        <div class="basemap-attribution" id="basemapAttribution">
            ¬© OpenStreetMap contributors
        </div>
    </div>

    <!-- CesiumJS JavaScript -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    
    <script>
        // Disable Cesium Ion to prevent authentication errors
        Cesium.Ion.defaultAccessToken = undefined;
        
        // Initialize the Cesium viewer with minimal configuration
        const viewer = new Cesium.Viewer('cesiumContainer', {
            // Disable unnecessary UI widgets for clean appearance
            animation: false,           // Remove animation controls
            baseLayerPicker: false,     // Remove base layer picker
            fullscreenButton: true,     // Keep fullscreen button
            geocoder: false,            // Remove geocoder search
            homeButton: true,           // Keep home button for navigation reset
            infoBox: false,             // Remove info box
            sceneModePicker: false,     // Remove 2D/3D mode picker
            selectionIndicator: false,  // Remove selection indicator
            timeline: false,            // Remove timeline
            navigationHelpButton: true, // Keep navigation help
            
            // Use heightmap terrain for simple 3D topography without authentication
            terrainProvider: new Cesium.EllipsoidTerrainProvider({
                // This creates a basic spherical terrain
                // We'll enhance it with visual effects for 3D appearance
            }),
            
            // Keep sky effects disabled to prevent authentication errors
            skyBox: false,
            skyAtmosphere: false,
            requestRenderMode: false,
            maximumRenderTimeChange: Infinity
        });

        // Keep lighting disabled to prevent rendering errors
        viewer.scene.globe.enableLighting = false;
        viewer.scene.fog.enabled = true;
        viewer.scene.fog.density = 0.0003;
        viewer.scene.fog.screenSpaceErrorFactor = 2.0;
        viewer.scene.globe.showWaterEffect = false;
        
        // Disable all lighting and atmosphere features to prevent errors
        viewer.scene.globe.dynamicAtmosphereLighting = false;
        viewer.scene.globe.dynamicAtmosphereLightingFromSun = false;
        
        // Base map configurations
        const baseMaps = {
            'osm': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                    credit: 'Map data ¬© OpenStreetMap contributors'
                }),
                attribution: '¬© OpenStreetMap contributors'
            },
            'otm': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
                    subdomains: ['a', 'b', 'c'],
                    credit: 'Map data ¬© OpenStreetMap contributors, SRTM | Map style ¬© OpenTopoMap (CC-BY-SA)'
                }),
                attribution: '¬© OpenStreetMap contributors, SRTM | ¬© OpenTopoMap (CC-BY-SA)'
            },
            'stamen-terrain': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png',
                    credit: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'
                }),
                attribution: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'
            },
            'cartodb-positron': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                    subdomains: ['a', 'b', 'c', 'd'],
                    credit: '¬© OpenStreetMap contributors ¬© CARTO'
                }),
                attribution: '¬© OpenStreetMap contributors ¬© CARTO'
            },
            'esri-imagery': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                    credit: 'Tiles ¬© Esri ‚Äî Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                }),
                attribution: 'Tiles ¬© Esri ‚Äî Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            }
        };

        // Current base map
        let currentBaseMap = 'osm';
        
        // Remove default imagery and add OpenStreetMap
        viewer.imageryLayers.removeAll();
        viewer.imageryLayers.addImageryProvider(baseMaps[currentBaseMap].provider());

        // Define European home view coordinates
        const europeHomeView = {
            destination: Cesium.Cartesian3.fromDegrees(10.0, 54.0, 4000000.0),
            orientation: {
                heading: 0.0,
                pitch: -Cesium.Math.PI_OVER_TWO,
                roll: 0.0
            }
        };

        // Set initial camera position centered on Europe
        viewer.camera.setView(europeHomeView);

        // Override the default home button behavior to use European coordinates
        viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function(e) {
            e.cancel = true;
            viewer.camera.flyTo(europeHomeView);
        });

        // Handle window resize events for responsiveness
        window.addEventListener('resize', function() {
            viewer.resize();
        }, false);

        // Disable right-click context menu over the viewer
        viewer.cesiumWidget.canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        }, false);
        
        // Add additional rotation input handlers for immediate north arrow response
        const canvas = viewer.canvas;
        let isRotating = false;
        
        // Mouse down to detect start of rotation
        canvas.addEventListener('mousedown', function(e) {
            if (e.button === 2 || e.ctrlKey) { // Right click or Ctrl+click
                isRotating = true;
            }
        });
        
        // Mouse move during rotation
        canvas.addEventListener('mousemove', function(e) {
            if (isRotating) {
                // Immediate north arrow update during rotation
                setTimeout(updateNorthArrow, 0);
            }
        });
        
        // Mouse up to end rotation
        canvas.addEventListener('mouseup', function(e) {
            isRotating = false;
        });

        // Hide credit container for cleaner look
        viewer.cesiumWidget.creditContainer.style.display = "none";

        // Add zoom button functionality
        const zoomInButton = document.getElementById('zoomIn');
        const zoomOutButton = document.getElementById('zoomOut');
        
        // Add search elements
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const suggestionsDropdown = document.getElementById('suggestionsDropdown');
        
        // Add layer control elements
        const baseLayerToggle = document.getElementById('baseLayerToggle');
        
        // Add drag and drop elements
        const dragDropOverlay = document.getElementById('dragDropOverlay');
        const modelFileInput = document.getElementById('modelFileInput');
        const modelUploadButton = document.getElementById('modelUploadButton');
        
        // Add scale bar and coordinate display elements
        const bottomLeftPanel = document.getElementById('bottomLeftPanel');
        const scaleBar = document.getElementById('scaleBar');
        const scaleLine = document.getElementById('scaleLine');
        const scaleText = document.getElementById('scaleText');
        const coordinatesText = document.getElementById('coordinatesText');
        const northArrow = document.getElementById('northArrow');
        
        // Autocomplete state
        let searchTimeout;
        let currentSuggestions = [];
        let selectedSuggestionIndex = -1;

        zoomInButton.addEventListener('click', function() {
            const camera = viewer.camera;
            const currentHeight = camera.positionCartographic.height;
            const newHeight = Math.max(currentHeight * 0.5, 1000); // Zoom in by 50%, minimum 1km
            
            camera.setView({
                destination: Cesium.Cartesian3.fromRadians(
                    camera.positionCartographic.longitude,
                    camera.positionCartographic.latitude,
                    newHeight
                ),
                orientation: {
                    heading: camera.heading,
                    pitch: camera.pitch,
                    roll: camera.roll
                }
            });
        });

        zoomOutButton.addEventListener('click', function() {
            const camera = viewer.camera;
            const currentHeight = camera.positionCartographic.height;
            const newHeight = Math.min(currentHeight * 2.0, 50000000); // Zoom out by 100%, maximum 50,000km
            
            camera.setView({
                destination: Cesium.Cartesian3.fromRadians(
                    camera.positionCartographic.longitude,
                    camera.positionCartographic.latitude,
                    newHeight
                ),
                orientation: {
                    heading: camera.heading,
                    pitch: camera.pitch,
                    roll: camera.roll
                }
            });
        });

        // Function to check if input is coordinates
        function isCoordinates(input) {
            const coordPattern = /^-?\d+\.?\d*,\s*-?\d+\.?\d*$|^-?\d+\.?\d*\s+-?\d+\.?\d*$/;
            return coordPattern.test(input.trim());
        }

        // Function to parse coordinates from input
        function parseCoordinates(input) {
            const cleaned = input.trim().replace(/,/, ' ');
            const parts = cleaned.split(/\s+/);
            if (parts.length === 2) {
                const lat = parseFloat(parts[0]);
                const lon = parseFloat(parts[1]);
                if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    return { lat, lon };
                }
            }
            return null;
        }

        // Function to get autocomplete suggestions
        async function getAutocompleteSuggestions(query) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&addressdetails=1&limit=5`);
                const data = await response.json();
                return data.map(item => ({
                    lat: parseFloat(item.lat),
                    lon: parseFloat(item.lon),
                    name: item.name || item.display_name.split(',')[0],
                    displayName: item.display_name,
                    type: item.type,
                    address: item.address
                }));
            } catch (error) {
                console.error('Autocomplete error:', error);
                return [];
            }
        }

        // Function to geocode using Nominatim API
        async function geocodeLocation(query) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon),
                        displayName: data[0].display_name
                    };
                }
                return null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        // Function to fly to coordinates with vertical nadir view
        function flyToLocation(lat, lon, altitude = 2000) {
            // Use setView for immediate positioning, then flyTo for smooth animation
            const destination = Cesium.Cartesian3.fromDegrees(lon, lat, altitude);
            
            viewer.camera.flyTo({
                destination: destination,
                orientation: {
                    heading: 0.0, // North direction
                    pitch: -Cesium.Math.PI_OVER_TWO, // -90 degrees (straight down)
                    roll: 0.0 // No rotation
                },
                duration: 2.0,
                complete: function() {
                    // Ensure the camera is truly vertical after animation
                    viewer.camera.setView({
                        destination: destination,
                        orientation: {
                            heading: 0.0,
                            pitch: -Cesium.Math.PI_OVER_TWO, // -90 degrees
                            roll: 0.0
                        }
                    });
                }
            });
        }

        // Universal search functionality
        async function performSearch() {
            const query = searchInput.value.trim();
            if (!query) return;

            // Show loading spinner
            loadingSpinner.style.display = 'block';
            searchButton.disabled = true;

            try {
                // Check if input is coordinates
                const coords = parseCoordinates(query);
                if (coords) {
                    flyToLocation(coords.lat, coords.lon);
                    searchInput.value = '';
                } else {
                    // Geocode the location
                    const result = await geocodeLocation(query);
                    if (result) {
                        flyToLocation(result.lat, result.lon);
                        searchInput.value = '';
                    } else {
                        alert('Location not found. Please try a different search term.');
                    }
                }
            } catch (error) {
                alert('Search failed. Please check your internet connection and try again.');
            } finally {
                // Hide loading spinner
                loadingSpinner.style.display = 'none';
                searchButton.disabled = false;
            }
        }

        // Function to display suggestions
        function displaySuggestions(suggestions) {
            currentSuggestions = suggestions;
            selectedSuggestionIndex = -1;
            
            if (suggestions.length === 0) {
                hideSuggestions();
                return;
            }
            
            const html = suggestions.map((suggestion, index) => {
                const name = suggestion.name || 'Unknown';
                const details = formatSuggestionDetails(suggestion);
                return `
                    <div class="suggestion-item" data-index="${index}">
                        <div class="suggestion-name">${escapeHtml(name)}</div>
                        <div class="suggestion-details">${escapeHtml(details)}</div>
                    </div>
                `;
            }).join('');
            
            suggestionsDropdown.innerHTML = html;
            suggestionsDropdown.style.display = 'block';
            
            // Add click event listeners to suggestions
            suggestionsDropdown.querySelectorAll('.suggestion-item').forEach((item, index) => {
                item.addEventListener('click', () => selectSuggestion(index));
            });
        }

        // Function to format suggestion details
        function formatSuggestionDetails(suggestion) {
            const parts = [];
            if (suggestion.address) {
                if (suggestion.address.city) parts.push(suggestion.address.city);
                if (suggestion.address.state) parts.push(suggestion.address.state);
                if (suggestion.address.country) parts.push(suggestion.address.country);
            }
            return parts.length > 0 ? parts.join(', ') : suggestion.displayName;
        }

        // Function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Function to hide suggestions
        function hideSuggestions() {
            suggestionsDropdown.style.display = 'none';
            currentSuggestions = [];
            selectedSuggestionIndex = -1;
        }

        // Function to select a suggestion
        function selectSuggestion(index) {
            if (index >= 0 && index < currentSuggestions.length) {
                const suggestion = currentSuggestions[index];
                flyToLocation(suggestion.lat, suggestion.lon);
                searchInput.value = '';
                hideSuggestions();
            }
        }

        // Function to highlight selected suggestion
        function updateSelectedSuggestion() {
            suggestionsDropdown.querySelectorAll('.suggestion-item').forEach((item, index) => {
                if (index === selectedSuggestionIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Debounced autocomplete function
        function handleInputChange() {
            const query = searchInput.value.trim();
            
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            // Hide suggestions if input is empty
            if (!query) {
                hideSuggestions();
                return;
            }
            
            // Don't autocomplete if input looks like coordinates
            if (isCoordinates(query)) {
                hideSuggestions();
                return;
            }
            
            // Set new timeout for autocomplete
            searchTimeout = setTimeout(async () => {
                try {
                    const suggestions = await getAutocompleteSuggestions(query);
                    displaySuggestions(suggestions);
                } catch (error) {
                    console.error('Autocomplete failed:', error);
                    hideSuggestions();
                }
            }, 300); // 300ms debounce
        }

        // Add search event listeners
        searchButton.addEventListener('click', performSearch);
        
        // Enhanced input event listeners
        searchInput.addEventListener('input', handleInputChange);
        
        searchInput.addEventListener('keydown', function(e) {
            if (suggestionsDropdown.style.display === 'block' && currentSuggestions.length > 0) {
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, currentSuggestions.length - 1);
                        updateSelectedSuggestion();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                        updateSelectedSuggestion();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (selectedSuggestionIndex >= 0) {
                            selectSuggestion(selectedSuggestionIndex);
                        } else {
                            performSearch();
                        }
                        break;
                    case 'Escape':
                        hideSuggestions();
                        break;
                }
            } else if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.search-container')) {
                hideSuggestions();
            }
        });

        /**
         * Live Coordinates Tracking System
         * 
         * Implements real-time coordinate display that shows latitude, longitude,
         * and height of terrain under the mouse cursor. Uses Cesium's camera ray
         * casting to determine precise geographic coordinates.
         */

        // Coordinate tracking handler with throttling for performance
        let coordinateUpdateThrottle = null;
        const COORDINATE_UPDATE_INTERVAL = 50; // Update every 50ms for smooth tracking

        /**
         * Calculates and updates the scale bar based on current map view
         * Uses geodesic distance calculation for accurate metric representation
         */
        function updateScaleBar() {
            try {
                const canvas = viewer.canvas;
                const ellipsoid = viewer.scene.globe.ellipsoid;
                
                // Get canvas dimensions
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                // Define two points on screen separated by 100 pixels
                const left = new Cesium.Cartesian2((width / 2) - 50, height / 2);
                const right = new Cesium.Cartesian2((width / 2) + 50, height / 2);
                
                // Pick ellipsoid positions for both points
                const leftPosition = viewer.camera.pickEllipsoid(left, ellipsoid);
                const rightPosition = viewer.camera.pickEllipsoid(right, ellipsoid);
                
                if (leftPosition && rightPosition) {
                    // Convert to cartographic coordinates
                    const leftCartographic = ellipsoid.cartesianToCartographic(leftPosition);
                    const rightCartographic = ellipsoid.cartesianToCartographic(rightPosition);
                    
                    // Calculate geodesic distance between the two points
                    const geodesic = new Cesium.EllipsoidGeodesic(leftCartographic, rightCartographic);
                    const pixelDistance = geodesic.surfaceDistance; // Distance in meters for 100 pixels
                    
                    // Determine appropriate scale values
                    let targetDistance, scaleWidth, scaleLabel;
                    
                    if (pixelDistance >= 100000) {
                        // For very large scales, use 100km intervals
                        targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                        if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                        else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                        scaleLabel = (targetDistance / 1000) + ' km';
                    } else if (pixelDistance >= 1000) {
                        // For medium scales, use km
                        targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                        if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                        else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                        scaleLabel = (targetDistance >= 1000) ? (targetDistance / 1000) + ' km' : targetDistance + ' m';
                    } else {
                        // For small scales, use meters
                        targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                        if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                        else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                        scaleLabel = targetDistance + ' m';
                    }
                    
                    // Calculate the width in pixels for our target distance
                    scaleWidth = (targetDistance / pixelDistance) * 100;
                    
                    // Update the scale bar
                    scaleLine.style.width = Math.max(Math.min(scaleWidth, 200), 30) + 'px';
                    scaleText.textContent = scaleLabel;
                }
            } catch (error) {
                console.warn('Scale bar calculation failed, using default');
                scaleLine.style.width = '60px';
                scaleText.textContent = '1 km';
            }
        }

        /**
         * Updates coordinate display with formatted values in WGS84 degrees
         * @param {number} latitude - Latitude in degrees
         * @param {number} longitude - Longitude in degrees  
         */
        function updateCoordinateDisplay(latitude, longitude) {
            try {
                if (!coordinatesText) {
                    console.warn('Coordinates text element not found');
                    return;
                }
                
                const latText = latitude.toFixed(6);
                const lonText = longitude.toFixed(6);
                coordinatesText.textContent = `Coordinates (¬∞) ${latText}, ${lonText}`;
                
            } catch (error) {
                console.warn('Error updating coordinate display:', error);
            }
        }

        /**
         * Clears coordinate display when mouse is not over terrain
         */
        function clearCoordinateDisplay() {
            try {
                if (!coordinatesText) {
                    console.warn('Coordinates text element not found');
                    return;
                }
                coordinatesText.textContent = 'Coordinates (¬∞) ---.------, ---.------';
            } catch (error) {
                console.warn('Error clearing coordinate display:', error);
            }
        }

        /**
         * Updates the north arrow rotation to always point to geographic north
         * Arrow compensates for camera rotation to maintain north orientation
         */
        function updateNorthArrow() {
            try {
                // Ensure northArrow element exists
                if (!northArrow) {
                    return;
                }
                
                // Get the camera's current heading (rotation around the up axis)
                const heading = viewer.camera.heading;
                
                // Convert heading from radians to degrees and normalize to 0-360
                let headingDegrees = Cesium.Math.toDegrees(heading);
                headingDegrees = ((headingDegrees % 360) + 360) % 360;
                
                // Rotate the north arrow to compensate for camera rotation
                // Negative rotation because we want the arrow to point north regardless of camera heading
                const rotation = -headingDegrees;
                
                // Apply rotation transform to the north arrow
                northArrow.style.transform = `rotate(${rotation}deg)`;
                

                
            } catch (error) {
                console.warn('North arrow update failed:', error);
                // Reset to default orientation on error
                if (northArrow) {
                    northArrow.style.transform = 'rotate(0deg)';
                }
            }
        }

        /**
         * Updates coordinates to show center of camera view
         * Uses camera position and center screen ray casting
         */
        function updateCenterCoordinates() {
            try {
                // Get center of screen coordinates
                const canvas = viewer.canvas;
                const centerX = canvas.clientWidth / 2;
                const centerY = canvas.clientHeight / 2;
                const centerPick = new Cesium.Cartesian2(centerX, centerY);
                
                // Cast ray from camera through center of screen
                const ray = viewer.camera.getPickRay(centerPick);
                let intersection = viewer.scene.globe.pick(ray, viewer.scene);
                
                // Fallback to ellipsoid intersection if no terrain intersection
                if (!intersection) {
                    const ellipsoidIntersection = Cesium.IntersectionTests.rayEllipsoid(ray, viewer.scene.globe.ellipsoid);
                    if (ellipsoidIntersection) {
                        intersection = Cesium.Ray.getPoint(ray, ellipsoidIntersection.start);
                    }
                }
                
                if (intersection) {
                    // Convert to geographic coordinates
                    const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    
                    updateCoordinateDisplay(latitude, longitude);
                } else {
                    clearCoordinateDisplay();
                }
                
            } catch (error) {
                console.warn('Center coordinate tracking error:', error);
                clearCoordinateDisplay();
            }
        }

        /**
         * Initialize coordinate tracking, scale bar, and north arrow systems
         * Attaches mouse move listener and camera change handlers
         */
        function initializeCoordinateTracking() {
            // Add camera change listeners for scale bar, north arrow, and center coordinates
            viewer.camera.changed.addEventListener(function() {
                updateScaleBar();
                updateNorthArrow();
                updateCenterCoordinates();
            });
            
            // Add camera move events for more responsive updates
            viewer.camera.moveStart.addEventListener(function() {
                updateNorthArrow();
            });
            
            viewer.camera.moveEnd.addEventListener(function() {
                updateScaleBar();
                updateNorthArrow();
                updateCenterCoordinates();
            });
            
            // Add scene post-render event for continuous updates during any camera changes
            let lastHeading = viewer.camera.heading;
            viewer.scene.postRender.addEventListener(function() {
                // Check if heading has changed to update north arrow
                const currentHeading = viewer.camera.heading;
                if (Math.abs(currentHeading - lastHeading) > 0.001) {
                    updateNorthArrow();
                    lastHeading = currentHeading;
                }
            });
            
            viewer.scene.morphComplete.addEventListener(function() {
                updateScaleBar();
                updateNorthArrow();
                updateCenterCoordinates();
            });
            
            // Initial updates
            updateScaleBar();
            updateNorthArrow();
            updateCenterCoordinates();
            
            console.log('Center coordinate tracking, scale bar, and north arrow initialized');
        }

        /**
         * Toggles the base map layer visibility
         * @param {boolean} visible - Whether to show or hide the base layer
         */
        function toggleBaseLayer(visible) {
            try {
                if (viewer.imageryLayers.length > 0) {
                    const baseLayer = viewer.imageryLayers.get(0);
                    baseLayer.show = visible;
                    console.log(`Base layer ${visible ? 'enabled' : 'disabled'}`);
                }
            } catch (error) {
                console.warn('Error toggling base layer:', error);
            }
        }

        /**
         * Initialize layer controls
         */
        function initializeLayerControls() {
            // Base layer toggle functionality
            baseLayerToggle.addEventListener('change', function() {
                toggleBaseLayer(this.checked);
            });
            
            // Model upload button functionality
            modelUploadButton.addEventListener('click', function() {
                modelFileInput.click();
            });
            
            console.log('Layer controls initialized');
        }

        /**
         * Check if file format is a recognized 3D model format
         * @param {string} filename - The filename to check
         * @returns {object} - Object with format info and support status
         */
        function check3DFileFormat(filename) {
            const extension = filename.toLowerCase().split('.').pop();
            
            const supportedFormats = {
                'glb': { name: 'GLTF Binary', supported: true, description: 'Optimized for web display' },
                'gltf': { name: 'GLTF JSON', supported: true, description: 'Standard web 3D format' }
            };
            
            const unsupportedFormats = {
                'obj': { name: 'Wavefront OBJ', supported: false, description: 'Legacy 3D mesh format' },
                'fbx': { name: 'Autodesk FBX', supported: false, description: 'Animation-rich format' },
                'dae': { name: 'COLLADA', supported: false, description: 'XML-based 3D format' },
                'stl': { name: 'Stereolithography', supported: false, description: '3D printing format' },
                'ply': { name: 'Polygon File Format', supported: false, description: 'Point cloud/mesh format' },
                'las': { name: 'LAS Point Cloud', supported: false, description: 'LiDAR data format' },
                'dxf': { name: 'AutoCAD DXF', supported: false, description: 'CAD drawing format' },
                'usdz': { name: 'Universal Scene Description', supported: false, description: 'Apple AR format' }
            };
            
            if (supportedFormats[extension]) {
                return { ...supportedFormats[extension], extension, isKnown3D: true };
            } else if (unsupportedFormats[extension]) {
                return { ...unsupportedFormats[extension], extension, isKnown3D: true };
            } else {
                return { name: 'Unknown', supported: false, extension, isKnown3D: false };
            }
        }

        /**
         * Show format compatibility warning for unsupported 3D files
         * @param {object} formatInfo - Format information object
         * @param {string} filename - The filename
         */
        function showFormatWarning(formatInfo, filename) {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 152, 0, 0.95);
                color: white;
                padding: 25px;
                border-radius: 12px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                max-width: 450px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            
            warningDiv.innerHTML = `
                <h3 style="margin: 0 0 15px 0;">Format Not Supported in Browser</h3>
                <div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <strong>${formatInfo.name} (.${formatInfo.extension})</strong><br>
                    <span style="font-size: 13px;">${formatInfo.description}</span>
                </div>
                <p style="margin-bottom: 20px; font-size: 14px;">
                    This file format is not supported in the browser. Please convert to <strong>.glb</strong> or <strong>3D Tiles</strong> before importing.
                </p>
                <div style="text-align: left; background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 20px;">
                    <strong>Recommended Converters:</strong>
                    <ul style="font-size: 13px; margin-top: 8px; line-height: 1.6;">
                        <li><strong>Blender</strong> - Free, supports most formats ‚Üí GLB export</li>
                        <li><strong>FBX2glTF</strong> - Facebook's official FBX converter</li>
                        <li><strong>obj2gltf</strong> - Command line OBJ to GLTF converter</li>
                        <li><strong>Online converters</strong> - Search "convert ${formatInfo.extension} to glb"</li>
                    </ul>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="this.parentElement.parentElement.remove()" style="background: white; color: #333; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">OK</button>
                    <button onclick="showModelAlternatives(); this.parentElement.parentElement.remove();" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Get Help</button>
                </div>
            `;
            
            document.body.appendChild(warningDiv);
        }

        /**
         * Validate file format (only GLB/GLTF allowed)
         * @param {File} file - The file to validate
         * @returns {object} - Validation result with isValid and message
         */
        function validateFileFormat(file) {
            const fileName = file.name.toLowerCase();
            const isGLB = fileName.endsWith('.glb');
            const isGLTF = fileName.endsWith('.gltf');
            
            if (!isGLB && !isGLTF) {
                return {
                    isValid: false,
                    message: "Only .glb or .gltf files are supported. Please convert your model before uploading."
                };
            }
            
            return { isValid: true, message: null };
        }

        /**
         * Validate file size (5MB limit)
         * @param {File} file - The file to validate
         * @returns {object} - Validation result with isValid and message
         */
        function validateFileSize(file) {
            const maxSize = 5 * 1024 * 1024; // 5MB in bytes
            const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
            
            if (file.size > maxSize) {
                return {
                    isValid: false,
                    message: `This model (${fileSizeMB}MB) may be too large for CesiumJS to handle efficiently. Try reducing the file below 5MB.`,
                    size: fileSizeMB
                };
            }
            
            return { isValid: true, message: null };
        }

        /**
         * Validate GLB/GLTF file format integrity
         * @param {File} file - The file to validate
         * @returns {Promise<object>} - Validation result with isValid and message
         */
        async function validateModelFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    const dataView = new DataView(arrayBuffer);
                    
                    try {
                        // Check GLB magic number (first 4 bytes should be "glTF")
                        if (file.name.toLowerCase().endsWith('.glb')) {
                            const magic = dataView.getUint32(0, true);
                            const glTFMagic = 0x46546C67; // "glTF" in little-endian
                            const isValid = magic === glTFMagic;
                            resolve({
                                isValid,
                                message: isValid ? null : "Invalid GLB file format. File may be corrupted or not a valid GLB."
                            });
                        } else if (file.name.toLowerCase().endsWith('.gltf')) {
                            // For GLTF JSON files, try to parse as JSON
                            const text = new TextDecoder().decode(arrayBuffer);
                            const json = JSON.parse(text);
                            const isValid = json.asset && json.asset.version;
                            resolve({
                                isValid,
                                message: isValid ? null : "Invalid GLTF file format. Missing required asset information."
                            });
                        } else {
                            resolve({
                                isValid: false,
                                message: "Unsupported file format."
                            });
                        }
                    } catch (error) {
                        console.warn('File validation error:', error);
                        resolve({
                            isValid: false,
                            message: "Could not read file. File may be corrupted."
                        });
                    }
                };
                reader.onerror = () => resolve({
                    isValid: false,
                    message: "Error reading file."
                });
                reader.readAsArrayBuffer(file.slice(0, 1024)); // Read first 1KB for validation
            });
        }

        /**
         * Show error modal with consistent styling
         * @param {string} title - Modal title
         * @param {string} message - Main message
         * @param {Array} buttons - Array of button objects {text, action, style}
         */
        function showErrorModal(title, message, buttons = null) {
            // Remove any existing modals
            const existingModals = document.querySelectorAll('.error-modal');
            existingModals.forEach(modal => modal.remove());
            
            const modal = document.createElement('div');
            modal.className = 'error-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: Arial, sans-serif;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 480px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                position: relative;
                animation: modalSlideIn 0.3s ease-out;
            `;
            
            // Add animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes modalSlideIn {
                    from { transform: translateY(-20px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            modalContent.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 16px;">
                    <span style="font-size: 24px; margin-right: 12px;">${title.includes('‚ùå') ? title : '‚ùå ' + title}</span>
                </div>
                <div style="color: #333; line-height: 1.6; margin-bottom: 24px;">
                    ${message}
                </div>
                <div id="modalButtons" style="display: flex; gap: 12px; justify-content: flex-end;"></div>
            `;
            
            const buttonsContainer = modalContent.querySelector('#modalButtons');
            
            // Default buttons if none provided
            if (!buttons) {
                buttons = [
                    { text: 'Got It', action: () => modal.remove(), style: 'primary' }
                ];
            }
            
            buttons.forEach(button => {
                const btn = document.createElement('button');
                btn.textContent = button.text;
                btn.onclick = button.action;
                
                const baseStyle = `
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: all 0.2s ease;
                `;
                
                if (button.style === 'primary') {
                    btn.style.cssText = baseStyle + `
                        background: #007bff;
                        color: white;
                    `;
                    btn.onmouseover = () => btn.style.background = '#0056b3';
                    btn.onmouseout = () => btn.style.background = '#007bff';
                } else {
                    btn.style.cssText = baseStyle + `
                        background: #f8f9fa;
                        color: #333;
                        border: 1px solid #dee2e6;
                    `;
                    btn.onmouseover = () => btn.style.background = '#e9ecef';
                    btn.onmouseout = () => btn.style.background = '#f8f9fa';
                }
                
                buttonsContainer.appendChild(btn);
            });
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close on overlay click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            
            // Close on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        /**
         * Show compatibility error modal with detailed guidance
         * @param {string} fileName - Name of the failed file
         */
        function showCompatibilityError(fileName) {
            const message = `
                <p>This GLB file includes features CesiumJS cannot render, such as:</p>
                <ul style="margin: 12px 0; padding-left: 20px; color: #666;">
                    <li>Rigging or animation</li>
                    <li>Advanced shaders/materials</li>
                    <li>Unsupported glTF extensions</li>
                    <li>Too many polygons</li>
                </ul>
                <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 16px 0;">
                    <strong style="color: #007bff;">üí° Quick Fix Tips:</strong>
                    <div style="margin-top: 8px; font-size: 14px; color: #555;">
                        Export a basic GLB with no animations, simplified materials, and under 5MB using Blender.
                    </div>
                </div>
            `;
            
            const buttons = [
                {
                    text: 'Got It',
                    action: () => document.querySelector('.error-modal').remove(),
                    style: 'primary'
                },
                {
                    text: 'How to Fix',
                    action: () => {
                        window.open('https://docs.blender.org/manual/en/latest/addons/import_export/scene_gltf2.html', '_blank');
                    },
                    style: 'secondary'
                }
            ];
            
            showErrorModal('Model Not Compatible', message, buttons);
        }

        /**
         * Load a 3D model at the current camera center position
         * @param {File} file - The GLTF/GLB file to load
         */
        async function loadModelAtCameraCenter(file) {
            console.log('Loading 3D model:', file.name, 'Size:', file.size, 'bytes');
            
            try {
                // Step 1: Validate file format (only .glb/.gltf allowed)
                const formatValidation = validateFileFormat(file);
                if (!formatValidation.isValid) {
                    showErrorModal('Unsupported File Format', formatValidation.message);
                    return;
                }
                
                // Step 2: Validate file size (5MB limit with warning)
                const sizeValidation = validateFileSize(file);
                if (!sizeValidation.isValid) {
                    showErrorModal('Large File Warning', sizeValidation.message, [
                        {
                            text: 'Continue Anyway',
                            action: () => {
                                document.querySelector('.error-modal').remove();
                                proceedWithModelLoading(file);
                            },
                            style: 'primary'
                        },
                        {
                            text: 'Cancel',
                            action: () => document.querySelector('.error-modal').remove(),
                            style: 'secondary'
                        }
                    ]);
                    return;
                }
                
                // Step 3: Validate file integrity
                const integrityValidation = await validateModelFile(file);
                if (!integrityValidation.isValid) {
                    showErrorModal('Invalid File', integrityValidation.message);
                    return;
                }
                
                // All validations passed, proceed with loading
                proceedWithModelLoading(file);
                
            } catch (error) {
                console.error('Error in model validation:', error);
                showErrorModal('Validation Error', 'An error occurred while validating the file. Please try again.');
            }
        }

        /**
         * Proceed with model loading after validation
         * @param {File} file - Validated file to load
         */
        async function proceedWithModelLoading(file) {
            try {
                
                // Get center of camera view coordinates
                const canvas = viewer.canvas;
                const centerX = canvas.clientWidth / 2;
                const centerY = canvas.clientHeight / 2;
                const centerPick = new Cesium.Cartesian2(centerX, centerY);
                
                // Cast ray to find intersection point
                const ray = viewer.camera.getPickRay(centerPick);
                let intersection = viewer.scene.globe.pick(ray, viewer.scene);
                
                // Fallback to ellipsoid intersection if no terrain
                if (!intersection) {
                    const ellipsoidIntersection = Cesium.IntersectionTests.rayEllipsoid(ray, viewer.scene.globe.ellipsoid);
                    if (ellipsoidIntersection) {
                        intersection = Cesium.Ray.getPoint(ray, ellipsoidIntersection.start);
                    }
                }
                
                if (!intersection) {
                    console.warn('Could not determine model placement position');
                    alert('Could not determine placement position. Please try from a different view.');
                    return;
                }
                
                // Convert to geographic coordinates
                const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                const height = cartographic.height + 10; // Slightly above ground
                
                console.log(`Placing model at: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}, height: ${height.toFixed(2)}m`);
                
                // Create blob URL for the file
                const modelUrl = URL.createObjectURL(file);
                console.log('Created blob URL:', modelUrl);
                
                // Show loading indicator
                const loadingMessage = document.createElement('div');
                loadingMessage.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0,0,0,0.8);
                    color: white;
                    padding: 20px;
                    border-radius: 8px;
                    z-index: 10000;
                    font-family: Arial, sans-serif;
                `;
                loadingMessage.textContent = 'Loading 3D model...';
                document.body.appendChild(loadingMessage);
                
                // Set up comprehensive error handling and camera protection
                let modelLoadFailed = false;
                let modelEntity = null;
                let errorRecoveryTimeout = null;
                
                // Store current camera state for recovery
                const cameraBackup = {
                    position: viewer.camera.position.clone(),
                    direction: viewer.camera.direction.clone(),
                    up: viewer.camera.up.clone(),
                    right: viewer.camera.right.clone()
                };
                
                // Function to restore camera controls and clean up
                const restoreCameraControls = () => {
                    try {
                        // Force enable camera controls
                        viewer.scene.screenSpaceCameraController.enableRotate = true;
                        viewer.scene.screenSpaceCameraController.enableTranslate = true;
                        viewer.scene.screenSpaceCameraController.enableZoom = true;
                        viewer.scene.screenSpaceCameraController.enableTilt = true;
                        viewer.scene.screenSpaceCameraController.enableLook = true;
                        
                        // Reset camera if needed
                        if (viewer.camera.position.equals(Cesium.Cartesian3.ZERO)) {
                            viewer.camera.position = cameraBackup.position;
                            viewer.camera.direction = cameraBackup.direction;
                            viewer.camera.up = cameraBackup.up;
                            viewer.camera.right = cameraBackup.right;
                        }
                        
                        // Force scene update
                        viewer.scene.requestRender();
                        console.log('Camera controls restored successfully');
                    } catch (error) {
                        console.warn('Camera restoration error:', error);
                    }
                };
                
                // Override console.error to catch CesiumJS model errors
                const originalConsoleError = console.error;
                const errorHandler = function(...args) {
                    const errorString = args.join(' ');
                    if (!modelLoadFailed && (
                        errorString.includes('midpoint') || 
                        errorString.includes('incrementallyLoadTextures') || 
                        errorString.includes('Cannot read properties of undefined') ||
                        errorString.includes('reading \'x\'') ||
                        errorString.includes('fromCornerPoints') ||
                        errorString.includes('new yue') ||
                        errorString.includes('buildDrawCommands') ||
                        errorString.includes('Ske') ||
                        errorString.includes('To.update') ||
                        errorString.includes('pn.fromCornerPoints') ||
                        errorString.includes('qs.update') ||
                        errorString.includes('Yl.updateAndExecuteCommands') ||
                        errorString.includes('AttributeType.SCALAR') ||
                        errorString.includes('ModelExperimental')
                    )) {
                        modelLoadFailed = true;
                        console.warn('3D model compatibility error detected');
                        
                        // Immediate camera control restoration
                        restoreCameraControls();
                        
                        // Clean up loading indicator
                        if (document.body.contains(loadingMessage)) {
                            document.body.removeChild(loadingMessage);
                        }
                        
                        // Remove failed model entity if it exists
                        if (modelEntity) {
                            try {
                                viewer.entities.remove(modelEntity);
                            } catch (e) {
                                console.warn('Error removing failed model entity:', e);
                            }
                        }
                        
                        URL.revokeObjectURL(modelUrl);
                        
                        // Clear any pending timeouts
                        if (errorRecoveryTimeout) {
                            clearTimeout(errorRecoveryTimeout);
                        }
                        
                        // Show compatibility error modal
                        showCompatibilityError(file.name);
                        
                        // Place a marker at the intended location
                        try {
                            viewer.entities.add({
                                name: `Failed Model - ${file.name}`,
                                position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                                point: {
                                    pixelSize: 12,
                                    color: Cesium.Color.RED,
                                    outlineColor: Cesium.Color.WHITE,
                                    outlineWidth: 2
                                },
                                label: {
                                    text: `‚ùå ${file.name}`,
                                    font: '11pt Arial',
                                    fillColor: Cesium.Color.WHITE,
                                    outlineColor: Cesium.Color.BLACK,
                                    outlineWidth: 1,
                                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                    pixelOffset: new Cesium.Cartesian2(0, -30)
                                }
                            });
                            
                            viewer.camera.setView({
                                destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 100),
                                orientation: {
                                    heading: 0,
                                    pitch: Cesium.Math.toRadians(-30),
                                    roll: 0
                                }
                            });
                        } catch (markerError) {
                            console.warn('Could not place error marker:', markerError);
                        }
                        
                        // Auto-remove error message
                        setTimeout(function() {
                            if (document.body.contains(errorDiv)) {
                                document.body.removeChild(errorDiv);
                            }
                        }, 8000);
                        
                        return;
                    }
                    originalConsoleError.apply(console, args);
                };
                
                console.error = errorHandler;
                
                // Create a simple point marker as fallback visualization
                const fallbackEntity = viewer.entities.add({
                    name: `Model Location - ${file.name}`,
                    position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                    point: {
                        pixelSize: 15,
                        color: Cesium.Color.YELLOW,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                    },
                    label: {
                        text: `üì¶ ${file.name}`,
                        font: '12pt Arial',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        pixelOffset: new Cesium.Cartesian2(0, -40),
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                    }
                });
                
                console.log('Created fallback marker for model location');
                
                // Try to load the 3D model with simplified approach
                try {
                    console.log('Attempting to load 3D model...');
                    
                    // Use readyPromise for proper error handling
                    modelEntity = viewer.entities.add({
                        name: `3D Model - ${file.name}`,
                        position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                        model: {
                            uri: modelUrl,
                            scale: 1.0,
                            minimumPixelSize: 32,
                            maximumScale: 1000,
                            runAnimations: false,
                            clampAnimations: true,
                            heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                            // Enhanced compatibility settings
                            silhouetteColor: Cesium.Color.TRANSPARENT,
                            silhouetteSize: 0,
                            incrementallyLoadTextures: false,
                            backFaceCulling: true,
                            shadows: Cesium.ShadowMode.DISABLED
                        }
                    });
                    
                    // Handle model loading with readyPromise
                    if (modelEntity.model.readyPromise) {
                        modelEntity.model.readyPromise
                            .then(() => {
                                if (!modelLoadFailed) {
                                    console.log('Model loaded successfully via readyPromise');
                                    
                                    // Clean up loading indicator
                                    if (document.body.contains(loadingMessage)) {
                                        document.body.removeChild(loadingMessage);
                                    }
                                    
                                    // Remove fallback marker
                                    viewer.entities.remove(fallbackEntity);
                                    
                                    // Restore console.error
                                    console.error = originalConsoleError;
                                    
                                    // Fly to model
                                    viewer.camera.setView({
                                        destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 50),
                                        orientation: {
                                            heading: 0,
                                            pitch: Cesium.Math.toRadians(-30),
                                            roll: 0
                                        }
                                    });
                                }
                            })
                            .catch((error) => {
                                if (!modelLoadFailed) {
                                    console.warn('Model readyPromise failed:', error);
                                    modelLoadFailed = true;
                                    
                                    // Clean up
                                    if (document.body.contains(loadingMessage)) {
                                        document.body.removeChild(loadingMessage);
                                    }
                                    
                                    if (modelEntity) {
                                        try {
                                            viewer.entities.remove(modelEntity);
                                        } catch (e) {
                                            console.warn('Error removing failed model:', e);
                                        }
                                    }
                                    
                                    restoreCameraControls();
                                    console.error = originalConsoleError;
                                    URL.revokeObjectURL(modelUrl);
                                    
                                    // Show compatibility error
                                    showCompatibilityError(file.name);
                                }
                            });
                    }
                    
                    // Set up monitoring for successful model loading
                    let loadingTimeout;
                    let checkModelLoaded = false;
                    
                    const checkIfModelLoaded = () => {
                        if (modelLoadFailed) return;
                        
                        try {
                            // Check if model has loaded successfully
                            if (modelEntity.model && modelEntity.model.readyPromise) {
                                modelEntity.model.readyPromise.then(() => {
                                    if (!modelLoadFailed) {
                                        // Model loaded successfully
                                        console.log('Model loaded successfully');
                                        checkModelLoaded = true;
                                        
                                        // Remove loading indicator
                                        if (document.body.contains(loadingMessage)) {
                                            document.body.removeChild(loadingMessage);
                                        }
                                        
                                        // Remove fallback marker since model loaded
                                        viewer.entities.remove(fallbackEntity);
                                        
                                        // Restore console.error
                                        console.error = originalConsoleError;
                                        
                                        // Clear monitoring timeout
                                        if (loadingTimeout) {
                                            clearTimeout(loadingTimeout);
                                        }
                                        
                                        // Fly to model
                                        viewer.camera.setView({
                                            destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 50),
                                            orientation: {
                                                heading: 0,
                                                pitch: Cesium.Math.toRadians(-30),
                                                roll: 0
                                            }
                                        });
                                    }
                                }).catch((error) => {
                                    if (!modelLoadFailed) {
                                        console.warn('Model ready promise failed:', error);
                                        errorHandler(['Model loading failed during ready promise']);
                                    }
                                });
                            }
                        } catch (checkError) {
                            console.warn('Error checking model load status:', checkError);
                        }
                    };
                    
                    // Start monitoring
                    setTimeout(checkIfModelLoaded, 500);
                    
                    // Fallback timeout for problematic models
                    loadingTimeout = setTimeout(() => {
                        if (!checkModelLoaded && !modelLoadFailed) {
                            console.log('Model loading failed, showing fallback marker');
                            modelLoadFailed = true;
                            
                            // Clean up loading indicator
                            if (document.body.contains(loadingMessage)) {
                                document.body.removeChild(loadingMessage);
                            }
                            
                            // Remove model entity
                            if (modelEntity) {
                                try {
                                    viewer.entities.remove(modelEntity);
                                } catch (e) {
                                    console.warn('Error removing timeout model entity:', e);
                                }
                            }
                            
                            // Restore camera controls
                            restoreCameraControls();
                            
                            // Restore console.error
                            console.error = originalConsoleError;
                            
                            URL.revokeObjectURL(modelUrl);
                            
                            // Show timeout modal
                            showErrorModal(
                                'Model Loading Timeout',
                                `The model is taking too long to load. This could indicate compatibility issues.
                                <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 16px 0;">
                                    <strong style="color: #007bff;">üí° Try This:</strong>
                                    <ul style="margin: 8px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>Use a smaller file (under 5MB)</li>
                                        <li>Export with basic materials only</li>
                                        <li>Disable animations before export</li>
                                    </ul>
                                </div>`
                            );
                        }
                    }, 8000); // 8 second timeout
                    
                } catch (modelError) {
                    console.error('Error creating model entity:', modelError);
                    // Restore original console.error
                    console.error = originalConsoleError;
                    
                    if (document.body.contains(loadingMessage)) {
                        document.body.removeChild(loadingMessage);
                    }
                    
                    // Show fallback marker
                    viewer.camera.setView({
                        destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 100),
                        orientation: {
                            heading: 0,
                            pitch: Cesium.Math.toRadians(-30),
                            roll: 0
                        }
                    });
                    
                    showErrorModal('Model Loading Error', 'Could not load 3D model. A marker has been placed at the location.');
                    URL.revokeObjectURL(modelUrl);
                }
                
            } catch (error) {
                console.error('Error in model loading process:', error);
                showErrorModal('Processing Error', 'Error processing 3D model file: ' + error.message);
            }
        }

        // Global camera restoration function for emergency recovery
        window.restoreCameraControls = function() {
            try {
                if (viewer && viewer.scene && viewer.scene.screenSpaceCameraController) {
                    viewer.scene.screenSpaceCameraController.enableRotate = true;
                    viewer.scene.screenSpaceCameraController.enableTranslate = true;
                    viewer.scene.screenSpaceCameraController.enableZoom = true;
                    viewer.scene.screenSpaceCameraController.enableTilt = true;
                    viewer.scene.screenSpaceCameraController.enableLook = true;
                    viewer.scene.requestRender();
                    console.log('Global camera controls restored');
                }
            } catch (error) {
                console.warn('Global camera restoration error:', error);
            }
        };

        /**
         * Show sample compatible 3D models for testing
         */
        function showSampleModels() {
            const sampleDiv = document.createElement('div');
            sampleDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(44, 62, 80, 0.95);
                color: white;
                padding: 25px;
                border-radius: 12px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                max-width: 550px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            sampleDiv.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #52c41a;">Test with Compatible Models</h3>
                <div style="text-align: left; margin-bottom: 20px;">
                    <p style="margin-bottom: 15px;">Try these known CesiumJS-compatible sources:</p>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                        <strong>üåê Free 3D Model Sites:</strong>
                        <ul style="font-size: 13px; line-height: 1.6; margin-top: 8px;">
                            <li><strong>Cesium Sandcastle</strong> - Official examples with GLB models</li>
                            <li><strong>Khronos Group</strong> - Official GLTF sample models</li>
                            <li><strong>Sketchfab</strong> - Filter by "Downloadable" + "GLTF"</li>
                            <li><strong>Poly Haven</strong> - Simple objects, good for testing</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px;">
                        <strong>‚úÖ What Works Best:</strong>
                        <ul style="font-size: 13px; line-height: 1.6; margin-top: 8px;">
                            <li>Simple geometric objects (cubes, spheres, vehicles)</li>
                            <li>Models under 5MB with basic materials</li>
                            <li>GLTF 2.0 format without custom extensions</li>
                            <li>Static models without skeletal animation</li>
                        </ul>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="openModelSources(); this.parentElement.parentElement.remove();" style="background: #52c41a; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Find Models</button>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">Close</button>
                </div>
            `;
            document.body.appendChild(sampleDiv);
        }

        /**
         * Open useful 3D model sources in new tabs
         */
        function openModelSources() {
            // Open multiple useful sources for finding compatible 3D models
            const sources = [
                'https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0',
                'https://sketchfab.com/3d-models?features=downloadable&sort_by=-likeCount&file_formats=gltf',
                'https://polyhaven.com/models',
                'https://sandcastle.cesium.com/?src=3D%20Models.html'
            ];
            
            // Open first two sources (avoid popup blockers)
            sources.slice(0, 2).forEach((url, index) => {
                setTimeout(() => {
                    window.open(url, '_blank');
                }, index * 100); // Small delay to avoid popup blocker
            });
            
            // Show message about additional sources
            setTimeout(() => {
                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(52, 152, 219, 0.95);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    z-index: 10002;
                    font-family: Arial, sans-serif;
                    max-width: 300px;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                `;
                infoDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;">üåê Model Sources Opened</div>
                    <div style="font-size: 13px; line-height: 1.4;">
                        Check your new tabs for:<br>
                        ‚Ä¢ Khronos GLTF samples<br>
                        ‚Ä¢ Sketchfab downloadable models<br>
                        <br>
                        <span style="opacity: 0.9;">Look for small, simple GLB files under 5MB</span>
                    </div>
                    <button onclick="this.parentElement.remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-top: 10px;">Got it</button>
                `;
                document.body.appendChild(infoDiv);
                
                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (document.body.contains(infoDiv)) {
                        infoDiv.remove();
                    }
                }, 8000);
            }, 500);
        }

        /**
         * Show alternatives for incompatible models
         */
        function showModelAlternatives() {
            const altDiv = document.createElement('div');
            altDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(52, 73, 94, 0.95);
                color: white;
                padding: 25px;
                border-radius: 12px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                max-width: 500px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            altDiv.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #3498db;">Alternative Solutions</h3>
                <div style="text-align: left; margin-bottom: 20px;">
                    <p style="margin-bottom: 15px;"><strong>Free 3D Model Converters:</strong></p>
                    <ul style="font-size: 13px; line-height: 1.6;">
                        <li><strong>Blender</strong> - Free, powerful 3D software with GLTF export</li>
                        <li><strong>Sketchfab</strong> - Online model viewer with download options</li>
                        <li><strong>Three.js Editor</strong> - Web-based GLTF optimizer</li>
                        <li><strong>gltf-pipeline</strong> - Command line GLTF optimizer</li>
                    </ul>
                    
                    <p style="margin: 15px 0 10px 0;"><strong>Quick Export Tips:</strong></p>
                    <ul style="font-size: 13px; line-height: 1.6;">
                        <li>In Blender: File ‚Üí Export ‚Üí glTF 2.0 ‚Üí "Include: Selected Objects"</li>
                        <li>Disable "Include Animations" and "Apply Modifiers"</li>
                        <li>Use "GLTF Separate" format instead of "GLTF Binary"</li>
                        <li>Reduce polygon count with Decimate modifier</li>
                    </ul>
                </div>
                <button onclick="this.parentElement.remove()" style="background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">Got It</button>
            `;
            document.body.appendChild(altDiv);
        }

        // Measurement tool state and variables
        let measurementTool = {
            isActive: false,
            mode: 'line', // 'line', 'area', 'vertical'
            units: 'metric', // 'metric', 'imperial'
            points: [],
            entities: [],
            activePoints: [],
            clickHandler: null,
            results: {}
        };

        /**
         * Toggle measurement tool visibility and functionality
         */
        function toggleMeasurementTool() {
            const measurementControls = document.getElementById('measurementControls');
            
            if (measurementControls.style.display === 'none') {
                measurementControls.style.display = 'block';
                measurementTool.isActive = true;
                startMeasurement();
            } else {
                measurementControls.style.display = 'none';
                measurementTool.isActive = false;
                stopMeasurement();
            }
        }

        /**
         * Set measurement mode (line, area, vertical)
         */
        function setMeasurementMode(mode) {
            // Update UI
            document.querySelectorAll('.measurement-mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            
            // Update measurement state
            measurementTool.mode = mode;
            newMeasurement();
            
            // Update instructions
            updateInstructions();
        }

        /**
         * Update measurement instructions based on current mode
         */
        function updateInstructions() {
            const instructionsEl = document.getElementById('measurementInstructions');
            
            switch(measurementTool.mode) {
                case 'line':
                    instructionsEl.textContent = 'Click two points to measure distance';
                    break;
                case 'area':
                    instructionsEl.textContent = 'Click points to create area boundary (double-click to finish)';
                    break;
                case 'vertical':
                    instructionsEl.textContent = 'Click two points to measure vertical distance';
                    break;
                default:
                    instructionsEl.textContent = 'Select measurement mode';
            }
        }

        /**
         * Start measurement functionality
         */
        function startMeasurement() {
            if (!viewer || !measurementTool.isActive) return;
            
            // Disable default click behavior temporarily
            viewer.cesiumWidget.screenSpaceEventHandler.setInputAction(function(event) {
                handleMeasurementClick(event);
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
            
            updateInstructions();
        }

        /**
         * Stop measurement functionality
         */
        function stopMeasurement() {
            if (!viewer) return;
            
            // Re-enable default click behavior
            viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }

        /**
         * Handle click events for measurement
         */
        function handleMeasurementClick(event) {
            if (!measurementTool.isActive) return;
            
            // Pick position on globe/terrain
            const pickedPosition = viewer.camera.pickEllipsoid(event.position, viewer.scene.globe.ellipsoid);
            if (!pickedPosition) return;
            
            measurementTool.activePoints.push(pickedPosition);
            
            // Add visual point marker
            addPointMarker(pickedPosition, measurementTool.activePoints.length);
            
            // Handle different measurement modes
            switch(measurementTool.mode) {
                case 'line':
                case 'vertical':
                    if (measurementTool.activePoints.length === 2) {
                        completeMeasurement();
                    }
                    break;
                case 'area':
                    if (measurementTool.activePoints.length >= 3) {
                        // Area measurement requires at least 3 points
                        // Will be completed with double-click or explicit finish
                        updateAreaMeasurement();
                    }
                    break;
            }
        }

        /**
         * Update area measurement (for incremental area updates)
         */
        function updateAreaMeasurement() {
            if (measurementTool.activePoints.length >= 3) {
                // Clear previous area visualization
                measurementTool.entities.forEach(entity => {
                    if (entity.polygon) {
                        viewer.entities.remove(entity);
                    }
                });
                
                // Draw current area
                drawAreaPolygon();
                
                // Calculate and display current results
                const results = calculateAreaMeasurement();
                measurementTool.results = results;
                displayResults(results);
            }
        }

        /**
         * Add visual point marker
         */
        function addPointMarker(position, pointNumber) {
            const pointEntity = viewer.entities.add({
                position: position,
                point: {
                    pixelSize: 8,
                    color: Cesium.Color.ORANGE,
                    outlineColor: Cesium.Color.WHITE,
                    outlineWidth: 2,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                },
                label: {
                    text: pointNumber.toString(),
                    font: '12pt Arial',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    pixelOffset: new Cesium.Cartesian2(0, -20),
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                }
            });
            
            measurementTool.entities.push(pointEntity);
        }

        /**
         * Complete measurement and show results
         */
        function completeMeasurement() {
            if (measurementTool.activePoints.length < 2) return;
            
            let results = {};
            
            if (measurementTool.mode === 'line') {
                results = calculateLineDistance();
                drawMeasurementLine();
            } else if (measurementTool.mode === 'vertical') {
                results = calculateVerticalDistance();
                drawMeasurementLine();
            } else if (measurementTool.mode === 'area') {
                results = calculateAreaMeasurement();
                drawAreaPolygon();
            }
            
            measurementTool.results = results;
            displayResults(results);
        }

        /**
         * Calculate line distance measurements
         */
        function calculateLineDistance() {
            const point1 = measurementTool.activePoints[0];
            const point2 = measurementTool.activePoints[1];
            
            // Convert to cartographic for height information
            const cartographic1 = Cesium.Cartographic.fromCartesian(point1);
            const cartographic2 = Cesium.Cartographic.fromCartesian(point2);
            
            // Calculate 3D direct distance
            const distance3D = Cesium.Cartesian3.distance(point1, point2);
            
            // Calculate horizontal distance (geodesic distance on ellipsoid)
            const geodesic = new Cesium.EllipsoidGeodesic(cartographic1, cartographic2);
            const horizontalDistance = geodesic.surfaceDistance || 0;
            
            // Calculate vertical distance (ensure heights are valid)
            const height1 = cartographic1.height || 0;
            const height2 = cartographic2.height || 0;
            const verticalDistance = Math.abs(height2 - height1);
            
            // Calculate slope and azimuth (with safety checks)
            const slope = horizontalDistance > 0 ? verticalDistance / horizontalDistance : 0;
            const slopeAngle = Math.atan(slope) * (180 / Math.PI);
            
            // Get azimuth (heading) with fallback
            let azimuth = 0;
            try {
                azimuth = (geodesic.startHeading || 0) * (180 / Math.PI);
                // Normalize azimuth to 0-360 degrees
                azimuth = azimuth < 0 ? azimuth + 360 : azimuth;
            } catch (e) {
                console.warn('Azimuth calculation failed:', e);
                azimuth = 0;
            }
            
            return {
                direct: distance3D || 0,
                horizontal: horizontalDistance || 0,
                vertical: verticalDistance || 0,
                slope: slopeAngle || 0,
                azimuth: azimuth || 0,
                point1Height: height1,
                point2Height: height2
            };
        }

        /**
         * Calculate vertical distance measurements
         */
        function calculateVerticalDistance() {
            const results = calculateLineDistance();
            return {
                vertical: results.vertical,
                point1Height: results.point1Height,
                point2Height: results.point2Height,
                heightDifference: results.point2Height - results.point1Height
            };
        }

        /**
         * Calculate area measurement (simplified polygon area)
         */
        function calculateAreaMeasurement() {
            if (measurementTool.activePoints.length < 3) return {};
            
            // Convert points to cartographic
            const cartographicPoints = measurementTool.activePoints.map(point => 
                Cesium.Cartographic.fromCartesian(point)
            );
            
            // Calculate approximate area using spherical excess method
            let area = 0;
            const R = 6371000; // Earth radius in meters
            
            for (let i = 0; i < cartographicPoints.length; i++) {
                const j = (i + 1) % cartographicPoints.length;
                const lat1 = cartographicPoints[i].latitude;
                const lon1 = cartographicPoints[i].longitude;
                const lat2 = cartographicPoints[j].latitude;
                const lon2 = cartographicPoints[j].longitude;
                
                area += (lon2 - lon1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }
            
            area = Math.abs(area * R * R / 2);
            
            // Calculate perimeter
            let perimeter = 0;
            for (let i = 0; i < measurementTool.activePoints.length; i++) {
                const j = (i + 1) % measurementTool.activePoints.length;
                perimeter += Cesium.Cartesian3.distance(
                    measurementTool.activePoints[i], 
                    measurementTool.activePoints[j]
                );
            }
            
            return {
                area: area,
                perimeter: perimeter,
                points: measurementTool.activePoints.length
            };
        }

        /**
         * Draw measurement line between points
         */
        function drawMeasurementLine() {
            const lineEntity = viewer.entities.add({
                polyline: {
                    positions: measurementTool.activePoints,
                    width: 3,
                    material: Cesium.Color.ORANGE,
                    clampToGround: true
                }
            });
            
            measurementTool.entities.push(lineEntity);
            
            // Add distance label at midpoint
            if (measurementTool.activePoints.length === 2) {
                const midpoint = Cesium.Cartesian3.midpoint(
                    measurementTool.activePoints[0],
                    measurementTool.activePoints[1],
                    new Cesium.Cartesian3()
                );
                
                const distance = formatDistance(measurementTool.results.direct || measurementTool.results.vertical);
                
                const labelEntity = viewer.entities.add({
                    position: midpoint,
                    label: {
                        text: distance,
                        font: '14pt Arial',
                        fillColor: Cesium.Color.ORANGE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        pixelOffset: new Cesium.Cartesian2(0, -30),
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                    }
                });
                
                measurementTool.entities.push(labelEntity);
            }
        }

        /**
         * Draw area polygon
         */
        function drawAreaPolygon() {
            const polygonEntity = viewer.entities.add({
                polygon: {
                    hierarchy: measurementTool.activePoints,
                    material: Cesium.Color.ORANGE.withAlpha(0.3),
                    outline: true,
                    outlineColor: Cesium.Color.ORANGE,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                }
            });
            
            measurementTool.entities.push(polygonEntity);
        }

        /**
         * Format distance value based on current units
         */
        function formatDistance(meters) {
            // Ensure meters is a valid number
            const validMeters = parseFloat(meters) || 0;
            
            if (measurementTool.units === 'metric') {
                if (validMeters >= 1000) {
                    return (validMeters / 1000).toFixed(2) + ' km';
                } else {
                    return validMeters.toFixed(2) + ' m';
                }
            } else {
                const feet = validMeters * 3.28084;
                if (feet >= 5280) {
                    return (feet / 5280).toFixed(2) + ' mi';
                } else {
                    return feet.toFixed(2) + ' ft';
                }
            }
        }

        /**
         * Format area value based on current units
         */
        function formatArea(squareMeters) {
            // Ensure squareMeters is a valid number
            const validSquareMeters = parseFloat(squareMeters) || 0;
            
            if (measurementTool.units === 'metric') {
                if (validSquareMeters >= 10000) {
                    return (validSquareMeters / 10000).toFixed(2) + ' ha';
                } else {
                    return validSquareMeters.toFixed(2) + ' m¬≤';
                }
            } else {
                const squareFeet = validSquareMeters * 10.7639;
                if (squareFeet >= 43560) {
                    return (squareFeet / 43560).toFixed(2) + ' acres';
                } else {
                    return squareFeet.toFixed(2) + ' ft¬≤';
                }
            }
        }

        /**
         * Display measurement results in the UI
         */
        function displayResults(results) {
            const resultsEl = document.getElementById('measurementResults');
            let html = '';
            
            // Add debugging
            console.log('Display results called with:', results);
            
            try {
                if (measurementTool.mode === 'line') {
                    html = `
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Direct Distance:</span>
                            <span class="measurement-result-value">${formatDistance(results.direct || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Horizontal:</span>
                            <span class="measurement-result-value">${formatDistance(results.horizontal || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Vertical:</span>
                            <span class="measurement-result-value">${formatDistance(results.vertical || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Slope:</span>
                            <span class="measurement-result-value">${(parseFloat(results.slope) || 0).toFixed(1)}¬∞</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Azimuth:</span>
                            <span class="measurement-result-value">${(parseFloat(results.azimuth) || 0).toFixed(1)}¬∞</span>
                        </div>
                    `;
                } else if (measurementTool.mode === 'vertical') {
                    html = `
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Vertical Distance:</span>
                            <span class="measurement-result-value">${formatDistance(results.vertical || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Height Difference:</span>
                            <span class="measurement-result-value">${formatDistance(Math.abs(results.heightDifference || 0))}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Point 1 Height:</span>
                            <span class="measurement-result-value">${formatDistance(results.point1Height || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Point 2 Height:</span>
                            <span class="measurement-result-value">${formatDistance(results.point2Height || 0)}</span>
                        </div>
                    `;
                } else if (measurementTool.mode === 'area') {
                    html = `
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Area:</span>
                            <span class="measurement-result-value">${formatArea(results.area || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Perimeter:</span>
                            <span class="measurement-result-value">${formatDistance(results.perimeter || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Points:</span>
                            <span class="measurement-result-value">${results.points || 0}</span>
                        </div>
                    `;
                }
                
                resultsEl.innerHTML = html;
            } catch (error) {
                console.error('Error displaying results:', error);
                resultsEl.innerHTML = `
                    <div style="text-align: center; color: #ff6b6b; font-size: 11px; margin-top: 15px;">
                        Error displaying measurements
                    </div>
                `;
            }
        }

        /**
         * Update measurement units and refresh display
         */
        function updateMeasurementUnits() {
            const unitsSelect = document.getElementById('measurementUnits');
            measurementTool.units = unitsSelect.value;
            
            // Refresh results display if we have results
            if (Object.keys(measurementTool.results).length > 0) {
                displayResults(measurementTool.results);
                
                // Update line labels if present
                updateLineLabels();
            }
        }

        /**
         * Update line labels with new units
         */
        function updateLineLabels() {
            // Remove existing line labels and redraw
            measurementTool.entities.forEach(entity => {
                if (entity.label) {
                    viewer.entities.remove(entity);
                }
            });
            
            // Redraw measurement line to update labels
            if (measurementTool.mode === 'line' || measurementTool.mode === 'vertical') {
                drawMeasurementLine();
            }
        }

        /**
         * Start new measurement (clear current)
         */
        function newMeasurement() {
            clearCurrentMeasurement();
            measurementTool.activePoints = [];
            measurementTool.results = {};
            
            // Reset results display
            const resultsEl = document.getElementById('measurementResults');
            resultsEl.innerHTML = `
                <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 15px;">
                    No measurements yet
                </div>
            `;
            
            updateInstructions();
        }

        /**
         * Clear current measurement entities
         */
        function clearCurrentMeasurement() {
            measurementTool.entities.forEach(entity => {
                viewer.entities.remove(entity);
            });
            measurementTool.entities = [];
        }

        /**
         * Clear all measurements
         */
        function clearMeasurements() {
            clearCurrentMeasurement();
            measurementTool.activePoints = [];
            measurementTool.results = {};
            
            // Reset results display
            const resultsEl = document.getElementById('measurementResults');
            resultsEl.innerHTML = `
                <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 15px;">
                    No measurements yet
                </div>
            `;
            
            updateInstructions();
        }

        /**
         * Toggle atmospheric effects for 3D visualization
         */
        function toggleAtmosphere() {
            const toggle = document.getElementById('atmosphereToggle');
            const enabled = toggle.checked;
            
            // Only toggle fog to avoid lighting-related errors
            viewer.scene.fog.enabled = enabled;
            
            // Adjust fog density for better 3D depth effect
            if (enabled) {
                viewer.scene.fog.density = 0.0003;
                viewer.scene.fog.screenSpaceErrorFactor = 2.0;
            } else {
                viewer.scene.fog.density = 0.0;
            }
            
            console.log('3D fog effects:', enabled ? 'enabled' : 'disabled');
        }

        /**
         * Switch base map provider
         */
        function switchBaseMap() {
            const selectElement = document.getElementById('basemapSelect');
            const attributionElement = document.getElementById('basemapAttribution');
            const selectedMap = selectElement.value;
            
            if (baseMaps[selectedMap]) {
                try {
                    // Remove current imagery layers
                    viewer.imageryLayers.removeAll();
                    
                    // Add new imagery provider
                    viewer.imageryLayers.addImageryProvider(baseMaps[selectedMap].provider());
                    
                    // Update attribution
                    attributionElement.textContent = baseMaps[selectedMap].attribution;
                    
                    // Update current base map
                    currentBaseMap = selectedMap;
                    
                    console.log(`Switched to base map: ${selectedMap}`);
                } catch (error) {
                    console.error('Error switching base map:', error);
                    
                    // Fallback to OpenStreetMap on error
                    if (selectedMap !== 'osm') {
                        selectElement.value = 'osm';
                        viewer.imageryLayers.removeAll();
                        viewer.imageryLayers.addImageryProvider(baseMaps['osm'].provider());
                        attributionElement.textContent = baseMaps['osm'].attribution;
                        currentBaseMap = 'osm';
                    }
                }
            }
        }

        /**
         * Initialize drag and drop functionality for 3D models
         */
        function initializeDragAndDrop() {
            let dragCounter = 0;
            
            // Prevent default drag behaviors on document
            document.addEventListener('dragenter', function(e) {
                e.preventDefault();
                dragCounter++;
                
                // Check if dragged item contains files
                if (e.dataTransfer.types.includes('Files')) {
                    dragDropOverlay.style.display = 'flex';
                }
            });
            
            document.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dragCounter--;
                
                if (dragCounter === 0) {
                    dragDropOverlay.style.display = 'none';
                }
            });
            
            document.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            document.addEventListener('drop', function(e) {
                e.preventDefault();
                dragCounter = 0;
                dragDropOverlay.style.display = 'none';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const fileName = file.name.toLowerCase();
                    
                    // Check if it's a 3D model file
                    const formatInfo = check3DFileFormat(file.name);
                    
                    if (formatInfo.isKnown3D) {
                        loadModelAtCameraCenter(file);
                    } else {
                        alert('File not recognized as a 3D model. Supported: .glb, .gltf, .obj, .fbx, .dae, .stl, .ply, .las, .dxf, .usdz');
                    }
                }
            });
            
            // Also handle file input for alternative upload method
            modelFileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    loadModelAtCameraCenter(file);
                    // Clear input for future uploads
                    e.target.value = '';
                }
            });
            
            console.log('Drag and drop for 3D models initialized');
        }

        // Initialize coordinate tracking after viewer is ready
        setTimeout(() => {
            // Verify all elements exist before initializing
            console.log('Checking elements:');
            console.log('- northArrow:', !!northArrow);
            console.log('- coordinatesText:', !!coordinatesText);
            console.log('- scaleLine:', !!scaleLine);
            console.log('- scaleText:', !!scaleText);
            console.log('- baseLayerToggle:', !!baseLayerToggle);
            
            initializeCoordinateTracking();
            initializeLayerControls();
            initializeDragAndDrop();
        }, 100);

        /**
         * Interactive Marker Placement System
         * 
         * Enables users to click on the globe to place red markers at specific locations.
         * Each marker displays a label and can be managed through the marker collection.
         */

        // Marker management system
        let markerCounter = 0;
        const markers = new Map(); // Store markers with unique IDs for potential future management

        /**
         * Creates a red marker billboard at specified coordinates
         * @param {number} longitude - Longitude in degrees
         * @param {number} latitude - Latitude in degrees
         * @param {string} label - Display label for the marker
         * @returns {Object} Created marker entity
         */
        function createMarker(longitude, latitude, label) {
            const markerId = `marker_${++markerCounter}`;
            
            const marker = viewer.entities.add({
                id: markerId,
                position: Cesium.Cartesian3.fromDegrees(longitude, latitude),
                billboard: {
                    image: createMarkerPin(), // Custom red pin graphic
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    scale: 1.0,
                    pixelOffset: new Cesium.Cartesian2(0, 0), // Remove offset for exact positioning
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                },
                label: {
                    text: label,
                    font: '12pt sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -36), // Adjust label position relative to marker
                    disableDepthTestDistance: Number.POSITIVE_INFINITY
                }
            });

            // Store marker reference for potential future management
            markers.set(markerId, {
                entity: marker,
                coordinates: { longitude, latitude },
                label: label,
                timestamp: new Date()
            });

            return marker;
        }

        /**
         * Creates a red marker pin graphic with precise bottom point positioning
         * @returns {HTMLCanvasElement} Canvas element containing the marker graphic
         */
        function createMarkerPin() {
            const canvas = document.createElement('canvas');
            canvas.width = 24;
            canvas.height = 36;
            const ctx = canvas.getContext('2d');

            // Draw red marker pin shape with precise positioning
            ctx.fillStyle = '#FF0000';
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 2;

            // Main pin body (circle) - positioned higher to accommodate point
            ctx.beginPath();
            ctx.arc(12, 10, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Pin point (triangle) - precise tip at bottom center
            ctx.beginPath();
            ctx.moveTo(12, 36); // Bottom point (exact click position)
            ctx.lineTo(6, 18);  // Left side of point
            ctx.lineTo(18, 18); // Right side of point
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Inner white dot
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(12, 10, 3, 0, 2 * Math.PI);
            ctx.fill();

            return canvas;
        }

        /**
         * Handles click events on the globe for marker placement
         * Uses precise ellipsoid intersection for exact positioning
         * @param {ClickEvent} event - Cesium click event
         */
        function handleGlobeClick(event) {
            try {
                // Use direct ellipsoid picking for most accurate positioning
                const ellipsoid = viewer.scene.globe.ellipsoid;
                const cartesian = viewer.camera.pickEllipsoid(event.position, ellipsoid);
                
                if (cartesian) {
                    // Convert Cartesian coordinates to geographic coordinates
                    const cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                    // Create marker with sequential numbering
                    const label = `Point ${markerCounter + 1}`;
                    const marker = createMarker(longitude, latitude, label);

                    console.log(`Marker placed at: ${latitude.toFixed(6)}¬∞, ${longitude.toFixed(6)}¬∞ (${label})`);
                } else {
                    // Secondary method: Try scene picking for terrain intersection
                    const pickedObject = viewer.scene.pick(event.position);
                    if (pickedObject && pickedObject.primitive) {
                        const ray = viewer.camera.getPickRay(event.position);
                        const intersection = viewer.scene.globe.pick(ray, viewer.scene);
                        
                        if (intersection) {
                            const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                            const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                            const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                            const label = `Point ${markerCounter + 1}`;
                            const marker = createMarker(longitude, latitude, label);

                            console.log(`Marker placed at: ${latitude.toFixed(6)}¬∞, ${longitude.toFixed(6)}¬∞ (${label})`);
                        }
                    } else {
                        console.log('Click position not on globe surface');
                    }
                }
            } catch (error) {
                console.warn('Marker placement error:', error);
            }
        }

        /**
         * Initialize marker placement system with accurate coordinate detection
         * Uses Cesium's built-in screen space event handler for precise positioning
         */
        function initializeMarkerPlacement() {
            // Remove any existing click handlers
            viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
            
            // Set up precise click handling using Cesium's screen space event system
            viewer.cesiumWidget.screenSpaceEventHandler.setInputAction(function(event) {
                // Get the exact click position from the event
                const position = event.position;
                
                // Use Cesium's ellipsoid picking for most accurate surface coordinates
                const ellipsoid = viewer.scene.globe.ellipsoid;
                const cartesian = viewer.camera.pickEllipsoid(position, ellipsoid);
                
                if (cartesian) {
                    // Convert Cartesian to geographic coordinates
                    const cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                    // Create marker at the exact clicked position
                    const label = `Point ${markerCounter + 1}`;
                    createMarker(longitude, latitude, label);

                    console.log(`Marker placed at: ${latitude.toFixed(6)}¬∞, ${longitude.toFixed(6)}¬∞ (${label})`);
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            console.log('Precise marker placement system initialized');
        }

        // Initialize marker placement system
        initializeMarkerPlacement();

        console.log('CesiumJS Globe Viewer initialized successfully');
    </script>
</body>
</html>
