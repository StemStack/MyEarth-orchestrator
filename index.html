<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CesiumJS Globe Viewer</title>
    
    <!-- CesiumJS CSS -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background-color: #000;
        }

        /* Cesium container takes full viewport */
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }

        /* Hide Cesium's default credit container for cleaner look */
        .cesium-widget-credits {
            position: absolute !important;
            bottom: 0 !important;
            left: 0 !important;
            background: rgba(0, 0, 0, 0.7) !important;
            padding: 2px 5px !important;
            font-size: 10px !important;
            color: #fff !important;
            border-radius: 0 3px 0 0 !important;
        }

        /* Ensure toolbar is positioned correctly */
        .cesium-viewer-toolbar {
            position: absolute !important;
            top: 10px !important;
            right: 10px !important;
        }

        /* Style the navigation help button */
        .cesium-navigation-help-button {
            background-color: rgba(42, 42, 42, 0.8) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
        }

        /* Loading indicator styling */
        .cesium-viewer-loadingIndicator {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }

        /* Custom zoom controls */
        .zoom-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background-color: rgba(42, 42, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .zoom-button:hover {
            background-color: rgba(68, 68, 68, 0.9);
        }

        .zoom-button:active {
            background-color: rgba(85, 85, 85, 1);
        }



        /* Universal search bar */
        .search-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 350px;
        }

        .search-input-wrapper {
            display: flex;
            align-items: center;
            background-color: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .search-container input {
            width: 300px;
            height: 35px;
            background-color: transparent;
            border: none;
            color: #fff;
            font-size: 14px;
            padding: 0 10px;
            outline: none;
        }

        .search-container input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .suggestions-dropdown {
            background-color: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-height: 300px;
            overflow-y: auto;
        }

        .suggestion-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item.selected {
            background-color: rgba(68, 68, 68, 0.8);
        }

        .suggestion-name {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .suggestion-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }

        /* Bottom left panel with scale bar and coordinates */
        .bottom-left-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Scale bar styling */
        .scale-bar-container {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            padding: 8px 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .scale-bar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scale-line {
            height: 2px;
            background-color: #000;
            position: relative;
            min-width: 60px;
        }

        .scale-line::before,
        .scale-line::after {
            content: '';
            position: absolute;
            width: 1px;
            height: 8px;
            background-color: #000;
            top: -3px;
        }

        .scale-line::before {
            left: 0;
        }

        .scale-line::after {
            right: 0;
        }

        .scale-text {
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #000;
            font-weight: 500;
            white-space: nowrap;
        }

        /* Coordinates info styling */
        .coordinates-info {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            padding: 6px 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .coordinates-text {
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #000;
            font-weight: 400;
        }

        /* North arrow compass styling */
        .north-arrow-container {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .north-arrow {
            position: relative;
            width: 36px;
            height: 36px;
            transition: transform 0.2s ease;
        }

        .arrow-needle {
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 24px solid #d32f2f;
            z-index: 2;
        }

        .arrow-needle::after {
            content: '';
            position: absolute;
            top: 24px;
            left: -6px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 9px solid #666;
        }

        .arrow-label {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            font-family: Arial, sans-serif;
            font-size: 12px;
            font-weight: bold;
            color: #000;
            z-index: 3;
        }

        .search-button {
            width: 35px;
            height: 35px;
            background-color: rgba(68, 68, 68, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            margin-left: 5px;
        }

        .search-button:hover {
            background-color: rgba(85, 85, 85, 0.9);
        }

        .search-button:active {
            background-color: rgba(100, 100, 100, 1);
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .cesium-viewer-toolbar {
                top: 5px !important;
                right: 5px !important;
            }
            
            .cesium-widget-credits {
                font-size: 8px !important;
                padding: 1px 3px !important;
            }

            .zoom-controls {
                top: 60px;
                left: 5px;
            }

            .zoom-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            .search-container {
                top: 5px;
                left: 5px;
                transform: none;
                width: calc(100vw - 20px);
                max-width: 300px;
            }

            .search-container input {
                width: calc(100% - 50px);
                font-size: 12px;
            }

            .suggestion-item {
                padding: 10px 12px;
            }

            .suggestion-name {
                font-size: 13px;
            }

            .suggestion-details {
                font-size: 11px;
            }

            .bottom-left-panel {
                bottom: 5px;
                left: 5px;
                gap: 6px;
            }

            .scale-bar-container,
            .coordinates-info {
                padding: 6px 8px;
            }

            .scale-text,
            .coordinates-text {
                font-size: 10px;
            }

            .scale-line {
                min-width: 50px;
            }

            .north-arrow-container {
                width: 48px;
                height: 48px;
                padding: 8px;
            }

            .north-arrow {
                width: 32px;
                height: 32px;
            }

            .arrow-needle {
                border-left-width: 5px;
                border-right-width: 5px;
                border-bottom-width: 20px;
                top: 2px;
            }

            .arrow-needle::after {
                left: -5px;
                border-left-width: 5px;
                border-right-width: 5px;
                border-top-width: 8px;
                top: 20px;
            }

            .arrow-label {
                font-size: 11px;
            }
        }
    </style>
</head>

<body>
    <!-- Main Cesium container -->
    <div id="cesiumContainer"></div>
    
    <!-- Custom zoom controls -->
    <div class="zoom-controls">
        <button class="zoom-button" id="zoomIn" title="Zoom In">+</button>
        <button class="zoom-button" id="zoomOut" title="Zoom Out">‚àí</button>
    </div>

    <!-- Universal search bar -->
    <div class="search-container">
        <div class="search-input-wrapper">
            <input type="text" id="searchInput" placeholder="Search address, place, or coordinates..." autocomplete="off">
            <button class="search-button" id="searchButton">üîç</button>
            <div class="loading-spinner" id="loadingSpinner" style="display: none;"></div>
        </div>
        <div class="suggestions-dropdown" id="suggestionsDropdown" style="display: none;"></div>
    </div>

    <!-- Scale bar and coordinates display -->
    <div class="bottom-left-panel" id="bottomLeftPanel">
        <!-- North arrow compass -->
        <div class="north-arrow-container" id="northArrowContainer">
            <div class="north-arrow" id="northArrow">
                <div class="arrow-needle"></div>
                <div class="arrow-label">N</div>
            </div>
        </div>
        
        <!-- Scale bar -->
        <div class="scale-bar-container" id="scaleBarContainer">
            <div class="scale-bar" id="scaleBar">
                <div class="scale-line" id="scaleLine"></div>
                <div class="scale-text" id="scaleText">1 km</div>
            </div>
        </div>
        
        <!-- Coordinates display -->
        <div class="coordinates-info" id="coordinatesInfo">
            <span class="coordinates-text" id="coordinatesText">Coordinates (¬∞) ---.------, ---.------</span>
        </div>
    </div>

    <!-- CesiumJS JavaScript -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    
    <script>
        // Initialize the Cesium viewer with minimal configuration
        const viewer = new Cesium.Viewer('cesiumContainer', {
            // Disable unnecessary UI widgets for clean appearance
            animation: false,           // Remove animation controls
            baseLayerPicker: false,     // Remove base layer picker
            fullscreenButton: true,     // Keep fullscreen button
            geocoder: false,            // Remove geocoder search
            homeButton: true,           // Keep home button for navigation reset
            infoBox: false,             // Remove info box
            sceneModePicker: false,     // Remove 2D/3D mode picker
            selectionIndicator: false,  // Remove selection indicator
            timeline: false,            // Remove timeline
            navigationHelpButton: true, // Keep navigation help
            
            // Use ellipsoid terrain (no authentication required)
            terrainProvider: new Cesium.EllipsoidTerrainProvider()
        });

        // Remove default imagery and add OpenStreetMap
        viewer.imageryLayers.removeAll();
        viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({
            url: 'https://tile.openstreetmap.org/'
        }));

        // Set initial camera position for a nice Earth view
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883, 15000000.0),
            orientation: {
                heading: 0.0,
                pitch: -Cesium.Math.PI_OVER_TWO,
                roll: 0.0
            }
        });

        // Handle window resize events for responsiveness
        window.addEventListener('resize', function() {
            viewer.resize();
        }, false);

        // Disable right-click context menu over the viewer
        viewer.cesiumWidget.canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        }, false);

        // Hide credit container for cleaner look
        viewer.cesiumWidget.creditContainer.style.display = "none";

        // Add zoom button functionality
        const zoomInButton = document.getElementById('zoomIn');
        const zoomOutButton = document.getElementById('zoomOut');
        
        // Add search elements
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const suggestionsDropdown = document.getElementById('suggestionsDropdown');
        
        // Add scale bar and coordinate display elements
        const bottomLeftPanel = document.getElementById('bottomLeftPanel');
        const scaleBar = document.getElementById('scaleBar');
        const scaleLine = document.getElementById('scaleLine');
        const scaleText = document.getElementById('scaleText');
        const coordinatesText = document.getElementById('coordinatesText');
        const northArrow = document.getElementById('northArrow');
        
        // Autocomplete state
        let searchTimeout;
        let currentSuggestions = [];
        let selectedSuggestionIndex = -1;

        zoomInButton.addEventListener('click', function() {
            const camera = viewer.camera;
            const currentHeight = camera.positionCartographic.height;
            const newHeight = Math.max(currentHeight * 0.5, 1000); // Zoom in by 50%, minimum 1km
            
            camera.setView({
                destination: Cesium.Cartesian3.fromRadians(
                    camera.positionCartographic.longitude,
                    camera.positionCartographic.latitude,
                    newHeight
                ),
                orientation: {
                    heading: camera.heading,
                    pitch: camera.pitch,
                    roll: camera.roll
                }
            });
        });

        zoomOutButton.addEventListener('click', function() {
            const camera = viewer.camera;
            const currentHeight = camera.positionCartographic.height;
            const newHeight = Math.min(currentHeight * 2.0, 50000000); // Zoom out by 100%, maximum 50,000km
            
            camera.setView({
                destination: Cesium.Cartesian3.fromRadians(
                    camera.positionCartographic.longitude,
                    camera.positionCartographic.latitude,
                    newHeight
                ),
                orientation: {
                    heading: camera.heading,
                    pitch: camera.pitch,
                    roll: camera.roll
                }
            });
        });

        // Function to check if input is coordinates
        function isCoordinates(input) {
            const coordPattern = /^-?\d+\.?\d*,\s*-?\d+\.?\d*$|^-?\d+\.?\d*\s+-?\d+\.?\d*$/;
            return coordPattern.test(input.trim());
        }

        // Function to parse coordinates from input
        function parseCoordinates(input) {
            const cleaned = input.trim().replace(/,/, ' ');
            const parts = cleaned.split(/\s+/);
            if (parts.length === 2) {
                const lat = parseFloat(parts[0]);
                const lon = parseFloat(parts[1]);
                if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    return { lat, lon };
                }
            }
            return null;
        }

        // Function to get autocomplete suggestions
        async function getAutocompleteSuggestions(query) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&addressdetails=1&limit=5`);
                const data = await response.json();
                return data.map(item => ({
                    lat: parseFloat(item.lat),
                    lon: parseFloat(item.lon),
                    name: item.name || item.display_name.split(',')[0],
                    displayName: item.display_name,
                    type: item.type,
                    address: item.address
                }));
            } catch (error) {
                console.error('Autocomplete error:', error);
                return [];
            }
        }

        // Function to geocode using Nominatim API
        async function geocodeLocation(query) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon),
                        displayName: data[0].display_name
                    };
                }
                return null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        // Function to fly to coordinates with vertical nadir view
        function flyToLocation(lat, lon, altitude = 2000) {
            // Use setView for immediate positioning, then flyTo for smooth animation
            const destination = Cesium.Cartesian3.fromDegrees(lon, lat, altitude);
            
            viewer.camera.flyTo({
                destination: destination,
                orientation: {
                    heading: 0.0, // North direction
                    pitch: -Cesium.Math.PI_OVER_TWO, // -90 degrees (straight down)
                    roll: 0.0 // No rotation
                },
                duration: 2.0,
                complete: function() {
                    // Ensure the camera is truly vertical after animation
                    viewer.camera.setView({
                        destination: destination,
                        orientation: {
                            heading: 0.0,
                            pitch: -Cesium.Math.PI_OVER_TWO, // -90 degrees
                            roll: 0.0
                        }
                    });
                }
            });
        }

        // Universal search functionality
        async function performSearch() {
            const query = searchInput.value.trim();
            if (!query) return;

            // Show loading spinner
            loadingSpinner.style.display = 'block';
            searchButton.disabled = true;

            try {
                // Check if input is coordinates
                const coords = parseCoordinates(query);
                if (coords) {
                    flyToLocation(coords.lat, coords.lon);
                    searchInput.value = '';
                } else {
                    // Geocode the location
                    const result = await geocodeLocation(query);
                    if (result) {
                        flyToLocation(result.lat, result.lon);
                        searchInput.value = '';
                    } else {
                        alert('Location not found. Please try a different search term.');
                    }
                }
            } catch (error) {
                alert('Search failed. Please check your internet connection and try again.');
            } finally {
                // Hide loading spinner
                loadingSpinner.style.display = 'none';
                searchButton.disabled = false;
            }
        }

        // Function to display suggestions
        function displaySuggestions(suggestions) {
            currentSuggestions = suggestions;
            selectedSuggestionIndex = -1;
            
            if (suggestions.length === 0) {
                hideSuggestions();
                return;
            }
            
            const html = suggestions.map((suggestion, index) => {
                const name = suggestion.name || 'Unknown';
                const details = formatSuggestionDetails(suggestion);
                return `
                    <div class="suggestion-item" data-index="${index}">
                        <div class="suggestion-name">${escapeHtml(name)}</div>
                        <div class="suggestion-details">${escapeHtml(details)}</div>
                    </div>
                `;
            }).join('');
            
            suggestionsDropdown.innerHTML = html;
            suggestionsDropdown.style.display = 'block';
            
            // Add click event listeners to suggestions
            suggestionsDropdown.querySelectorAll('.suggestion-item').forEach((item, index) => {
                item.addEventListener('click', () => selectSuggestion(index));
            });
        }

        // Function to format suggestion details
        function formatSuggestionDetails(suggestion) {
            const parts = [];
            if (suggestion.address) {
                if (suggestion.address.city) parts.push(suggestion.address.city);
                if (suggestion.address.state) parts.push(suggestion.address.state);
                if (suggestion.address.country) parts.push(suggestion.address.country);
            }
            return parts.length > 0 ? parts.join(', ') : suggestion.displayName;
        }

        // Function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Function to hide suggestions
        function hideSuggestions() {
            suggestionsDropdown.style.display = 'none';
            currentSuggestions = [];
            selectedSuggestionIndex = -1;
        }

        // Function to select a suggestion
        function selectSuggestion(index) {
            if (index >= 0 && index < currentSuggestions.length) {
                const suggestion = currentSuggestions[index];
                flyToLocation(suggestion.lat, suggestion.lon);
                searchInput.value = '';
                hideSuggestions();
            }
        }

        // Function to highlight selected suggestion
        function updateSelectedSuggestion() {
            suggestionsDropdown.querySelectorAll('.suggestion-item').forEach((item, index) => {
                if (index === selectedSuggestionIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Debounced autocomplete function
        function handleInputChange() {
            const query = searchInput.value.trim();
            
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            // Hide suggestions if input is empty
            if (!query) {
                hideSuggestions();
                return;
            }
            
            // Don't autocomplete if input looks like coordinates
            if (isCoordinates(query)) {
                hideSuggestions();
                return;
            }
            
            // Set new timeout for autocomplete
            searchTimeout = setTimeout(async () => {
                try {
                    const suggestions = await getAutocompleteSuggestions(query);
                    displaySuggestions(suggestions);
                } catch (error) {
                    console.error('Autocomplete failed:', error);
                    hideSuggestions();
                }
            }, 300); // 300ms debounce
        }

        // Add search event listeners
        searchButton.addEventListener('click', performSearch);
        
        // Enhanced input event listeners
        searchInput.addEventListener('input', handleInputChange);
        
        searchInput.addEventListener('keydown', function(e) {
            if (suggestionsDropdown.style.display === 'block' && currentSuggestions.length > 0) {
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, currentSuggestions.length - 1);
                        updateSelectedSuggestion();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                        updateSelectedSuggestion();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (selectedSuggestionIndex >= 0) {
                            selectSuggestion(selectedSuggestionIndex);
                        } else {
                            performSearch();
                        }
                        break;
                    case 'Escape':
                        hideSuggestions();
                        break;
                }
            } else if (e.key === 'Enter') {
                performSearch();
            }
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.search-container')) {
                hideSuggestions();
            }
        });

        /**
         * Live Coordinates Tracking System
         * 
         * Implements real-time coordinate display that shows latitude, longitude,
         * and height of terrain under the mouse cursor. Uses Cesium's camera ray
         * casting to determine precise geographic coordinates.
         */

        // Coordinate tracking handler with throttling for performance
        let coordinateUpdateThrottle = null;
        const COORDINATE_UPDATE_INTERVAL = 50; // Update every 50ms for smooth tracking

        /**
         * Calculates and updates the scale bar based on current map view
         * Uses geodesic distance calculation for accurate metric representation
         */
        function updateScaleBar() {
            try {
                const canvas = viewer.canvas;
                const ellipsoid = viewer.scene.globe.ellipsoid;
                
                // Get canvas dimensions
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                // Define two points on screen separated by 100 pixels
                const left = new Cesium.Cartesian2((width / 2) - 50, height / 2);
                const right = new Cesium.Cartesian2((width / 2) + 50, height / 2);
                
                // Pick ellipsoid positions for both points
                const leftPosition = viewer.camera.pickEllipsoid(left, ellipsoid);
                const rightPosition = viewer.camera.pickEllipsoid(right, ellipsoid);
                
                if (leftPosition && rightPosition) {
                    // Convert to cartographic coordinates
                    const leftCartographic = ellipsoid.cartesianToCartographic(leftPosition);
                    const rightCartographic = ellipsoid.cartesianToCartographic(rightPosition);
                    
                    // Calculate geodesic distance between the two points
                    const geodesic = new Cesium.EllipsoidGeodesic(leftCartographic, rightCartographic);
                    const pixelDistance = geodesic.surfaceDistance; // Distance in meters for 100 pixels
                    
                    // Determine appropriate scale values
                    let targetDistance, scaleWidth, scaleLabel;
                    
                    if (pixelDistance >= 100000) {
                        // For very large scales, use 100km intervals
                        targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                        if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                        else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                        scaleLabel = (targetDistance / 1000) + ' km';
                    } else if (pixelDistance >= 1000) {
                        // For medium scales, use km
                        targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                        if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                        else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                        scaleLabel = (targetDistance >= 1000) ? (targetDistance / 1000) + ' km' : targetDistance + ' m';
                    } else {
                        // For small scales, use meters
                        targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                        if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                        else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                        scaleLabel = targetDistance + ' m';
                    }
                    
                    // Calculate the width in pixels for our target distance
                    scaleWidth = (targetDistance / pixelDistance) * 100;
                    
                    // Update the scale bar
                    scaleLine.style.width = Math.max(Math.min(scaleWidth, 200), 30) + 'px';
                    scaleText.textContent = scaleLabel;
                }
            } catch (error) {
                console.warn('Scale bar calculation failed, using default');
                scaleLine.style.width = '60px';
                scaleText.textContent = '1 km';
            }
        }

        /**
         * Updates coordinate display with formatted values in WGS84 degrees
         * @param {number} latitude - Latitude in degrees
         * @param {number} longitude - Longitude in degrees  
         */
        function updateCoordinateDisplay(latitude, longitude) {
            try {
                if (!coordinatesText) {
                    console.warn('Coordinates text element not found');
                    return;
                }
                
                const latText = latitude.toFixed(6);
                const lonText = longitude.toFixed(6);
                coordinatesText.textContent = `Coordinates (¬∞) ${latText}, ${lonText}`;
                
            } catch (error) {
                console.warn('Error updating coordinate display:', error);
            }
        }

        /**
         * Clears coordinate display when mouse is not over terrain
         */
        function clearCoordinateDisplay() {
            try {
                if (!coordinatesText) {
                    console.warn('Coordinates text element not found');
                    return;
                }
                coordinatesText.textContent = 'Coordinates (¬∞) ---.------, ---.------';
            } catch (error) {
                console.warn('Error clearing coordinate display:', error);
            }
        }

        /**
         * Updates the north arrow rotation to always point to geographic north
         * Arrow compensates for camera rotation to maintain north orientation
         */
        function updateNorthArrow() {
            try {
                // Ensure northArrow element exists
                if (!northArrow) {
                    console.warn('North arrow element not found');
                    return;
                }
                
                // Get the camera's current heading (rotation around the up axis)
                const heading = viewer.camera.heading;
                
                // Convert heading from radians to degrees and normalize to 0-360
                let headingDegrees = Cesium.Math.toDegrees(heading);
                headingDegrees = ((headingDegrees % 360) + 360) % 360;
                
                // Rotate the north arrow to compensate for camera rotation
                // Negative rotation because we want the arrow to point north regardless of camera heading
                const rotation = -headingDegrees;
                
                // Apply rotation transform to the north arrow
                northArrow.style.transform = `rotate(${rotation}deg)`;
                

                
            } catch (error) {
                console.warn('North arrow update failed:', error);
                // Reset to default orientation on error
                if (northArrow) {
                    northArrow.style.transform = 'rotate(0deg)';
                }
            }
        }

        /**
         * Handles mouse movement over the Cesium viewer canvas
         * Uses camera ray casting to determine world coordinates
         * @param {MouseEvent} event - Mouse move event
         */
        function handleMouseMove(event) {
            // Throttle updates for performance optimization
            if (coordinateUpdateThrottle) {
                return;
            }

            coordinateUpdateThrottle = setTimeout(() => {
                coordinateUpdateThrottle = null;

                try {
                    // Get mouse position relative to canvas
                    const canvas = viewer.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    console.log(`Mouse position: ${x}, ${y}`); // Debug log
                    
                    // Convert screen coordinates to Cesium coordinates
                    const pick = new Cesium.Cartesian2(x, y);
                    
                    // Try different methods to get terrain intersection
                    let intersection = null;
                    
                    // Method 1: Use scene.pickPosition for better terrain detection
                    intersection = viewer.scene.pickPosition(pick);
                    console.log('Method 1 result:', !!intersection); // Debug log
                    
                    // Method 2: Fallback to globe.pick if pickPosition fails
                    if (!intersection) {
                        const ray = viewer.camera.getPickRay(pick);
                        intersection = viewer.scene.globe.pick(ray, viewer.scene);
                        console.log('Method 2 result:', !!intersection); // Debug log
                    }
                    
                    // Method 3: Fallback to camera ray with ellipsoid intersection
                    if (!intersection) {
                        const ray = viewer.camera.getPickRay(pick);
                        intersection = Cesium.IntersectionTests.rayEllipsoid(ray, viewer.scene.globe.ellipsoid);
                        if (intersection) {
                            intersection = Cesium.Ray.getPoint(ray, intersection.start);
                        }
                        console.log('Method 3 result:', !!intersection); // Debug log
                    }
                    
                    if (intersection) {
                        // Convert Cartesian coordinates to geographic coordinates
                        const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                        
                        console.log(`Coordinates found: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}`); // Debug log
                        updateCoordinateDisplay(latitude, longitude);
                    } else {
                        // Mouse is not over terrain (e.g., over space)
                        console.log('No intersection found'); // Debug log
                        clearCoordinateDisplay();
                    }
                } catch (error) {
                    // Handle any coordinate calculation errors gracefully
                    console.warn('Coordinate tracking error:', error);
                    clearCoordinateDisplay();
                }
            }, COORDINATE_UPDATE_INTERVAL);
        }

        /**
         * Initialize coordinate tracking, scale bar, and north arrow systems
         * Attaches mouse move listener and camera change handlers
         */
        function initializeCoordinateTracking() {
            const canvas = viewer.canvas;
            
            // Test coordinate display immediately
            coordinatesText.textContent = 'Coordinates (¬∞) Testing...';
            console.log('Testing coordinate display update');
            
            // Add mouse move listener for coordinate tracking
            const mouseHandler = function(event) {
                console.log('Mouse move detected on canvas'); // Debug log
                handleMouseMove(event);
            };
            
            canvas.addEventListener('mousemove', mouseHandler);
            
            // Also add to the main viewer element for better coverage
            viewer.container.addEventListener('mousemove', function(event) {
                console.log('Mouse move detected on container'); // Debug log
                handleMouseMove(event);
            });
            
            // Clear coordinates when mouse leaves canvas
            canvas.addEventListener('mouseleave', function() {
                console.log('Mouse left canvas'); // Debug log
                clearCoordinateDisplay();
            });
            viewer.container.addEventListener('mouseleave', function() {
                console.log('Mouse left container'); // Debug log
                clearCoordinateDisplay();
            });
            
            // Add camera change listeners for scale bar and north arrow updates
            viewer.camera.changed.addEventListener(function() {
                updateScaleBar();
                updateNorthArrow();
            });
            viewer.scene.morphComplete.addEventListener(function() {
                updateScaleBar();
                updateNorthArrow();
            });
            
            // Initial updates
            updateScaleBar();
            updateNorthArrow();
            
            // Set initial coordinate state after short delay
            setTimeout(() => {
                clearCoordinateDisplay();
                console.log('Initial coordinate display cleared');
            }, 500);
            
            console.log('Live coordinate tracking, scale bar, and north arrow initialized');
            console.log('Mouse event listeners attached to canvas and container');
        }

        // Initialize coordinate tracking after viewer is ready
        setTimeout(() => {
            // Verify all elements exist before initializing
            console.log('Checking elements:');
            console.log('- northArrow:', !!northArrow);
            console.log('- coordinatesText:', !!coordinatesText);
            console.log('- scaleLine:', !!scaleLine);
            console.log('- scaleText:', !!scaleText);
            
            initializeCoordinateTracking();
        }, 100);

        /**
         * Interactive Marker Placement System
         * 
         * Enables users to click on the globe to place red markers at specific locations.
         * Each marker displays a label and can be managed through the marker collection.
         */

        // Marker management system
        let markerCounter = 0;
        const markers = new Map(); // Store markers with unique IDs for potential future management

        /**
         * Creates a red marker billboard at specified coordinates
         * @param {number} longitude - Longitude in degrees
         * @param {number} latitude - Latitude in degrees
         * @param {string} label - Display label for the marker
         * @returns {Object} Created marker entity
         */
        function createMarker(longitude, latitude, label) {
            const markerId = `marker_${++markerCounter}`;
            
            const marker = viewer.entities.add({
                id: markerId,
                position: Cesium.Cartesian3.fromDegrees(longitude, latitude),
                billboard: {
                    image: createMarkerPin(), // Custom red pin graphic
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    scale: 1.0,
                    pixelOffset: new Cesium.Cartesian2(0, 0), // Remove offset for exact positioning
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                },
                label: {
                    text: label,
                    font: '12pt sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -36), // Adjust label position relative to marker
                    disableDepthTestDistance: Number.POSITIVE_INFINITY
                }
            });

            // Store marker reference for potential future management
            markers.set(markerId, {
                entity: marker,
                coordinates: { longitude, latitude },
                label: label,
                timestamp: new Date()
            });

            return marker;
        }

        /**
         * Creates a red marker pin graphic with precise bottom point positioning
         * @returns {HTMLCanvasElement} Canvas element containing the marker graphic
         */
        function createMarkerPin() {
            const canvas = document.createElement('canvas');
            canvas.width = 24;
            canvas.height = 36;
            const ctx = canvas.getContext('2d');

            // Draw red marker pin shape with precise positioning
            ctx.fillStyle = '#FF0000';
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 2;

            // Main pin body (circle) - positioned higher to accommodate point
            ctx.beginPath();
            ctx.arc(12, 10, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Pin point (triangle) - precise tip at bottom center
            ctx.beginPath();
            ctx.moveTo(12, 36); // Bottom point (exact click position)
            ctx.lineTo(6, 18);  // Left side of point
            ctx.lineTo(18, 18); // Right side of point
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Inner white dot
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(12, 10, 3, 0, 2 * Math.PI);
            ctx.fill();

            return canvas;
        }

        /**
         * Handles click events on the globe for marker placement
         * Uses precise ellipsoid intersection for exact positioning
         * @param {ClickEvent} event - Cesium click event
         */
        function handleGlobeClick(event) {
            try {
                // Use direct ellipsoid picking for most accurate positioning
                const ellipsoid = viewer.scene.globe.ellipsoid;
                const cartesian = viewer.camera.pickEllipsoid(event.position, ellipsoid);
                
                if (cartesian) {
                    // Convert Cartesian coordinates to geographic coordinates
                    const cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                    // Create marker with sequential numbering
                    const label = `Point ${markerCounter + 1}`;
                    const marker = createMarker(longitude, latitude, label);

                    console.log(`Marker placed at: ${latitude.toFixed(6)}¬∞, ${longitude.toFixed(6)}¬∞ (${label})`);
                } else {
                    // Secondary method: Try scene picking for terrain intersection
                    const pickedObject = viewer.scene.pick(event.position);
                    if (pickedObject && pickedObject.primitive) {
                        const ray = viewer.camera.getPickRay(event.position);
                        const intersection = viewer.scene.globe.pick(ray, viewer.scene);
                        
                        if (intersection) {
                            const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                            const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                            const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                            const label = `Point ${markerCounter + 1}`;
                            const marker = createMarker(longitude, latitude, label);

                            console.log(`Marker placed at: ${latitude.toFixed(6)}¬∞, ${longitude.toFixed(6)}¬∞ (${label})`);
                        }
                    } else {
                        console.log('Click position not on globe surface');
                    }
                }
            } catch (error) {
                console.warn('Marker placement error:', error);
            }
        }

        /**
         * Initialize marker placement system with accurate coordinate detection
         * Uses Cesium's built-in screen space event handler for precise positioning
         */
        function initializeMarkerPlacement() {
            // Remove any existing click handlers
            viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
            
            // Set up precise click handling using Cesium's screen space event system
            viewer.cesiumWidget.screenSpaceEventHandler.setInputAction(function(event) {
                // Get the exact click position from the event
                const position = event.position;
                
                // Use Cesium's ellipsoid picking for most accurate surface coordinates
                const ellipsoid = viewer.scene.globe.ellipsoid;
                const cartesian = viewer.camera.pickEllipsoid(position, ellipsoid);
                
                if (cartesian) {
                    // Convert Cartesian to geographic coordinates
                    const cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                    // Create marker at the exact clicked position
                    const label = `Point ${markerCounter + 1}`;
                    createMarker(longitude, latitude, label);

                    console.log(`Marker placed at: ${latitude.toFixed(6)}¬∞, ${longitude.toFixed(6)}¬∞ (${label})`);
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            console.log('Precise marker placement system initialized');
        }

        // Initialize marker placement system
        initializeMarkerPlacement();

        console.log('CesiumJS Globe Viewer initialized successfully');
    </script>
</body>
</html>
