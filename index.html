<!DOCTYPE html>
<!-- ======================================== -->
<!-- MYEARTH.APP - 3D GLOBE VIEWER -->
<!-- ======================================== -->
<!-- 
    PANEL SYSTEM DOCUMENTATION
    =========================
    
    This application uses a dual-panel system for user interface:
    
    1. LEFT PANEL (SIDEBAR)
       ====================
       - ID: leftPanel
       - Class: sidebar
       - Toggle Function: toggleLeftPanel()
       - Toggle Button: leftPanelToggle (hamburger menu)
       - Position: Left side of screen
       - Purpose: Map layers, data services, 3D models, gizmo controls
       - Sections: Maps displayed, Data Services, 3D Models, Gizmo
       - Default State: Collapsed
       - CSS Classes: 'collapsed', 'with-left-panel'
       
    2. RIGHT PANEL (TOOL TOOLBAR)
       ==========================
       - ID: rightPanel
       - Toggle Function: toggleRightPanel()
       - Toggle Button: panel-toggle-btn (hamburger menu)
       - Position: Right side of screen
       - Purpose: Quick access to map tools, navigation, layers, utilities
       - Layout: 2-column grid with 20 tool buttons + print tool
       - Style: White rounded panel with Swiss geoportal design
       - Default State: Visible
       - CSS Classes: 'collapsed'
       
    KEY ELEMENTS:
    =============
    - leftPanelToggle: Left panel toggle button (top-left corner)
    - leftPanel: Main left sidebar container
    - rightPanel: Main right toolbar container
    - panel-toggle-btn: Right panel toggle button (hamburger menu)
    - tool-grid: 2-column grid containing 20 tool buttons
    - print-tool: Separate print button at bottom of right panel
    
    DEVELOPMENT NOTES:
    =================
    - All panel functions are globally available via window object
    - Panel states are managed via CSS classes
    - Console logging is implemented for debugging
    - Responsive design supports mobile and desktop
    - Swiss geoportal design pattern used for right panel
    - Left panel uses traditional sidebar design
-->
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyEarth.app - 3D Globe Viewer</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/static/favicon.svg">
    <link rel="shortcut icon" href="/static/favicon.svg">
    <meta name="theme-color" content="#000000">
    
    <!-- CesiumJS CSS -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <!-- Print Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Google OAuth2 -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/static/css/auth.css">
    
    <!-- Gizmo System CSS -->
    <style>
        .gizmo-controls {
            background: transparent;
            color: var(--text-color);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            margin-top: 10px;
            border: 1px solid var(--sidebar-border);
        }
        
        .gizmo-controls h4 {
            margin: 0 0 8px 0;
            color: var(--text-color);
            font-size: 14px;
            font-weight: 600;
        }
        
        .gizmo-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .gizmo-btn {
            background: rgba(52, 152, 219, 0.3);
            color: #3498db;
            border: 1px solid #3498db;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
            margin: 2px;
        }
        
        .gizmo-btn:hover {
            background: rgba(52, 152, 219, 0.5);
            border-color: #2980b9;
        }
        
        .gizmo-btn.active {
            background: rgba(52, 152, 219, 0.7);
            border-color: #2980b9;
            color: white;
        }
        
        .gizmo-btn.secondary {
            background: rgba(230, 126, 34, 0.3);
            color: #e67e22;
            border-color: #e67e22;
        }
        
        .gizmo-btn.secondary:hover {
            background: rgba(230, 126, 34, 0.5);
            border-color: #d35400;
        }
        
        .gizmo-status {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 5px;
            font-style: italic;
        }
    </style>
    
    <style>
        /* CSS Variables for Theme System */
        :root {
            --bg-color: #000;
            --sidebar-bg: transparent;
            --sidebar-border: #dee2e6;
            --text-color: #333;
            --text-muted: #666;
            --button-bg: #007bff;
            --button-hover: #0056b3;
            --button-secondary: #6c757d;
            --input-bg: transparent;
            --input-border: #ced4da;
            --panel-bg: transparent;
            --shadow: rgba(0, 0, 0, 0.1);
            --legend-bg: transparent;
            --legend-border: #dee2e6;
            --switch-bg: #ccc;
            --switch-toggle: #fff;
        }
        
        [data-theme="dark"] {
            --bg-color: #000;
            --sidebar-bg: transparent;
            --sidebar-border: #404040;
            --text-color: #e0e0e0;
            --text-muted: #b0b0b0;
            --button-bg: #0d6efd;
            --button-hover: #0b5ed7;
            --button-secondary: #495057;
            --input-bg: transparent;
            --input-border: #404040;
            --panel-bg: transparent;
            --shadow: rgba(0, 0, 0, 0.3);
            --legend-bg: transparent;
            --legend-border: #404040;
            --switch-bg: #404040;
            --switch-toggle: #0d6efd;
        }

        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Cesium container takes full viewport with adjusted margins */
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            margin-right: 60px;
            margin-bottom: 40px;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            transition: margin 0.3s ease;
            visibility: visible !important;
            display: block !important;
        }

        #cesiumContainer.with-left-panel {
            margin-left: 280px;
        }

        /* Move Cesium's credits to bottom center */
        .cesium-widget-credits {
            position: absolute !important;
            bottom: 5px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            background: rgba(255, 255, 255, 0.3) !important;
            padding: 4px 12px !important;
            font-size: 11px !important;
            color: #fff !important;
            border-radius: 15px !important;
            white-space: nowrap !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
        }

        /* Modern Right-Side Tool Menu */
        .cesium-viewer-toolbar {
            position: fixed !important;
            top: 50% !important;
            right: 20px !important;
            transform: translateY(-50%) !important;
            background: rgba(255, 255, 255, 0.5) !important;
            backdrop-filter: blur(10px) !important;
            border-radius: 12px !important;
            padding: 8px !important;
            flex-direction: column !important;
            display: flex !important;
            gap: 6px !important;
            z-index: 1000 !important;
        }
        
        /* Unified Modern Button Styling */
        .cesium-viewer-toolbar .cesium-button,
        .cesium-viewer-toolbar .cesium-navigation-help-button,
        .cesium-viewer-toolbar .cesium-home-button,
        .cesium-viewer-toolbar .cesium-scene-mode-picker,
        .cesium-viewer-toolbar .cesium-base-layer-picker,
        .cesium-viewer-toolbar .cesium-geocoder-container,
        .cesium-viewer-toolbar button {
            width: 30px !important;
            height: 30px !important;
            border-radius: 50% !important;
            background: rgba(255, 255, 255, 0.5) !important;
            color: #333 !important;
            border: none !important;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1) !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            margin: 0 !important;
            font-size: 14px !important;
            cursor: pointer !important;
            position: relative !important;
        }
        
        .cesium-viewer-toolbar .cesium-button:hover,
        .cesium-viewer-toolbar .cesium-navigation-help-button:hover,
        .cesium-viewer-toolbar .cesium-home-button:hover,
        .cesium-viewer-toolbar .cesium-scene-mode-picker:hover,
        .cesium-viewer-toolbar .cesium-base-layer-picker:hover,
        .cesium-viewer-toolbar .cesium-geocoder-container:hover,
        .cesium-viewer-toolbar button:hover {
            background: rgba(255, 255, 255, 0.8) !important;
            transform: translateY(-1px) scale(1.1) !important;
        }
        
        /* Ensure all button icons are dark */
        .cesium-viewer-toolbar .cesium-button *,
        .cesium-viewer-toolbar .cesium-navigation-help-button *,
        .cesium-viewer-toolbar .cesium-home-button *,
        .cesium-viewer-toolbar .cesium-scene-mode-picker *,
        .cesium-viewer-toolbar .cesium-base-layer-picker *,
        .cesium-viewer-toolbar .cesium-geocoder-container *,
        .cesium-viewer-toolbar button * {
            color: #333 !important;
            fill: #333 !important;
            stroke: #333 !important;
        }
        
        /* Active state for any button */
        .cesium-viewer-toolbar .cesium-button.active,
        .cesium-viewer-toolbar .cesium-navigation-help-button.active,
        .cesium-viewer-toolbar .cesium-home-button.active,
        .cesium-viewer-toolbar .cesium-scene-mode-picker.active,
        .cesium-viewer-toolbar .cesium-base-layer-picker.active,
        .cesium-viewer-toolbar .cesium-geocoder-container.active,
        .cesium-viewer-toolbar button.active,
        .cesium-viewer-toolbar .cesium-button.print-active {
            background: rgba(59, 130, 246, 0.8) !important;
            color: white !important;
        }
        
        .cesium-viewer-toolbar .cesium-button.active:hover,
        .cesium-viewer-toolbar .cesium-navigation-help-button.active:hover,
        .cesium-viewer-toolbar .cesium-home-button.active:hover,
        .cesium-viewer-toolbar .cesium-scene-mode-picker.active:hover,
        .cesium-viewer-toolbar .cesium-base-layer-picker.active:hover,
        .cesium-viewer-toolbar .cesium-geocoder-container.active:hover,
        .cesium-viewer-toolbar button.active:hover,
        .cesium-viewer-toolbar .cesium-button.print-active:hover {
            background: rgba(59, 130, 246, 1) !important;
            transform: translateY(-1px) scale(1.1) !important;
        }
        
        /* Hide ALL old Cesium buttons and elements */
        .cesium-viewer-navigationContainer,
        .cesium-sceneModePicker-wrapper,
        .cesium-baseLayerPicker-dropDown,
        .cesium-animation-container,
        .cesium-timeline-main,
        .cesium-fullscreenButton,
        .cesium-vrButton,
        .cesium-sceneModePicker-dropDown-icon,
        .cesium-navigationHelp-button,
        .cesium-viewer-cesium3DTilesInspectorContainer,
        .cesium-viewer-animationContainer,
        .cesium-viewer-bottomContainer,
        .cesium-viewer-timelineContainer,
        .cesium-viewer-toolbar .cesium-navigation-help-button,
        .cesium-viewer-toolbar .cesium-home-button,
        .cesium-viewer-toolbar .cesium-scene-mode-picker,
        .cesium-viewer-toolbar .cesium-base-layer-picker,
        .cesium-viewer-toolbar .cesium-geocoder-container,
        .cesium-compass,
        .cesium-compass-wrapper,
        .cesium-compass-outer,
        .cesium-compass-inner,
        .cesium-compass-rose,
        .cesium-compass-roseN,
        .cesium-compass-roseE,
        .cesium-compass-roseS,
        .cesium-compass-roseW,
        /* Additional aggressive hiding for any remaining old buttons */
        .cesium-viewer-toolbar > *:not([data-custom-tool]),
        .cesium-viewer-toolbar > button:not([data-custom-tool]),
        .cesium-viewer-toolbar > div:not([data-custom-tool]),
        /* ULTRA-AGGRESSIVE: Hide ALL Cesium UI elements regardless of location */
        .cesium-navigationHelpButton,
        .cesium-homeButton,
        .cesium-sceneModePicker,
        .cesium-baseLayerPicker,
        .cesium-geocoder,
        .cesium-infoBox,
        .cesium-selectionIndicator,
        .cesium-viewer-navigationContainer,
        div[class*="cesium-navigation"],
        div[class*="cesium-home"],
        div[class*="cesium-compass"],
        div[class*="cesium-scene"],
        div[class*="cesium-base"],
        div[class*="cesium-geocoder"],
        button[class*="cesium-navigation"],
        button[class*="cesium-home"],
        button[class*="cesium-compass"],
        button[class*="cesium-scene"],
        button[class*="cesium-base"],
        button[class*="cesium-geocoder"],
        /* Target the specific hamburger menu that's visible */
        .cesium-viewer .cesium-navigationHelpButton,
        .cesium-viewer .cesium-homeButton,
        .cesium-viewer .cesium-sceneModePicker,
        .cesium-viewer .cesium-baseLayerPicker,
        .cesium-viewer .cesium-geocoder,
        .cesium-viewer .cesium-compass,
        /* Any toolbar elements not marked as custom */
        .cesium-toolbar-button:not([data-custom-tool]),
        .cesium-button:not([data-custom-tool]) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
            position: absolute !important;
            top: -9999px !important;
            left: -9999px !important;
            width: 0 !important;
            height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Tooltip styles for better UX */
        .cesium-viewer-toolbar .cesium-button::before,
        .cesium-viewer-toolbar .cesium-navigation-help-button::before,
        .cesium-viewer-toolbar .cesium-home-button::before,
        .cesium-viewer-toolbar .cesium-scene-mode-picker::before,
        .cesium-viewer-toolbar .cesium-base-layer-picker::before,
        .cesium-viewer-toolbar .cesium-geocoder-container::before,
        .cesium-viewer-toolbar button::before {
            content: attr(title);
            position: absolute;
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1001;
        }
        
        .cesium-viewer-toolbar .cesium-button:hover::before,
        .cesium-viewer-toolbar .cesium-navigation-help-button:hover::before,
        .cesium-viewer-toolbar .cesium-home-button:hover::before,
        .cesium-viewer-toolbar .cesium-scene-mode-picker:hover::before,
        .cesium-viewer-toolbar .cesium-base-layer-picker:hover::before,
        .cesium-viewer-toolbar .cesium-geocoder-container:hover::before,
        .cesium-viewer-toolbar button:hover::before {
            opacity: 1;
        }
        
        /* Responsive design for mobile */
        @media (max-width: 768px) {
            .cesium-viewer-toolbar {
                right: 10px !important;
                padding: 6px !important;
                gap: 4px !important;
            }
            
            .cesium-viewer-toolbar .cesium-button,
            .cesium-viewer-toolbar .cesium-navigation-help-button,
            .cesium-viewer-toolbar .cesium-home-button,
            .cesium-viewer-toolbar .cesium-scene-mode-picker,
            .cesium-viewer-toolbar .cesium-base-layer-picker,
            .cesium-viewer-toolbar .cesium-geocoder-container,
            .cesium-viewer-toolbar button {
                width: 28px !important;
                height: 28px !important;
                font-size: 12px !important;
            }
            
            .cesium-viewer-toolbar .cesium-button::before,
            .cesium-viewer-toolbar .cesium-navigation-help-button::before,
            .cesium-viewer-toolbar .cesium-home-button::before,
            .cesium-viewer-toolbar .cesium-scene-mode-picker::before,
            .cesium-viewer-toolbar .cesium-base-layer-picker::before,
            .cesium-viewer-toolbar .cesium-geocoder-container::before,
            .cesium-viewer-toolbar button::before {
                display: none !important;
            }
        }

        /* Loading indicator styling */
        .cesium-viewer-loadingIndicator {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }





        /* Sidebar integrated search bar */
        .sidebar-search-container {
            margin-bottom: 15px;
        }

        .sidebar-search-wrapper {
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--input-border);
            border-radius: 4px;
            box-shadow: 0 1px 3px var(--shadow);
            transition: background-color 0.3s ease;
        }

        .sidebar-search-container input {
            width: 100%;
            height: 32px;
            background-color: transparent;
            border: none;
            color: var(--text-color);
            font-size: 12px;
            padding: 0 8px;
            outline: none;
            flex: 1;
        }

        .sidebar-search-container input::placeholder {
            color: #999;
            font-size: 11px;
        }

        .sidebar-search-button {
            background-color: rgba(52, 152, 219, 0.3);
            border: 1px solid rgba(52, 152, 219, 0.5);
            color: #3498db;
            padding: 6px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 12px;
            min-width: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 26px;
        }

        .sidebar-search-button:hover {
            background-color: rgba(52, 152, 219, 0.5);
        }

        .sidebar-search-button:active {
            background-color: rgba(52, 152, 219, 0.7);
        }

        .suggestions-dropdown {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            border-top: none;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 2px 8px var(--shadow);
            max-height: 200px;
            overflow-y: auto;
            margin-top: 1px;
            transition: background-color 0.3s ease;
        }

        .suggestion-item {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item.selected {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .suggestion-name {
            color: var(--text-color);
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .suggestion-details {
            color: var(--text-muted);
            font-size: 10px;
        }

        /* Bottom left panel with scale bar and coordinates */
        /* Theme Toggle Button (Top Right) */
        .theme-toggle-button {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 2000;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
        }

        .theme-toggle-button:hover {
            background: rgba(248, 248, 248, 0.95);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .theme-toggle-button span {
            font-size: 20px;
            transition: transform 0.3s ease;
        }

        .theme-toggle-button:hover span {
            transform: rotate(15deg);
        }

        /* Dark theme adjustments for toggle button */
        [data-theme="dark"] .theme-toggle-button {
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        [data-theme="dark"] .theme-toggle-button:hover {
            background: rgba(248, 248, 248, 0.95);
        }

        .bottom-left-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Scale bar styling */
        .scale-bar-container {
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            -webkit-backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            border: 1px solid var(--input-border);
            border-radius: 3px;
            padding: 8px 12px;
            box-shadow: 0 2px 6px var(--shadow);
            transition: background-color 0.3s ease;
        }

        .scale-bar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scale-line {
            height: 2px;
            background-color: #000;
            position: relative;
            min-width: 60px;
        }

        .scale-line::before,
        .scale-line::after {
            content: '';
            position: absolute;
            width: 1px;
            height: 8px;
            background-color: #000;
            top: -3px;
        }

        .scale-line::before {
            left: 0;
        }

        .scale-line::after {
            right: 0;
        }

        .scale-text {
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
            font-weight: 500;
            white-space: nowrap;
        }

        /* Coordinates info styling */
        .coordinates-info {
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            -webkit-backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            border: 1px solid var(--input-border);
            border-radius: 3px;
            padding: 6px 12px;
            box-shadow: 0 2px 6px var(--shadow);
            transition: background-color 0.3s ease;
        }

        .coordinates-text {
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
            font-weight: 400;
        }

        /* North arrow compass styling */
        .north-arrow-container {
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            -webkit-backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            border: 1px solid var(--input-border);
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 2px 6px var(--shadow);
            width: 60px;
            transition: background-color 0.3s ease;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .north-arrow {
            position: relative;
            width: 36px;
            height: 36px;
            transition: transform 0.1s ease-out;
        }

        .arrow-needle {
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 24px solid #d32f2f;
            z-index: 2;
        }

        .arrow-needle::after {
            content: '';
            position: absolute;
            top: 24px;
            left: -6px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 9px solid #666;
        }

        .arrow-label {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            font-family: Arial, sans-serif;
            font-size: 12px;
            font-weight: bold;
            color: #000;
            z-index: 3;
        }



        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .cesium-viewer-toolbar {
                top: 5px !important;
                right: 5px !important;
            }
            
            .cesium-widget-credits {
                font-size: 8px !important;
                padding: 1px 3px !important;
            }

            .zoom-controls {
                top: 60px;
                left: 5px;
            }

            .zoom-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            .search-container {
                top: 5px;
                left: 5px;
                transform: none;
                width: calc(100vw - 20px);
                max-width: 300px;
            }

            .search-container input {
                width: calc(100% - 50px);
                font-size: 12px;
            }

            .suggestion-item {
                padding: 10px 12px;
            }

            .suggestion-name {
                font-size: 13px;
            }

            .suggestion-details {
                font-size: 11px;
            }

            .bottom-left-panel {
                bottom: 5px;
                left: 5px;
                gap: 6px;
            }

            .scale-bar-container,
            .coordinates-info {
                padding: 6px 8px;
            }

            .scale-text,
            .coordinates-text {
                font-size: 10px;
            }

            .scale-line {
                min-width: 50px;
            }

            .north-arrow-container {
                width: 48px;
                height: 48px;
                padding: 8px;
            }

            .north-arrow {
                width: 32px;
                height: 32px;
            }

            .arrow-needle {
                border-left-width: 5px;
                border-right-width: 5px;
                border-bottom-width: 20px;
                top: 2px;
            }

            .arrow-needle::after {
                left: -5px;
                border-left-width: 5px;
                border-right-width: 5px;
                border-top-width: 8px;
                top: 20px;
            }

            .arrow-label {
                font-size: 11px;
            }
        }

        /* Center crosshair styling */
        .center-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            pointer-events: none;
        }

        .crosshair-horizontal {
            position: absolute;
            top: -1px;
            left: -10px;
            width: 20px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.5);
        }

        .crosshair-vertical {
            position: absolute;
            top: -10px;
            left: -1px;
            width: 2px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.5);
        }

        /* Left Panel Styles */
        .sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 280px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            -webkit-backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transition: transform 0.3s ease;
            overflow-y: auto;
            padding-top: 40px;
            padding-bottom: 20px; /* Add padding at the bottom */
            box-sizing: border-box;
        }

        /* New 2-Column Grid Layout for Right Panel */
        #rightPanel {
            position: fixed !important;
            top: 20px !important;
            right: 15px !important;
            width: 80px !important;
            background: rgba(255, 255, 255, 0.5) !important;
            backdrop-filter: blur(10px) !important;
            border-radius: 12px !important;
            z-index: 999;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 8px;
            box-sizing: border-box;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }

        /* Tool Grid - 2 Columns */
        .tool-grid {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 4px !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 40px 0 0 0 !important;
        }

        /* Tool Icons in Grid */
        .tool-grid .tool-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: rgba(255,255,255,0.9) !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #333;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
            margin: 0;
        }

        .tool-grid .tool-icon:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            border-color: rgba(0, 123, 255, 0.3) !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.15) !important;
        }

        .tool-grid .tool-icon.active {
            background: rgba(0, 123, 255, 0.2) !important;
            color: #007bff !important;
            border-color: #007bff !important;
        }



        /* Panel Toggle Button - Aligned with Panel */
        #rightPanel .panel-toggle-btn {
            position: absolute !important;
            top: 12px !important;
            right: 8px !important;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: rgba(255,255,255,0.95) !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #333;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
            z-index: 1002 !important;
        }

        #rightPanel .panel-toggle-btn:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            border-color: rgba(0, 123, 255, 0.3) !important;
            transform: translateY(-1px);
        }

        /* Icon switching for panel toggle button */
        #rightPanel .panel-toggle-btn .hamburger-icon {
            display: none;
        }
        
        #rightPanel .panel-toggle-btn .close-icon {
            display: block;
        }
        
        #rightPanel.collapsed .panel-toggle-btn .hamburger-icon {
            display: block;
        }
        
        #rightPanel.collapsed .panel-toggle-btn .close-icon {
            display: none;
        }

        /* Dark Theme Support */
        .dark-theme {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
        }

        .dark-theme #rightPanel {
            background: rgba(30, 30, 30, 0.95) !important;
            border-color: rgba(255, 255, 255, 0.1) !important;
        }

        .dark-theme .tool-grid .tool-icon {
            background: rgba(50, 50, 50, 0.9) !important;
            border-color: rgba(255, 255, 255, 0.1) !important;
            color: #ffffff;
        }

        .dark-theme .tool-grid .tool-icon:hover {
            background: rgba(0, 123, 255, 0.2) !important;
            border-color: rgba(0, 123, 255, 0.5) !important;
        }



        .dark-theme .panel-toggle-btn {
            background: rgba(50, 50, 50, 0.95) !important;
            border-color: rgba(255, 255, 255, 0.1) !important;
            color: #ffffff;
        }

        /* ======================================== */
        /* LAYERS PANEL STYLES - SWISS GEOPORTAL */
        /* ======================================== */
        .layers-panel {
            position: fixed !important;
            bottom: 40px !important;
            right: 20px !important;
            width: auto !important;
            background: transparent !important;
            backdrop-filter: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            border: none !important;
            z-index: 1000 !important;
            overflow: visible !important;
        }

        .layers-close-btn {
            position: absolute !important;
            top: -8px !important;
            right: -8px !important;
            width: 20px !important;
            height: 20px !important;
            background: rgba(255, 255, 255, 0.9) !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            z-index: 1001 !important;
            transition: all 0.2s ease !important;
            color: #666 !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
        }

        .layers-close-btn:hover {
            background: rgba(255, 255, 255, 1) !important;
            color: #333 !important;
            transform: scale(1.1) !important;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) !important;
        }



        .base-map-row {
            display: flex !important;
            gap: 8px !important;
            align-items: flex-start !important;
            overflow-x: auto !important;
            padding-bottom: 8px !important;
        }

        .base-map-card {
            flex-shrink: 0 !important;
            width: 80px !important;
            height: 60px !important;
            border: 2px solid #ddd !important;
            border-radius: 6px !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            position: relative !important;
            overflow: hidden !important;
            background: #f8f8f8 !important;
        }

        .base-map-card:hover {
            border-color: #007bff !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
        }

        .base-map-card.selected {
            border-color: #e74c3c !important;
            border-width: 3px !important;
        }

        .base-map-preview {
            width: 100% !important;
            height: 40px !important;
            position: relative !important;
            overflow: hidden !important;
        }

        .base-map-overlay {
            position: absolute !important;
            bottom: 0 !important;
            left: 0 !important;
            right: 0 !important;
            height: 20px !important;
            background: rgba(51, 51, 51, 0.8) !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .base-map-overlay span {
            color: white !important;
            font-size: 10px !important;
            font-weight: 500 !important;
            text-align: center !important;
            line-height: 1 !important;
        }

        /* Map Preview Styles */
        .no-background {
            background: white !important;
        }

        .grid-overlay {
            width: 100% !important;
            height: 100% !important;
            background-image: radial-gradient(circle, #ccc 1px, transparent 1px) !important;
            background-size: 8px 8px !important;
            opacity: 0.3 !important;
        }

        .osm-preview {
            background: #f0f0f0 !important;
        }

        .map-details {
            width: 100% !important;
            height: 100% !important;
            position: relative !important;
        }

        .roads {
            position: absolute !important;
            top: 20px !important;
            left: 10px !important;
            right: 10px !important;
            height: 2px !important;
            background: #f4d03f !important;
            border-radius: 1px !important;
        }

        .roads::before {
            content: '' !important;
            position: absolute !important;
            top: 8px !important;
            left: 0 !important;
            right: 0 !important;
            height: 1px !important;
            background: #bdc3c7 !important;
            border-radius: 0.5px !important;
        }

        .buildings {
            position: absolute !important;
            top: 8px !important;
            left: 15px !important;
            width: 4px !important;
            height: 4px !important;
            background: #2c3e50 !important;
        }

        .buildings::before {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 8px !important;
            width: 3px !important;
            height: 3px !important;
            background: #2c3e50 !important;
        }

        .buildings::after {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 16px !important;
            width: 2px !important;
            height: 2px !important;
            background: #2c3e50 !important;
        }

        .water {
            position: absolute !important;
            top: 25px !important;
            left: 5px !important;
            width: 15px !important;
            height: 8px !important;
            background: #3498db !important;
            border-radius: 2px !important;
        }

        .contours {
            position: absolute !important;
            top: 10px !important;
            left: 10px !important;
            right: 10px !important;
            height: 1px !important;
            background: #8B4513 !important;
        }

        .contours::before {
            content: '' !important;
            position: absolute !important;
            top: 6px !important;
            left: 0 !important;
            right: 0 !important;
            height: 1px !important;
            background: #A0522D !important;
        }

        .contours::after {
            content: '' !important;
            position: absolute !important;
            top: 12px !important;
            left: 0 !important;
            right: 0 !important;
            height: 1px !important;
            background: #8B4513 !important;
        }

        .topo-preview {
            background: linear-gradient(135deg, #f4f1de 0%, #e8d5c4 100%) !important;
        }

        .mono-preview {
            background: #f5f5f5 !important;
        }

        .satellite-preview {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 50%, #f39c12 100%) !important;
        }

        .satellite-texture {
            width: 100% !important;
            height: 100% !important;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(255,255,255,0.3) 1px, transparent 1px),
                radial-gradient(circle at 80% 70%, rgba(255,255,255,0.2) 1px, transparent 1px) !important;
            background-size: 8px 8px, 12px 12px !important;
        }

        .more-preview {
            background: #34495e !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .arrow-icon {
            color: white !important;
            font-size: 16px !important;
            font-weight: bold !important;
        }



        /* Dark Theme Support for Layers Panel */
        .dark-theme .base-map-card {
            background: #2c3e50 !important;
            border-color: #34495e !important;
        }

        /* Force hide any circular buttons or overlays */
        [style*="border-radius: 50%"],
        [style*="border-radius: 50px"],
        [style*="border-radius: 25px"],
        [style*="border-radius: 20px"],
        [style*="border-radius: 15px"] {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            width: 0 !important;
            height: 0 !important;
            position: absolute !important;
            top: -9999px !important;
            left: -9999px !important;
            z-index: -9999 !important;
        }

        /* Force hide any old panels or conflicting elements */
        #oldRightPanel,
        .old-right-panel,
        [id*="old"],
        [class*="old"],
        .cesium-viewer-toolbar,
        .cesium-widget-toolbar,
        .cesium-toolbar-button,
        .cesium-button,
        .cesium-navigation-help-button,
        .cesium-home-button,
        .cesium-scene-mode-picker,
        .cesium-base-layer-picker,
        .cesium-geocoder-container {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            width: 0 !important;
            height: 0 !important;
            position: absolute !important;
            top: -9999px !important;
            left: -9999px !important;
            z-index: -9999 !important;
        }

        #rightPanel.collapsed {
            width: 32px !important;
            height: 32px !important;
            padding: 0 !important;
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }
        
        #rightPanel.collapsed .tool-icon {
            display: none !important;
        }
        
        #rightPanel.collapsed .tool-grid {
            display: none !important;
        }
        

        
        #rightPanel.collapsed .panel-toggle-btn {
            display: flex !important;
            position: fixed !important;
            top: 20px !important;
            right: 15px !important;
            margin: 0 !important;
            width: 28px !important;
            height: 28px !important;
            background: rgba(255,255,255,0.95) !important;
            border: 1px solid rgba(0,0,0,0.1) !important;
            border-radius: 6px !important;
            align-items: center !important;
            justify-content: center !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
            color: #333 !important;
            z-index: 1002 !important;
        }
        
        #rightPanel.collapsed .panel-toggle-btn:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            border-color: rgba(0, 123, 255, 0.3) !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) !important;
        }
        




        /* Floating toggle button for collapsed left panel */
        .floating-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #ddd;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1002;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
        }

        .floating-toggle:hover {
            background: rgba(255,255,255,0.3);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }



        /* Swiss Geoportal Style Tool Icons */
        .tool-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px !important;
            background: transparent !important;
            border: none !important;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 16px;
            color: #333 !important;
            box-shadow: none !important;
            font-weight: 400;
            margin: 0 auto;
            flex-shrink: 0;
            position: relative;
        }

        .tool-icon:hover {
            background: rgba(0, 0, 0, 0.08) !important;
            border-radius: 6px !important;
            transform: translateY(-1px);
        }

        .tool-icon.active {
            background: rgba(0, 123, 255, 0.1) !important;
            color: #007bff !important;
            border-radius: 6px !important;
        }

        .tool-icon:active {
            transform: translateY(0px);
        }

        /* Swiss Style SVG icons */
        .tool-icon svg {
            width: 18px;
            height: 18px;
            color: #333 !important;
            stroke: #333 !important;
            fill: none;
            stroke-width: 1.5;
            transition: all 0.2s ease;
        }

        .tool-icon:hover svg {
            color: #000 !important;
            stroke: #000 !important;
        }

        .tool-icon.active svg {
            color: #007bff !important;
            stroke: #007bff !important;
        }

        /* Left Panel Collapse State */
        .sidebar.collapsed {
            transform: translateX(-200px) !important;
            width: 80px !important;
            overflow: visible !important;
        }
        
        /* Hide sidebar content when collapsed but keep toggle visible */
        .sidebar.collapsed .sidebar-header,
        .sidebar.collapsed .sidebar-section {
            display: none;
        }
        

        
        /* Hide all tools when collapsed */
        #rightPanel.collapsed .tool-icon {
            display: none;
        }

        /* Info display styling */
        .info-display {
            cursor: default !important;
            font-family: monospace;
        }

        .info-display:hover {
            transform: none !important;
            background: rgba(255,255,255,0.1) !important;
        }

        /* Hide default zoom controls since we have new ones */
        .zoom-controls {
            display: none;
        }
        
        /* Completely hide the bottom area where timeline appears */
        .cesium-widget,
        .cesium-viewer {
            bottom: 0 !important;
            height: 100% !important;
        }



        .top-search-container {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .top-search-wrapper {
            position: relative;
            background: rgba(255,255,255,0.3);
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 4px 8px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .top-search-input {
            flex: 1;
            border: none;
            outline: none;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 20px;
            background: transparent;
        }

        /* Floating search bar */
        .top-search-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            display: none;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Show floating search bar when search is active */
        .top-search-container.active {
            display: block;
        }

        /* Dark theme support for floating search */
        .dark-theme .top-search-container {
            background: rgba(30, 30, 30, 0.95);
            border-color: rgba(255, 255, 255, 0.1);
        }



        .top-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #dc143c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }

        .top-suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(255,255,255,0.8);
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
        }

        .top-suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }

        .top-suggestion-item:hover,
        .top-suggestion-item.selected {
            background: rgba(0,0,0,0.05);
        }

        .top-suggestion-item:last-child {
            border-bottom: none;
        }



        .contact-info {
            color: #666;
            font-size: 13px;
        }

        .contact-info a {
            color: #3498db;
            text-decoration: none;
        }

        .contact-info a:hover {
            text-decoration: underline;
        }

        /* Adjust main container - no top panel */
        #cesiumContainer {
            top: 0 !important;
            height: 100vh !important;
        }
        
        /* Target specific timeline elements more precisely */
        .cesium-viewer .cesium-viewer-bottom,
        .cesium-viewer-bottom,
        div[class*="cesium-viewer-bottom"],
        div[class*="timeline"],
        div[class*="animation"] {
            display: none !important;
            height: 0 !important;
            width: 0 !important;
            visibility: hidden !important;
            opacity: 0 !important;
            position: absolute !important;
            top: -9999px !important;
            left: -9999px !important;
            z-index: -9999 !important;
        }

        /* Update theme toggle button position */
        .theme-toggle-button {
            position: absolute;
            top: 10px;
            right: 150px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #333;
            z-index: 999;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .theme-toggle-button:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* Bottom Information Band */
        #bottomBand {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            -webkit-backdrop-filter: blur(30px) saturate(200%) brightness(1.5);
            border-top: 1px solid #ddd;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            padding: 0 15px;
            z-index: 1000;
            backdrop-filter: blur(15px);
            font-size: 11px;
            overflow: hidden;
        }

        .bottom-left, .bottom-center, .bottom-right {
            display: flex;
            align-items: center;
            gap: 12px;
            white-space: nowrap;
            overflow: hidden;
        }

        .bottom-left {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            overflow: hidden;
            gap: 4px;
        }

        .bottom-center {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            overflow: hidden;
            text-align: left;
            padding-left: 10px;
        }



        .bottom-right {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: flex-end;
            text-align: right;
            gap: 2px;
            overflow: hidden;
        }

        #revisionInfo {
            font-size: 9px;
            color: #888;
            font-style: italic;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #bottomBand {
                padding: 0 8px;
                font-size: 9px;
                grid-template-columns: 0.6fr 1.2fr 1.2fr;
            }
            
            #coordinatesInfo {
                font-size: 8px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            #activeLayersInfo {
                font-size: 8px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 45%;
            }
            
            #attributionInfo {
                font-size: 8px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 45%;
            }
            
            #revisionInfo {
                font-size: 7px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 45%;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            #bottomBand {
                padding: 0 6px;
                font-size: 8px;
                grid-template-columns: 0.5fr 1.2fr 1.3fr;
            }
            
            #coordinatesInfo {
                font-size: 7px;
            }
            
            #activeLayersInfo {
                font-size: 7px;
                max-width: 40%;
            }
            
            #attributionInfo {
                font-size: 7px;
                max-width: 40%;
            }
            
            #revisionInfo {
                font-size: 6px;
                max-width: 40%;
            }
        }

        /* Scale Bar in Bottom Band */
        .scale-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .scale-bar {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .scale-line {
            height: 2px;
            background: #333;
            border-left: 2px solid #333;
            border-right: 2px solid #333;
            min-width: 50px;
        }

        .scale-text {
            font-size: 10px;
            color: #333;
            font-weight: 500;
            white-space: nowrap;
            min-width: 30px;
        }
        
        /* Mobile scale bar adjustments */
        @media (max-width: 768px) {
            .scale-bar-container {
                gap: 2px;
            }
            
            .scale-text {
                font-size: 8px;
                min-width: 20px;
            }
            
            .scale-line {
                min-width: 20px;
                max-width: 40px;
            }
        }
        
        @media (max-width: 480px) {
            .scale-text {
                font-size: 7px;
                min-width: 15px;
            }
            
            .scale-line {
                min-width: 15px;
                max-width: 30px;
            }
            
            .scale-bar-container {
                gap: 1px;
            }
        }

        #coordinatesInfo {
            font-size: 10px;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
            text-align: center;
            margin: auto;
        }

        #activeLayersInfo {
            font-size: 10px;
            color: #333;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        #attributionInfo {
            font-size: 10px;
            color: #666;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .sidebar-header {
            background: rgba(220, 20, 60, 0.3);
            color: #dc143c;
            padding: 12px 15px;
            font-weight: 600;
            font-size: 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-toggle {
            position: fixed;
            top: 20px;
            left: 25px;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.95) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
            border-radius: 6px !important;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333 !important;
            z-index: 1003;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1) !important;
        }

        .sidebar-toggle:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            border-color: rgba(0, 123, 255, 0.3) !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) !important;
        }



        /* Floating menu button when sidebar is collapsed - maps.geo.admin style */
        .floating-menu-button {
            position: fixed;
            top: 20px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            z-index: 1002;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.2s ease;
            font-weight: bold;
        }

        /* Collapsed left panel toggle button */
        .collapsed-left-toggle {
            position: fixed;
            top: 20px;
            left: 25px;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.95) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
            border-radius: 6px !important;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            color: #333 !important;
            z-index: 1003;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1) !important;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .floating-menu-button:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Ensure sidebar is visible by default on desktop */
        .sidebar {
            transform: translateX(0);
        }
        
        .sidebar.collapsed {
            transform: translateX(-100%);
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .sidebar {
                width: 300px;
                height: calc(100vh - 80px); /* Account for top panel (40px) and bottom band (40px) */
                bottom: 40px; /* Add bottom spacing for the bottom band */
            }
        }

        .sidebar-section {
            border-bottom: 1px solid var(--sidebar-border);
        }

        /* Sidebar Logo Styling */
        .sidebar-logo {
            position: absolute;
            top: 8px;
            right: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            z-index: 1001;
        }

        .sidebar-logo .app-title {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            line-height: 1;
            gap: 2px;
        }

        .sidebar-logo .title-main {
            font-weight: 900;
            color: #333;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            letter-spacing: -0.5px;
        }

        .sidebar-logo .title-second-line {
            display: flex;
            align-items: baseline;
            line-height: 1;
        }

        .sidebar-logo .title-earth {
            font-weight: 900;
            color: #333;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            letter-spacing: -0.5px;
        }

        .sidebar-logo .title-app {
            font-weight: 400;
            color: #666;
            font-size: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin-left: 2px;
        }

        /* Dark theme support for sidebar logo */
        .dark-theme .sidebar-logo .title-main,
        .dark-theme .sidebar-logo .title-earth {
            color: #ffffff;
        }

        .dark-theme .sidebar-logo .title-app {
            color: #cccccc;
        }

        .section-header {
            padding: 12px 15px;
            background: transparent;
            font-weight: 600;
            font-size: 12px;
            color: var(--text-muted);
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid var(--sidebar-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
            touch-action: manipulation; /* Better touch response on mobile */
        }

        .section-header:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .section-content {
            padding: 10px 15px;
            background: transparent;
            transition: background-color 0.3s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        .control-item {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 12px;
        }

        .control-item input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(0.9);
        }

        .control-item label {
            cursor: pointer;
            user-select: none;
            flex: 1;
            color: var(--text-color);
        }

        .control-item label {
            cursor: pointer;
            user-select: none;
            flex: 1;
        }

        .control-button {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            color: #333;
            margin-bottom: 6px;
            transition: background 0.2s ease;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .control-button.primary {
            background: rgba(13, 110, 253, 0.3);
            color: #0d6efd;
            border-color: #0d6efd;
        }

        .control-button.primary:hover {
            background: rgba(13, 110, 253, 0.5);
        }

        .control-button.secondary {
            background: rgba(108, 117, 125, 0.3);
            color: #6c757d;
            border-color: #6c757d;
        }

        .control-button.secondary:hover {
            background: rgba(108, 117, 125, 0.5);
        }

        .webgl-notice {
            margin-top: 10px;
            padding: 8px;
            background: transparent;
            border: 1px solid #ffc107;
            border-radius: 3px;
            font-size: 11px;
            color: #856404;
        }

        /* Model upload section */
        .model-upload-section {
            margin-top: 8px;
            padding: 6px;
            background: transparent;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .model-upload-button {
            width: 100%;
            padding: 5px 8px;
            background-color: rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.5);
            border-radius: 3px;
            color: #4caf50;
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .model-upload-button:hover {
            background-color: rgba(76, 175, 80, 0.5);
        }

        .model-upload-hint {
            font-size: 7px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin: 2px 0;
            line-height: 1.1;
        }

        .sample-models-button {
            width: 100%;
            padding: 4px 6px;
            background-color: rgba(33, 150, 243, 0.3);
            border: 1px solid rgba(33, 150, 243, 0.5);
            border-radius: 3px;
            color: #2196f3;
            font-size: 9px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 3px;
        }

        .sample-models-button:hover {
            background-color: rgba(33, 150, 243, 0.5);
        }

        /* Service Loader Panel styles */
        .service-loader-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            max-height: 80vh;
            background: rgba(44, 62, 80, 0.95);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            color: white;
            font-family: Arial, sans-serif;
            z-index: 10000;
            overflow-y: auto;
        }

        .service-loader-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .service-loader-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
        }

        .service-loader-content {
            padding: 20px;
        }

        .service-format-selector {
            margin-bottom: 20px;
        }

        .service-format-selector label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .service-format-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            color: #333;
            font-size: 13px;
        }

        .service-input-group {
            margin-bottom: 15px;
        }

        .service-input-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #bdc3c7;
        }

        .service-loader-actions {
            margin: 20px 0;
        }

        .active-layers-section {
            margin-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }

        .active-layers-title {
            font-size: 13px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 10px;
        }

        .active-layers-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px;
            margin: 2px 0;
            background: transparent;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: default;
            font-size: 11px;
            transition: all 0.2s ease;
        }
        
        .layer-item[draggable="true"] {
            cursor: grab;
        }
        
        .layer-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .layer-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }
        
        .layer-item.drag-over {
            background: rgba(52, 152, 219, 0.1);
            border-color: #3498db;
        }
        
        .layer-drag-handle {
            color: #999;
            margin-right: 6px;
            cursor: grab;
            user-select: none;
            padding: 4px;
            border-radius: 2px;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .layer-drag-handle:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .layer-drag-handle:active {
            cursor: grabbing;
        }

        .layer-info {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layer-name {
            font-weight: 500;
            color: #333;
        }

        .layer-type {
            color: #95a5a6;
            font-size: 10px;
        }

        .layer-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            -webkit-user-drag: none;
            -moz-user-drag: none;
            -ms-user-drag: none;
            user-drag: none;
        }
        
        .layer-controls * {
            pointer-events: auto;
            -webkit-user-drag: none;
            -moz-user-drag: none;
            -ms-user-drag: none;
            user-drag: none;
        }
        
        .opacity-slider {
            width: 60px;
            pointer-events: auto;
        }
        
        .remove-layer-btn {
            width: 20px;
            height: 20px;
            border: none;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        
        .remove-layer-btn:hover {
            background: #c0392b;
        }
        
        .layer-info-area {
            flex: 1;
            display: flex;
            align-items: center;
            min-height: 20px;
            pointer-events: none;
        }
        
        .opacity-slider {
            width: 60px;
            height: 4px;
        }
        
        .remove-layer-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .remove-layer-btn:hover {
            background: #c82333;
        }

        .layer-toggle-btn {
            padding: 4px 8px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
        }

        .layer-toggle-btn.disabled {
            background: #7f8c8d;
        }

        .layer-remove-btn {
            padding: 4px 8px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
        }

        /* Measurement tool styles */
        .measurement-controls, .marker-controls {
            position: fixed;
            top: 330px;
            right: 20px;
            width: 220px;
            background: rgba(42, 42, 42, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(15px);
        }

        .measurement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .measurement-title {
            font-weight: bold;
            font-size: 13px;
            color: #ffa500;
        }

        .measurement-mode-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .measurement-mode-btn {
            flex: 1;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .measurement-mode-btn.active {
            background: #ffa500;
            border-color: #ffa500;
            color: black;
            font-weight: bold;
        }

        .measurement-mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        .measurement-units {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .measurement-units label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }

        .measurement-units select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: white;
            font-size: 11px;
            padding: 3px 6px;
            cursor: pointer;
        }

        .measurement-results {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 10px;
            min-height: 60px;
        }

        .measurement-result-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 11px;
        }

        .measurement-result-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .measurement-result-value {
            color: #ffa500;
            font-weight: bold;
        }

        .measurement-actions {
            display: flex;
            gap: 6px;
        }

        .measurement-btn {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .measurement-btn.primary {
            background: rgba(255, 165, 0, 0.3);
            color: #ffa500;
            font-weight: bold;
            border: 1px solid #ffa500;
        }

        .measurement-btn.primary:hover {
            background: rgba(255, 165, 0, 0.5);
        }

        .measurement-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .measurement-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .measurement-instructions {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin: 8px 0;
            line-height: 1.3;
        }

        /* Point Marker Management Styles */
        .points-section {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 12px;
            padding-top: 12px;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .points-title {
            font-size: 12px;
            font-weight: bold;
            color: #ffa500;
        }

        .points-count {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 10px;
        }

        .points-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 8px;
        }

        .point-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
            border-left: 3px solid #ff0000;
        }

        .point-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .point-name-input {
            background: transparent;
            border: none;
            color: white;
            font-size: 11px;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 2px;
            flex: 1;
            margin-right: 6px;
        }

        .point-name-input:focus {
            background: rgba(255, 255, 255, 0.1);
            outline: 1px solid #ffa500;
        }

        .point-actions {
            display: flex;
            gap: 4px;
        }

        .point-action-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }

        .point-color-btn {
            background: #ff0000;
            color: white;
        }

        .point-color-btn:hover {
            opacity: 0.8;
        }

        .point-delete-btn {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6666;
            border: 1px solid rgba(255, 0, 0, 0.3);
        }

        .point-delete-btn:hover {
            background: rgba(255, 0, 0, 0.4);
        }

        .point-coordinates {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.7);
            font-family: monospace;
            margin: 2px 0;
        }

        .point-timestamp {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
        }

        .color-picker-dropdown {
            position: absolute;
            background: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 8px;
            z-index: 10000;
            display: none;
            flex-wrap: wrap;
            gap: 4px;
            width: 120px;
        }

        .color-option {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }

        .color-option:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .points-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .points-clear-btn {
            flex: 1;
            padding: 4px 8px;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 3px;
            color: #ff6666;
            font-size: 10px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .points-clear-btn:hover {
            background: rgba(255, 0, 0, 0.4);
        }



        @media (max-width: 768px) {
            .zoom-controls {
                top: 55px;
                right: 8px;
            }

            .zoom-button {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }

            .layer-controls {
                top: 60px;
                left: 8px;
                padding: 8px;
                min-width: 100px;
            }

            .layer-toggle label {
                font-size: 11px;
            }



            .tool-icon {
                width: 28px;
                height: 28px;
            }
        }

        /* Drag and drop overlay styling */
        .drag-drop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .drag-drop-content {
            background-color: rgba(255, 255, 255, 0.95);
            border: 3px dashed #4CAF50;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            max-width: 300px;
        }

        .drag-drop-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .drag-drop-text {
            font-family: Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .drag-drop-subtext {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #666;
        }

        @media (max-width: 768px) {
            .drag-drop-content {
                padding: 30px;
                max-width: 250px;
            }

            .drag-drop-icon {
                font-size: 36px;
            }

            .drag-drop-text {
                font-size: 16px;
            }

            .drag-drop-subtext {
                font-size: 12px;
            }
        }
        
        /* Panel transparency - bright white with 50% transparency */
        .sidebar,
        #bottomBand,
        .top-panel {
            background: rgba(255, 255, 255, 0.85) !important;
            backdrop-filter: blur(30px) saturate(200%) brightness(1.5) !important;
            -webkit-backdrop-filter: blur(30px) saturate(200%) brightness(1.5) !important;
            opacity: 1 !important;
        }
        

        
        /* Ensure sub-panels are also opaque */
        .sidebar-section,
        .sidebar-content,
        .section-content,
        .tool-icon,
        .north-arrow-container,
        .coordinates-info,
        .scale-bar-container {
            opacity: 1 !important;
        }
    </style>
</head>

<body>


    <!-- Main Cesium container -->
    <div id="cesiumContainer"></div>

    <!-- Floating Search Container -->
    <div class="top-search-container">
        <div class="top-search-wrapper">
            <input type="text" id="topSearchInput" placeholder="Search address, place, or coordinates..." autocomplete="off" class="top-search-input">
            <div class="top-loading-spinner" id="topLoadingSpinner" style="display: none;"></div>
        </div>
        <div class="top-suggestions-dropdown" id="topSuggestionsDropdown" style="display: none;"></div>
    </div>
    




    <!-- Center crosshair -->
    <div class="center-crosshair" id="centerCrosshair">
        <div class="crosshair-horizontal"></div>
        <div class="crosshair-vertical"></div>
    </div>

    <!-- ======================================== -->
    <!-- ======================================== -->
    <!-- LAYER MANAGEMENT CONTAINER -->
    <!-- ======================================== -->
    <div class="layer-management" id="layerManagement">
        <div class="layer-management-header">
            <h3 class="layer-management-title">Layer Management</h3>
            <button class="layer-management-close" onclick="document.getElementById('layerManagement').style.display='none'">&times;</button>
        </div>
        
        <div class="search-filters">
            <input type="text" id="layerSearch" class="search-input" placeholder="Search layers...">
            <div class="filter-row">
                <select id="categoryFilter" class="filter-select">
                    <option value="">All Categories</option>
                </select>
                <select id="licenseFilter" class="filter-select">
                    <option value="">All Licenses</option>
                </select>
                <select id="sortBy" class="filter-select">
                    <option value="created_at">Date</option>
                    <option value="rating">Rating</option>
                    <option value="popularity">Popularity</option>
                    <option value="title">Title</option>
                </select>
            </div>
        </div>
        
        <div class="layer-actions">
            <button id="addLayerBtn" class="btn-primary">Add Layer</button>
            <button id="uploadFileBtn" class="btn-secondary">Upload File</button>
        </div>
        
        <div id="layersContainer" class="layers-container">
            <!-- Layers will be loaded here -->
        </div>
    </div>

    <!-- LEFT PANEL TOOLBAR - TOGGLE BUTTON -->
    <!-- ======================================== -->
    <!-- 
        LEFT PANEL TOGGLE BUTTON
        - ID: leftPanelToggle
        - Function: toggleLeftPanel()
        - Position: Fixed top-left corner
        - Style: Square button matching right panel
        - Purpose: Opens/closes the left sidebar panel
    -->
    <div class="sidebar-toggle" id="leftPanelToggle" onclick="toggleLeftPanel()">
        <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </div>

    <!-- ======================================== -->
    <!-- LEFT PANEL - MAIN SIDEBAR -->
    <!-- ======================================== -->
    <!-- 
        LEFT PANEL (SIDEBAR)
        - ID: leftPanel
        - Class: sidebar
        - Function: toggleLeftPanel()
        - Position: Left side of screen
        - Purpose: Contains map layers, data services, 3D models, gizmo controls
        - Sections: Maps displayed, Data Services, 3D Models, Gizmo
        - Toggle: Use leftPanelToggle button or sidebar-close-button
    -->
    <div class="sidebar" id="leftPanel">
        <!-- Logo Section -->
        <div class="sidebar-logo">
            <div class="app-title">
                <div class="title-main">My</div>
                <div class="title-second-line">
                    <span class="title-earth">Earth</span>
                    <span class="title-app">.app</span>
                </div>
            </div>
        </div>

        <!-- Authentication Section -->
        <div class="sidebar-section">
            <div class="section-header" onclick="toggleSection('authSection')">
                <span>
                    <svg width="12" height="12" viewBox="0 0 24 24" style="margin-right: 6px; vertical-align: middle;">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" fill="none" stroke="currentColor" stroke-width="2"/>
                        <circle cx="12" cy="7" r="4" fill="none" stroke="currentColor" stroke-width="2"/>
                    </svg>
                    Account
                </span>
                <span>
                    <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6,9 12,15 18,9"/>
                    </svg>
                </span>
            </div>
            <div class="section-content" id="authSection">
                <div id="userInfo" style="display: none;"></div>
                <div id="loginButtons"></div>
            </div>
        </div>

        <!-- Maps displayed Section -->
        <div class="sidebar-section">
            <div class="section-header" onclick="toggleSection('mapsDisplayed')">
                <span><svg width="12" height="12" viewBox="0 0 24 24" style="margin-right: 6px; vertical-align: middle;"><rect x="2" y="2" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"/><path d="M6 6h12M6 12h12M6 18h12" stroke="currentColor" stroke-width="1"/></svg>Maps displayed</span>
                <span><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg></span>
            </div>
            <div class="section-content" id="mapsDisplayed">
                <!-- Base Map Selection -->
                <div style="margin-bottom: 12px;">
                    <label style="font-size: 11px; font-weight: 600; color: #555; margin-bottom: 6px; display: block;">Base Map Provider:</label>
                    <select id="baseMapSelector" onchange="switchBaseMap()" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px; background: rgba(255, 255, 255, 0.3);">
                        <option value="openstreetmap" selected>OSM Standard</option>
                        <option value="opentopomap">OpenTopoMap</option>
                        <option value="monochrome">Monochrome (Light)</option>
                        <option value="dark_mode">Dark Mode</option>
                        <option value="cartodb_positron">CartoDB Positron</option>
                        <option value="esri_world">ESRI World Imagery</option>
                    </select>
                </div>
                
                <!-- Layer Visibility Controls -->
                <div class="control-item">
                    <input type="checkbox" id="baseLayerToggle" checked>
                    <label for="baseLayerToggle">Base Map Visible</label>
                </div>
                <div class="control-item">
                    <input type="checkbox" id="atmosphereToggle" checked onchange="toggleAtmosphere()">
                    <label for="atmosphereToggle">Atmosphere Effects</label>
                </div>
                <div class="control-item">
                    <input type="checkbox" id="terrainToggle" checked onchange="toggleTerrain()">
                    <label for="terrainToggle">3D Terrain</label>
                </div>
            </div>
        </div>
        
        <!-- Data Services Section -->
        <div class="sidebar-section">
            <div class="section-header" onclick="toggleSection('dataServices')">
                <span><svg width="12" height="12" viewBox="0 0 24 24" style="margin-right: 6px; vertical-align: middle;"><circle cx="12" cy="12" r="3" fill="none" stroke="currentColor" stroke-width="2"/><path d="M12 1v6m0 6v6M5.6 5.6l4.2 4.2m4.2 4.2l4.2 4.2M1 12h6m6 0h6M5.6 18.4l4.2-4.2m4.2-4.2l4.2-4.2" stroke="currentColor" stroke-width="2"/></svg>Data Services</span>
                <span><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg></span>
            </div>
            <div class="section-content" id="dataServices">
                <!-- Predefined WMS Layers -->
                <div style="margin-bottom: 12px;">
                    <label style="font-size: 11px; font-weight: 600; color: #555; margin-bottom: 6px; display: block;">WMS Data Layers:</label>
                    
                    <div class="control-item" style="margin-bottom: 4px;">
                        <input type="checkbox" id="satelliteWms" onchange="togglePredefinedLayer('satellite', this.checked)">
                        <label for="satelliteWms" style="font-size: 11px;">Satellite Imagery Overlay</label>
                    </div>
                    
                    <div class="control-item" style="margin-bottom: 4px;">
                        <input type="checkbox" id="labelsWms" onchange="togglePredefinedLayer('labels', this.checked)">
                        <label for="labelsWms" style="font-size: 11px;">Place Labels Overlay</label>
                    </div>
                    
                    <div class="control-item" style="margin-bottom: 4px;">
                        <input type="checkbox" id="terrainWms" onchange="togglePredefinedLayer('terrain', this.checked)">
                        <label for="terrainWms" style="font-size: 11px;">Terrain Lines Overlay</label>
                    </div>
                    
                    <div class="control-item" style="margin-bottom: 4px;">
                        <input type="checkbox" id="protected_areasWms" onchange="togglePredefinedLayer('protected_areas', this.checked)" checked>
                        <label for="protected_areasWms" style="font-size: 11px;">World Database of Protected Areas</label>
                    </div>
                    
                    <div class="control-item" style="margin-bottom: 8px;">
                        <input type="checkbox" id="land_degradationWms" onchange="togglePredefinedLayer('land_degradation', this.checked)">
                        <label for="land_degradationWms" style="font-size: 11px;">Global Land Degradation (Bare Ground Change)</label>
                    </div>
                </div>
                
                <!-- Active Layers List -->
                <div style="margin-bottom: 12px;">
                    <label style="font-size: 11px; font-weight: 600; color: #555; margin-bottom: 6px; display: block;">Active Layers:</label>
                    <div id="activeLayersList" style="min-height: 20px; border: 1px solid #ddd; border-radius: 3px; padding: 4px; background: transparent;">
                        <div style="font-size: 11px; color: #666; padding: 8px;">No active WMS layers</div>
                    </div>
                </div>

                <!-- Legend Section -->
                <div id="legendSection" style="margin-bottom: 12px; display: none;">
                    <label style="font-size: 11px; font-weight: 600; color: #555; margin-bottom: 6px; display: block;">Layer Legend:</label>
                    <div id="legendContainer" style="border: 1px solid #ddd; border-radius: 3px; padding: 8px; background: transparent; font-size: 10px;">
                        <!-- Legend content will be populated here -->
                    </div>
                </div>
                
                <button class="control-button primary" onclick="toggleServiceLoader()">
                    Load External Data
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 4px;">
                    Import GeoJSON, WMS, and TileJSON data sources
                </div>
            </div>
        </div>
        

        
        <!-- 3D Models Section -->
        <div class="sidebar-section">
            <div class="section-header" onclick="toggleSection('models3d')">
                <span><svg width="12" height="12" viewBox="0 0 24 24" style="margin-right: 6px; vertical-align: middle;"><path d="M12 2L2 7v10l10 5 10-5V7L12 2z" fill="none" stroke="currentColor" stroke-width="2"/><path d="M12 22V12" stroke="currentColor" stroke-width="2"/><path d="M2 7L12 12L22 7" stroke="currentColor" stroke-width="2"/></svg>3D Models</span>
                <span><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg></span>
            </div>
            <div class="section-content" id="models3d">
                <button class="control-button secondary" id="modelUploadButton">
                    Upload 3D Model
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 4px;">
                    Drag & drop any 3D format: 3D Tiles, glTF, OBJ, FBX, LAS, KML, IFC, archives, images, and more
                </div>
            </div>
        </div>
        
        <!-- Gizmo Controls Section -->
        <div class="sidebar-section">
            <div class="section-header" onclick="toggleSection('gizmo')">
                <span><svg width="12" height="12" viewBox="0 0 24 24" style="margin-right: 6px; vertical-align: middle;"><path d="M12 2L2 7v10l10 5 10-5V7L12 2z" fill="none" stroke="currentColor" stroke-width="2"/><path d="M12 22V12" stroke="currentColor" stroke-width="2"/><path d="M2 7L12 12L22 7" stroke="currentColor" stroke-width="2"/></svg>Gizmo Controls</span>
                <span><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg></span>
            </div>
            <div class="section-content" id="gizmo">
                <div class="gizmo-controls">
                    <h4> 3D Manipulation</h4>
                    <div class="gizmo-buttons">
                        <button class="gizmo-btn active" onclick="setGizmoMode('translate')"> T</button>
                        <button class="gizmo-btn" onclick="setGizmoMode('rotate')"> R</button>
                        <button class="gizmo-btn" onclick="setGizmoMode('scale')"> S</button>
                    </div>
                    <div class="gizmo-buttons">
                        <button class="gizmo-btn secondary" onclick="toggleGizmo()"> Toggle</button>
                        <button class="gizmo-btn secondary" onclick="selectNextModel()"> Next</button>
                    </div>
                    <div class="gizmo-status" id="gizmoStatus">Ready for 3D models</div>
                </div>
            </div>
        </div>
        

    </div>

    <!-- Drag and drop overlay -->
    <!-- Service Loader Panel -->
    <div class="service-loader-panel" id="serviceLoaderPanel" style="display: none;">
        <div class="service-loader-header">
            <div class="service-loader-title">Data Service Loader</div>
            <button onclick="toggleServiceLoader()" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        
        <div class="service-loader-content">
            <!-- Format Selector -->
            <div class="service-format-selector">
                <label for="serviceFormat">Service Type:</label>
                <select id="serviceFormat" onchange="updateServiceInputs()">
                    <option value="geojson">GeoJSON Data</option>
                    <option value="wms">WMS Service</option>
                    <option value="tilejson">TileJSON Service</option>
                </select>
            </div>
            
            <!-- Dynamic Input Fields -->
            <div id="serviceInputFields">
                <!-- GeoJSON inputs (default) -->
                <div id="geojsonInputs">
                    <div class="service-input-group">
                        <label for="geojsonUrl">GeoJSON URL:</label>
                        <input type="url" id="geojsonUrl" placeholder="https://example.com/data.geojson" style="width: 100%; padding: 6px; margin-top: 4px; border: 1px solid #555; border-radius: 3px; background: rgba(255, 255, 255, 0.2); color: #333;">
                        <small style="color: #aaa; font-size: 10px;">Supports public URLs or uploaded .geojson files</small>
                    </div>
                </div>
                
                <!-- WMS inputs -->
                <div id="wmsInputs" style="display: none;">
                    <div class="service-input-group">
                        <label for="wmsUrl">WMS Service URL:</label>
                        <input type="url" id="wmsUrl" placeholder="https://example.com/wms" style="width: 100%; padding: 6px; margin-top: 4px; border: 1px solid #555; border-radius: 3px; background: rgba(255, 255, 255, 0.2); color: #333;">
                    </div>
                    <div class="service-input-group">
                        <label for="wmsLayers">Layer Name(s):</label>
                        <input type="text" id="wmsLayers" placeholder="layer1,layer2" style="width: 100%; padding: 6px; margin-top: 4px; border: 1px solid #555; border-radius: 3px; background: rgba(255, 255, 255, 0.2); color: #333;">
                    </div>
                    <div class="service-input-group">
                        <label for="wmsFormat">Format (optional):</label>
                        <select id="wmsFormat" style="width: 100%; padding: 6px; margin-top: 4px; border: 1px solid #555; border-radius: 3px; background: rgba(255, 255, 255, 0.2); color: #333;">
                            <option value="image/png">PNG</option>
                            <option value="image/jpeg">JPEG</option>
                            <option value="image/gif">GIF</option>
                        </select>
                    </div>
                </div>
                
                <!-- TileJSON inputs -->
                <div id="tilejsonInputs" style="display: none;">
                    <div class="service-input-group">
                        <label for="tilejsonUrl">TileJSON URL:</label>
                        <input type="url" id="tilejsonUrl" placeholder="https://example.com/tiles.json" style="width: 100%; padding: 6px; margin-top: 4px; border: 1px solid #555; border-radius: 3px; background: rgba(255, 255, 255, 0.2); color: #333;">
                        <small style="color: #aaa; font-size: 10px;">Mapbox, custom raster tiles, or hillshade</small>
                    </div>
                </div>
            </div>
            
            <!-- Load Button -->
            <div class="service-loader-actions">
                <button onclick="loadSelectedService()" style="width: 100%; padding: 10px; background: rgba(52, 152, 219, 0.3); color: #3498db; border: 1px solid #3498db; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold;">
                    Add Layer
                </button>
            </div>
            
            <!-- Active Layers List -->
            <div class="active-layers-section">
                <div class="active-layers-title">Active Data Layers:</div>
                <div id="activeLayersList" class="active-layers-list">
                    <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 10px;">
                        No data layers loaded
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Measurement Controls - Line & Area -->
    <div class="measurement-controls" id="measurementControls" style="display: none;">
        <div class="measurement-header">
            <div class="measurement-title">Measurement</div>
            <button onclick="toggleMeasurementTool()" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        
        <div class="measurement-mode-buttons">
            <button class="measurement-mode-btn active" data-mode="line" onclick="setMeasurementMode('line')">Line</button>
            <button class="measurement-mode-btn" data-mode="area" onclick="setMeasurementMode('area')">Area</button>
        </div>
        
        <div class="measurement-units">
            <label>Units:</label>
            <select id="measurementUnits" onchange="updateMeasurementUnits()">
                <option value="metric">Metric (m)</option>
                <option value="imperial">Imperial (ft)</option>
            </select>
        </div>
        
        <div class="measurement-results" id="measurementResults">
            <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px;">
                No measurements yet
            </div>
        </div>
        
        <div class="measurement-instructions" id="measurementInstructions">
            Click two points to measure distance
        </div>
        
        <div class="measurement-actions">
            <button class="measurement-btn primary" onclick="newMeasurement()">New</button>
            <button class="measurement-btn secondary" onclick="clearMeasurements()">Clear All</button>
        </div>
    </div>

    <!-- Point Marker Controls -->
    <div class="marker-controls" id="markerControls" style="display: none;">
        <div class="measurement-header">
            <div class="measurement-title">Point Markers</div>
            <button onclick="toggleMarkerPanel()" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        
        <div class="points-list" id="pointsList">
            <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px;">
                No markers placed
            </div>
        </div>

        <div class="points-actions">
            <button class="points-clear-btn" onclick="clearAllPoints()">Clear All Points</button>
        </div>
    </div>

    <!-- Color Picker Dropdown -->
    <div class="color-picker-dropdown" id="colorPickerDropdown">
        <!-- Color options will be dynamically inserted here -->
    </div>

    <div class="drag-drop-overlay" id="dragDropOverlay" style="display: none;">
        <div class="drag-drop-content">
            <div class="drag-drop-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14,2 14,8 20,8"/>
                    <line x1="16" y1="13" x2="8" y2="13"/>
                    <line x1="16" y1="17" x2="8" y2="17"/>
                    <polyline points="10,9 9,9 8,9"/>
                </svg>
            </div>
            <div class="drag-drop-text">Drop 3D Model Here</div>
            <div class="drag-drop-subtext">Supported: GLB, GLTF, OBJ, FBX, DAE, STL, PLY, LAS, DXF, USDZ</div>
        </div>
    </div>



    <!-- ======================================== -->
    <!-- RIGHT PANEL - TOOL TOOLBAR -->
    <!-- ======================================== -->
    <!-- 
        RIGHT PANEL (TOOL TOOLBAR)
        - ID: rightPanel
        - Function: toggleRightPanel()
        - Position: Fixed right side of screen
        - Layout: 2-column grid with 20 tool buttons
        - Style: White rounded panel with Swiss geoportal design
        - Purpose: Quick access to map tools, navigation, layers, utilities
        - Toggle: Use panel-toggle-btn (hamburger menu)
        - Grid: 10 rows  2 columns = 20 total tools
        - Print Tool: Separate button at bottom
    -->
    <div id="rightPanel">
        <div class="panel-toggle-btn" onclick="toggleRightPanel()" title="Tools">
            <!-- Hamburger icon (shown when panel is closed) -->
            <svg class="hamburger-icon" width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
            <!-- X icon (shown when panel is open) -->
            <svg class="close-icon" width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </div>
        
        <div class="tool-grid">
            <!-- Row 1 -->
            <div class="tool-icon" id="zoomInTool" title="Zoom In" onclick="zoomIn()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
            </div>
            <div class="tool-icon" id="zoomOutTool" title="Zoom Out" onclick="zoomOut()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        </div>



            <!-- Row 3 -->
            <div class="tool-icon" id="northArrow" title="North Orientation" onclick="resetNorth()" style="cursor: pointer;">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <!-- Black circle background -->
                    <circle cx="12" cy="12" r="10" fill="black"/>
                    <!-- White upward-pointing arrow -->
                    <polygon points="12,6 16,14 12,12 8,14" fill="white" stroke="white"/>
                </svg>
            </div>
            <div class="tool-icon" id="fullscreenTool" title="Fullscreen" onclick="toggleFullscreen()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3"></path>
                    <path d="M21 8V5a2 2 0 0 0-2-2h-3"></path>
                    <path d="M3 16v3a2 2 0 0 0 2 2h3"></path>
                    <path d="M16 21h3a2 2 0 0 0 2-2v-3"></path>
            </svg>
        </div>

            <!-- Row 4 -->
            <div class="tool-icon" id="searchTool" title="Search" onclick="toggleSearch()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                </svg>
            </div>
            <div class="tool-icon" id="themeTool" title="Toggle Theme" onclick="toggleTheme()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
            </svg>
        </div>



            <!-- Row 7 -->
            <div class="tool-icon" id="globeTool" title="Globe View" onclick="toggleGlobeView()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M2 12h20"></path>
                    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                </svg>
            </div>
            <div class="tool-icon" id="layersTool" title="Layers" onclick="toggleLayersPanel()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.57 3.91a2 2 0 0 0 1.66 0l8.57-3.9a1 1 0 0 0 0-1.83Z"></path>
                    <path d="m22 12-8.57 3.9a2 2 0 0 1-1.66 0L3 12"></path>
                    <path d="m22 17-8.57 3.9a2 2 0 0 1-1.66 0L3 17"></path>
            </svg>
        </div>

            <!-- Row 8 -->
            <div class="tool-icon" id="markerTool" title="Add Marker" onclick="toggleMarkerPanel()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
            </div>
            <div class="tool-icon" id="shareTool" title="Share View" onclick="shareCurrentView()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="18" cy="5" r="3"></circle>
                    <circle cx="6" cy="12" r="3"></circle>
                    <circle cx="18" cy="19" r="3"></circle>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                </svg>
            </div>



            <!-- Row 10 -->
            <div class="tool-icon" id="githubTool" title="GitHub Repository" onclick="openGitHub()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path>
                    <path d="M9 18c-4.51 2-5-2-7-2"></path>
                </svg>
            </div>
            <div class="tool-icon" id="infoTool" title="Information" onclick="toggleInfoPanel()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M12 16v-4"></path>
                    <path d="M12 8h.01"></path>
            </svg>
        </div>

            <!-- Row 11 -->
            <div class="tool-icon" id="contactTool" title="Contact Support" onclick="openContactEmail()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                    <polyline points="22,6 12,13 2,6"></polyline>
                </svg>
            </div>
            <div class="tool-icon" id="printTool" title="Print to PDF" onclick="togglePrintMode()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6,9 6,2 18,2 18,9"></polyline>
                    <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
                    <rect x="6" y="14" width="12" height="8"></rect>
            </svg>
        </div>

            <!-- Row 12 - Login Icon -->
            <div class="tool-icon" id="loginTool" title="Account" onclick="toggleLeftPanel()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <circle cx="12" cy="7" r="4" fill="none" stroke="currentColor" stroke-width="2"/>
                </svg>
            </div>
            <div class="tool-icon" id="layerManagementTool" title="Layer Management" onclick="toggleLayerManagement()">
                <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="2" y="2" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M6 6h12M6 12h12M6 18h12" stroke="currentColor" stroke-width="1"/>
                </svg>
            </div>

        </div>



    </div>

    <!-- ======================================== -->
    <!-- LAYERS PANEL - SWISS GEOPORTAL STYLE -->
    <!-- ======================================== -->
    <!-- 
        LAYERS PANEL
        - ID: layersPanel
        - Purpose: Contains base map provider selection
        - Trigger: layersTool button in right panel
        - Style: Swiss geoportal horizontal layout with map thumbnails
        - Position: Overlay on top of the globe
        - Reference: https://map.geo.admin.ch/
    -->
    <div id="layersPanel" class="layers-panel" style="display: none;">
        <div class="layers-close-btn" onclick="toggleLayersPanel()">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </div>
        <div class="base-map-row">
                <div class="base-map-card" data-value="none" onclick="selectBaseMap('none')">
                    <div class="base-map-preview no-background">
                        <div class="grid-overlay"></div>
                    </div>
                    <div class="base-map-overlay">
                        <span>No background</span>
                    </div>
        </div>

                <div class="base-map-card" data-value="openstreetmap" onclick="selectBaseMap('openstreetmap')">
                    <div class="base-map-preview osm-preview">
                        <div class="map-details">
                            <div class="roads"></div>
                            <div class="buildings"></div>
                            <div class="water"></div>
                        </div>
                    </div>
                    <div class="base-map-overlay">
                        <span>OSM Standard</span>
                    </div>
    </div>

                <div class="base-map-card selected" data-value="openstreetmap" onclick="selectBaseMap('openstreetmap')">
                    <div class="base-map-preview osm-preview">
                        <div class="map-details">
                            <div class="roads"></div>
                            <div class="buildings"></div>
                            <div class="water"></div>
                        </div>
                    </div>
                    <div class="base-map-overlay">
                        <span>OSM Standard</span>
                    </div>
                </div>
                
                <div class="base-map-card" data-value="opentopomap" onclick="selectBaseMap('opentopomap')">
                    <div class="base-map-preview topo-preview">
                        <div class="map-details">
                            <div class="contours"></div>
                            <div class="roads"></div>
                            <div class="buildings"></div>
                        </div>
                    </div>
                    <div class="base-map-overlay">
                        <span>OpenTopoMap</span>
                    </div>
                </div>
                
                <div class="base-map-card" data-value="monochrome" onclick="selectBaseMap('monochrome')">
                    <div class="base-map-preview mono-preview">
                        <div class="map-details">
                            <div class="roads"></div>
                            <div class="buildings"></div>
                            <div class="water"></div>
                        </div>
                    </div>
                    <div class="base-map-overlay">
                        <span>Monochrome</span>
                    </div>
                </div>
                
                <div class="base-map-card" data-value="esri_world" onclick="selectBaseMap('esri_world')">
                    <div class="base-map-preview satellite-preview">
                        <div class="satellite-texture"></div>
                    </div>
                    <div class="base-map-overlay">
                        <span>Aerial imagery</span>
                    </div>
                </div>
                
                <div class="base-map-card more-options" onclick="showMoreMaps()">
                    <div class="base-map-preview more-preview">
                        <div class="arrow-icon">></div>
                    </div>
                    <div class="base-map-overlay">
                        <span>More...</span>
                    </div>
                </div>
            </div>
    </div>

    <!-- Bottom Information Band -->
    <div id="bottomBand">
        <div class="bottom-left">
            <!-- Integrated Scale Bar back to left -->
            <div class="scale-bar-container" id="scaleBarContainer">
                <div class="scale-bar" id="scaleBar">
                    <div class="scale-line" id="scaleLine"></div>
                    <div class="scale-text" id="scaleText">1 km</div>
                </div>
            </div>
        </div>
        <div class="bottom-center">
            <div id="coordinatesInfo">N: 45.000 E: 15.000</div>
        </div>
        <div class="bottom-right">
            <div id="activeLayersInfo">Active Layers: OSM Standard</div>
            <div id="attributionInfo"> OpenStreetMap contributors</div>
            <div id="revisionInfo">MyEarth.app v.0.4.3</div>
        </div>
    </div>












    <!-- File input (hidden) -->
    <input type="file" id="modelFileInput" accept=".gltf,.glb,.obj,.fbx,.dae,.stl,.ply,.las,.dxf,.usdz" style="display: none;">








    <!-- CesiumJS JavaScript -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    
    <!-- Gizmo System JavaScript -->
    <script src="CesiumModelImporter.js"></script>
    <script src="CesiumGizmo.js"></script>
    
    <!-- Print Overlay System -->
    <link rel="stylesheet" href="printOverlayStyles.css">
    <script src="PrintOverlay.js"></script>
    
    <!-- Authentication and Layer Management -->
    <script src="/static/js/auth.js"></script>
    <script src="/static/js/layerManager.js"></script>
    
    <script>
        // Version management and cache busting
        (function() {
            console.log(' Starting version management...');
            
            // Consistent version formatting function
            function formatVersionString(version, buildDate) {
                const date = new Date(buildDate);
                const day = date.getDate().toString().padStart(2, '0');
                const month = date.toLocaleDateString('en-GB', { month: 'short' });
                const year = date.getFullYear();
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                
                return `v${version}  ${day} ${month} ${year} ${hours}:${minutes}`;
            }
            
            // Load version from version.json (server-generated)
            async function loadVersion() {
                const versionElement = document.getElementById('appVersion');
                if (!versionElement) {
                    console.error(' Version element not found!');
                    return;
                }
                
                console.log(' Version element found, attempting to load version.json...');
                
                try {
                    const timestamp = Date.now();
                    const versionUrl = `/version.json?t=${timestamp}`;
                    console.log(' Fetching version from:', versionUrl);
                    
                    const response = await fetch(versionUrl, {
                        cache: 'no-cache',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    console.log(' Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const versionData = await response.json();
                    console.log(' Version data received:', versionData);
                    
                    // Format version string consistently using server timestamp
                    const versionString = formatVersionString(versionData.version, versionData.buildDate);
                    console.log(' Formatted version string:', versionString);
                    
                    // Update version display
                    versionElement.textContent = versionString;
                    console.log(' Version display updated successfully');
                    
                    // Cache busting for static assets using version and timestamp
                    const cacheBuster = `?v=${versionData.version}&t=${versionData.buildTimestamp}`;
                    console.log(' Applying cache buster:', cacheBuster);
                    
                    // Update CSS and JS file references with cache buster
                    const links = document.querySelectorAll('link[href*="printOverlayStyles.css"]');
                    links.forEach(link => {
                        if (!link.href.includes('?')) {
                            link.href += cacheBuster;
                        }
                    });
                    
                    const scripts = document.querySelectorAll('script[src*="PrintOverlay.js"], script[src*="CesiumModelImporter.js"], script[src*="CesiumGizmo.js"]');
                    scripts.forEach(script => {
                        if (!script.src.includes('?')) {
                            script.src += cacheBuster;
                        }
                    });
                    
                    console.log(' Version management initialized successfully:', versionString);
                    console.log(' Build info:', versionData);
                    
                } catch (error) {
                    console.error(' Failed to load version.json:', error);
                    console.error(' Error details:', error.message);
                    
                    // Fallback version using consistent formatting
                    const version = '0.3';
                    const now = new Date();
                    const versionString = formatVersionString(version, now.toISOString()) + ' (fallback)';
                    console.log(' Using fallback version:', versionString);
                    
                    // Update version display
                    versionElement.textContent = versionString;
                    
                    // Fallback cache busting
                    const cacheBuster = `?v=${version}&t=${Date.now()}`;
                    
                    // Update CSS and JS file references with cache buster
                    const links = document.querySelectorAll('link[href*="printOverlayStyles.css"]');
                    links.forEach(link => {
                        if (!link.href.includes('?')) {
                            link.href += cacheBuster;
                        }
                    });
                    
                    const scripts = document.querySelectorAll('script[src*="PrintOverlay.js"], script[src*="CesiumModelImporter.js"], script[src*="CesiumGizmo.js"]');
                    scripts.forEach(script => {
                        if (!script.src.includes('?')) {
                            script.src += cacheBuster;
                        }
                    });
                    
                    console.log(' Version management initialized (fallback):', versionString);
                }
            }
            
            // Load version immediately when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadVersion);
            } else {
                loadVersion();
            }
        })();
        
        // Simple Ion service blocking - no prototype manipulation to avoid cyclic errors
        if (typeof Cesium !== 'undefined') {
            // Disable Ion access tokens and servers
            if (Cesium.Ion) {
                Cesium.Ion.defaultAccessToken = '';
                Cesium.Ion.defaultServer = undefined;
            }
            
            // Override Ion resource to prevent usage
            if (Cesium.IonResource && Cesium.IonResource.fromAssetId) {
                Cesium.IonResource.fromAssetId = function() {
                    console.warn('Ion services disabled - using free alternatives only');
                    throw new Error('Ion services disabled');
                };
            }
        }
        
        console.log(' Ion services completely disabled - using only free, open-source data');
        
        // Safely disable timeline and animation in viewer options only
        console.log('Preparing viewer with timeline disabled');
        
        // Initialize the Cesium viewer with minimal configuration
        const viewer = new Cesium.Viewer('cesiumContainer', {
            // Disable ALL UI widgets for completely clean appearance
            animation: false,           // Remove animation controls
            baseLayerPicker: false,     // Remove base layer picker
            fullscreenButton: false,    // Remove fullscreen button - use custom
            geocoder: false,            // Remove geocoder search
            homeButton: false,          // Remove home button
            infoBox: false,             // Remove info box
            sceneModePicker: false,     // Remove scene mode picker
            timeline: false,            // Remove timeline slider
            navigationHelpButton: false, // Remove help button
            selectionIndicator: false,  // Remove selection indicator
            navigationInstructionsInitiallyVisible: false, // Remove navigation instructions
            
            // CRITICAL: Disable the toolbar completely
            showRenderLoopErrors: false,
            useDefaultRenderLoop: true,
            
            // Use ellipsoid terrain initially, will be upgraded after initialization
            terrainProvider: new Cesium.EllipsoidTerrainProvider(),
            
            // Disable all Ion-dependent features
            skyBox: false,
            skyAtmosphere: false,
            baseLayerPicker: false,
            geocoder: false,
            requestRenderMode: false,
            maximumRenderTimeChange: Infinity
        });

        // Hide the CesiumJS credits widget in bottom-right corner
        const creditsElement = viewer.cesiumWidget.creditContainer;
        if (creditsElement) {
            creditsElement.style.display = 'none';
        }

        // ULTRA-AGGRESSIVE removal of any existing toolbar and UI elements
        const ultraAggressiveRemoval = () => {
            // Remove all possible Cesium UI elements with expanded selectors
            const cesiumSelectors = [
                // Original toolbar elements
                '.cesium-viewer-toolbar:not([data-custom-toolbar])',
                '.cesium-navigationHelpButton',
                '.cesium-homeButton', 
                '.cesium-sceneModePicker',
                '.cesium-baseLayerPicker',
                '.cesium-geocoder',
                '.cesium-infoBox',
                '.cesium-selectionIndicator',
                '.cesium-viewer-navigationContainer',
                '.cesium-compass',
                '.cesium-distance-legend',
                '.cesium-navigation-help-button',
                '.cesium-home-button',
                '.cesium-scene-mode-picker',
                '.cesium-base-layer-picker',
                '.cesium-geocoder-container',
                '.cesium-compass-wrapper',
                '.cesium-compass-outer',
                '.cesium-compass-inner',
                '.cesium-compass-needle',
                '.cesium-compass-gyro',
                '.cesium-compass-rose',
                
                // Additional wildcard selectors for any remaining elements
                '[class*="cesium-navigation"]:not([data-custom-tool])',
                '[class*="cesium-zoom"]:not([data-custom-tool])',
                '[class*="cesium-compass"]:not([data-custom-tool])',
                '[class*="cesium-info"]:not([data-custom-tool])',
                '[class*="cesium-help"]:not([data-custom-tool])',
                '[class*="cesium-home"]:not([data-custom-tool])',
                '[class*="cesium-scene"]:not([data-custom-tool])',
                '[class*="cesium-base"]:not([data-custom-tool])',
                '[class*="cesium-geocoder"]:not([data-custom-tool])',
                
                // Target any buttons that don't have our custom marker
                '.cesium-button:not([data-custom-tool])',
                '.cesium-toolbar-button:not([data-custom-tool])',
                
                // Specific problematic elements that might still show
                'div[title*="Navigation"]',
                'div[title*="Home"]',
                'div[title*="Scene"]',
                'button[title*="Navigation"]',
                'button[title*="Home"]',
                'button[title*="Scene"]'
            ];
            
            let removedCount = 0;
            cesiumSelectors.forEach(selector => {
                try {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        // Double-check it's not our custom toolbar
                        if (!el.hasAttribute('data-custom-toolbar') && !el.hasAttribute('data-custom-tool')) {
                            console.log(` Removing unwanted UI element: ${selector}`, el);
                            el.style.display = 'none !important';
                            el.style.visibility = 'hidden !important';
                            el.style.opacity = '0 !important';
                            el.style.position = 'absolute !important';
                            el.style.top = '-9999px !important';
                            el.style.left = '-9999px !important';
                            el.remove();
                            removedCount++;
                        }
                    });
                } catch (e) {
                    // Ignore selector errors
                }
            });
            
            if (removedCount > 0) {
                console.log(` Removed ${removedCount} unwanted Cesium UI elements`);
            }
        };
        
        // Remove immediately and continuously
        ultraAggressiveRemoval();
        
        // Keep removing at different intervals
        setTimeout(ultraAggressiveRemoval, 10);
        setTimeout(ultraAggressiveRemoval, 50);
        setTimeout(ultraAggressiveRemoval, 100);
        setTimeout(ultraAggressiveRemoval, 250);
        setTimeout(ultraAggressiveRemoval, 500);
        setTimeout(ultraAggressiveRemoval, 1000);
        
        // Set up continuous monitoring every 2 seconds
        const continuousCleanup = setInterval(() => {
            ultraAggressiveRemoval();
        }, 2000);
        
        // Stop continuous cleanup after 30 seconds to avoid performance impact
        setTimeout(() => {
            clearInterval(continuousCleanup);
            console.log(' Stopped continuous UI cleanup - should be clean now');
        }, 30000);
        
        // Set up MutationObserver to catch dynamically added Cesium UI elements
        const observer = new MutationObserver((mutations) => {
            let shouldClean = false;
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // Check if the added node is a Cesium UI element
                        if (node.className && typeof node.className === 'string' && 
                            (node.className.includes('cesium-') || 
                             node.getAttribute && (
                                 (node.getAttribute('title') && 
                                  (node.getAttribute('title').includes('Navigation') || 
                                   node.getAttribute('title').includes('Home') || 
                                   node.getAttribute('title').includes('Scene')))
                             )) &&
                            !node.hasAttribute('data-custom-toolbar') && 
                            !node.hasAttribute('data-custom-tool')) {
                            shouldClean = true;
                        }
                    }
                });
            });
            
            if (shouldClean) {
                console.log(' Detected new Cesium UI elements, cleaning up...');
                setTimeout(ultraAggressiveRemoval, 10);
            }
        });
        
        // Start observing the document with the configured parameters
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: false
        });
        
        console.log(' MutationObserver active - will catch any new Cesium UI elements');

        // Completely disable and remove ALL CesiumJS UI elements
        setTimeout(() => {
            // First, completely remove the original toolbar
            const originalToolbar = document.querySelector('.cesium-viewer-toolbar');
            if (originalToolbar && !originalToolbar.hasAttribute('data-custom-toolbar')) {
                originalToolbar.remove();
            }
            
            const elementsToHide = [
                '.cesium-viewer-navigationContainer', 
                '.cesium-navigation-help-button',
                '.cesium-home-button',
                '.cesium-sceneModePicker-wrapper',
                '.cesium-baseLayerPicker-dropDown',
                '.cesium-animation-container',
                '.cesium-timeline-main',
                '.cesium-timeline-container',
                '.cesium-timeline-bar',
                '.cesium-timeline-tic',
                '.cesium-timeline-scrubber',
                '.cesium-timeline-epoch',
                '.cesium-animation-svgContainer',
                '.cesium-fullscreenButton',
                '.cesium-vrButton',
                '.cesium-widget-toolbar',
                '.cesium-button:not([data-custom-tool])',
                '.cesium-toolbar-button',
                '.cesium-compass',
                '.cesium-compass-wrapper'
            ];
            
            elementsToHide.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                    el.style.display = 'none';
                    el.style.visibility = 'hidden';
                    el.remove(); // Completely remove from DOM
                });
            });
            
            // Additional aggressive timeline and animation removal
            const removeTimelineInterval2 = setInterval(() => {
                const timelineElements = document.querySelectorAll('[class*="cesium-timeline"], [class*="cesium-animation"], [class*="cesium-viewer-bottom"]');
                if (timelineElements.length > 0) {
                    timelineElements.forEach(el => {
                        el.style.display = 'none !important';
                        el.style.visibility = 'hidden !important';
                        el.style.height = '0 !important';
                        el.style.width = '0 !important';
                        el.style.position = 'absolute !important';
                        el.style.top = '-9999px !important';
                        el.style.left = '-9999px !important';
                        el.remove();
                    });
                }
            }, 100);
            
            // Stop the interval after 5 seconds
            setTimeout(() => clearInterval(removeTimelineInterval2), 5000);
            
            // Inject targeted CSS to hide only timeline elements
            const hideTimelineStyle = document.createElement('style');
            hideTimelineStyle.innerHTML = `
                /* Only hide specific timeline containers */
                .cesium-viewer-bottom,
                .cesium-viewer-timelineContainer,
                .cesium-timeline-main,
                .cesium-timeline-container,
                .cesium-animation-container,
                .cesium-viewer-animationContainer {
                    display: none !important;
                    visibility: hidden !important;
                    height: 0 !important;
                    opacity: 0 !important;
                }
                
                /* Ensure the main viewer canvas is visible */
                .cesium-viewer-cesiumWidgetContainer,
                .cesium-widget,
                canvas.cesium-widget-canvas {
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                }
                
                /* Fix right panel to show all tools */
                #rightPanel {
                    max-height: none !important;
                    overflow: visible !important;
                }
            `;
            document.head.appendChild(hideTimelineStyle);
            
            console.log(' All CesiumJS UI elements forcibly removed');
        
        // Additional aggressive timeline removal with CSS
        const timelineCSS = document.createElement('style');
        timelineCSS.textContent = `
            .cesium-timeline-main,
            .cesium-timeline-container,
            .cesium-timeline-bar,
            .cesium-timeline-tic,
            .cesium-timeline-scrubber,
            .cesium-timeline-epoch,
            .cesium-animation-container,
            .cesium-animation-svgContainer,
            .cesium-home-button,
            .cesium-navigation-help-button,
            .cesium-viewer-bottom,
            .cesium-viewer-timelineContainer,
            .cesium-viewer-animationContainer,
            .cesium-widget-credits,
            .cesium-timeline,
            .cesium-animation {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                width: 0 !important;
                height: 0 !important;
                overflow: hidden !important;
                position: absolute !important;
                top: -9999px !important;
                left: -9999px !important;
                z-index: -9999 !important;
            }
        `;
        document.head.appendChild(timelineCSS);
        
        // Continuous timeline removal - check every 500ms
        const removeTimelineInterval = setInterval(() => {
            const timelineElements = document.querySelectorAll(`
                .cesium-timeline-main,
                .cesium-timeline-container,
                .cesium-timeline-bar,
                .cesium-timeline-tic,
                .cesium-timeline-scrubber,
                .cesium-timeline-epoch,
                .cesium-animation-container,
                .cesium-animation-svgContainer,
                .cesium-viewer-timelineContainer,
                .cesium-viewer-bottom
            `);
            
            timelineElements.forEach(el => {
                if (el) {
                    el.style.display = 'none';
                    el.style.visibility = 'hidden';
                    el.style.opacity = '0';
                    el.style.height = '0';
                    el.style.width = '0';
                    el.style.overflow = 'hidden';
                    el.remove();
                }
            });
            
            // Also check for any bottom containers that might contain timeline
            const bottomContainers = document.querySelectorAll('[class*="timeline"], [class*="animation"], [class*="bottom"]');
            bottomContainers.forEach(el => {
                if (el && (el.className.includes('cesium') || el.className.includes('timeline') || el.className.includes('animation'))) {
                    el.style.display = 'none';
                    el.style.visibility = 'hidden';
                    el.style.opacity = '0';
                    el.style.height = '0';
                    el.style.width = '0';
                    el.style.zIndex = '-9999';
                    el.remove();
                }
            });
            
            // Force hide the bottom container specifically - multiple approaches
            const bottomSelectors = [
                '.cesium-viewer-bottom',
                '.cesium-viewer .cesium-viewer-bottom',
                '.cesium-widget .cesium-viewer-bottom',
                'div[class*="cesium-viewer-bottom"]'
            ];
            
            bottomSelectors.forEach(selector => {
                const containers = document.querySelectorAll(selector);
                containers.forEach(container => {
                    if (container) {
                        container.style.display = 'none !important';
                        container.style.visibility = 'hidden !important';
                        container.style.opacity = '0 !important';
                        container.style.height = '0 !important';
                        container.style.zIndex = '-9999 !important';
                        container.remove();
                    }
                });
            });
        }, 500);
        
        // Stop checking after 10 seconds
        setTimeout(() => clearInterval(removeTimelineInterval), 10000);
        }, 100);

        // Keep lighting disabled to prevent rendering errors
        viewer.scene.globe.enableLighting = false;
        viewer.scene.fog.enabled = true;
        viewer.scene.fog.density = 0.0003;
        viewer.scene.fog.screenSpaceErrorFactor = 2.0;
        viewer.scene.globe.showWaterEffect = false;
        
        // Keep initial state stable
        viewer.scene.globe.enableLighting = false;
        viewer.scene.globe.depthTestAgainstTerrain = false;
        viewer.scene.globe.terrainExaggeration = 1.0;
        viewer.scene.globe.material = undefined;
        
        // Use basic lighting without dynamic atmosphere
        viewer.scene.globe.dynamicAtmosphereLighting = false;
        viewer.scene.globe.dynamicAtmosphereLightingFromSun = false;
        
        // Add wireframe material option for 3D visualization
        let wireframeEnabled = false;
        
        // Apply enhanced terrain visualization with fallback
        function applyRealTerrain() {
            try {
                // Start with stable ellipsoid base
                viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
                
                // Apply visual enhancements for 3D effect
                viewer.scene.globe.material = new Cesium.Material({
                    fabric: {
                        type: 'Grid',
                        uniforms: {
                            color: new Cesium.Color(0.0, 0.6, 1.0, 0.4),
                            cellAlpha: 0.04,
                            lineCount: new Cesium.Cartesian2(64, 32),
                            lineThickness: new Cesium.Cartesian2(1.2, 1.2)
                        }
                    }
                });
                
                viewer.scene.globe.enableLighting = true;
                viewer.scene.globe.terrainExaggeration = 1.0;
                console.log('Enhanced terrain visualization applied');
                
            } catch (error) {
                console.warn('Terrain enhancement failed, using basic mode:', error);
                viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
                viewer.scene.globe.material = undefined;
                viewer.scene.globe.enableLighting = false;
            }
        }
        
        // Apply terrain on startup
        applyRealTerrain();
        
        console.log(' All services using free, open-source providers only');
        
        // WMS layer initialization will be handled later after services are defined
        
        // Add fallback to ellipsoid terrain if the terrain provider fails
        viewer.terrainProvider.errorEvent.addEventListener(function(err) {
            console.warn('Terrain provider failed, falling back to ellipsoid:', err);
            viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
        });
        
        // Base map configurations
        const baseMaps = {
            'osm': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                    credit: 'Map data  OpenStreetMap contributors'
                }),
                attribution: ' OpenStreetMap contributors'
            },
            'otm': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
                    subdomains: ['a', 'b', 'c'],
                    credit: 'Map data  OpenStreetMap contributors, SRTM | Map style  OpenTopoMap (CC-BY-SA)'
                }),
                attribution: ' OpenStreetMap contributors, SRTM |  OpenTopoMap (CC-BY-SA)'
            },
            'stamen-terrain': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png',
                    credit: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'
                }),
                attribution: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'
            },
            'cartodb-positron': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                    subdomains: ['a', 'b', 'c', 'd'],
                    credit: ' OpenStreetMap contributors  CARTO'
                }),
                attribution: ' OpenStreetMap contributors  CARTO'
            },
            'esri-imagery': {
                provider: () => new Cesium.UrlTemplateImageryProvider({
                    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                    credit: 'Tiles  Esri  Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                }),
                attribution: 'Tiles  Esri  Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            }
        };

        // Current base map - default to OSM Standard for clean appearance
        let currentBaseMap = 'openstreetmap';
        
        // Remove default imagery and add OSM Standard (free open-source service)
        viewer.imageryLayers.removeAll();
        const defaultImageryProvider = new Cesium.UrlTemplateImageryProvider({
            url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            subdomains: ['a', 'b', 'c'],
            credit: ' OpenStreetMap contributors'
        });
        viewer.imageryLayers.addImageryProvider(defaultImageryProvider);
        
        console.log(' Using OSM Standard - free, open-source base map provider');
        
        // Set attribution for OSM Standard  
        const attributionElement = document.querySelector('.cesium-credit-textContainer');
        if (attributionElement) {
            attributionElement.innerHTML = ' OpenStreetMap contributors';
        }

        // Define Europe and North Africa overview with straight down perspective
        const europeHomeView = {
            destination: Cesium.Cartesian3.fromDegrees(10.0, 40.0, 8000000.0), // Center on Europe/North Africa
            orientation: {
                heading: Cesium.Math.toRadians(0),
                pitch: Cesium.Math.toRadians(-90), // Straight down view
                roll: 0.0
            }
        };

        // Set initial camera position centered on Europe
        viewer.camera.setView(europeHomeView);

        // Home button is disabled - no need for override
        
        // Initialize Gizmo System
        console.log(' Initializing Universal 3D Model Importer and Gizmo System...');
        
        // Initialize Model Importer
        const modelImporter = new CesiumModelImporter(viewer, {
            autoSelect: true,
            showBoundingBox: true,
            onModelImported: (model, file, fileType) => {
                console.log(' Model imported:', file.name, 'Type:', fileType);
                showMessage(` Imported: ${file.name} (${fileType})`, 'success');
            },
            onError: (error, file) => {
                console.error(' Import error:', error, file);
                showMessage(` Failed to import ${file.name}: ${error.message}`, 'error');
            }
        });
        
        // Initialize Gizmo
        const gizmo = new CesiumGizmo(viewer, {
            size: 40,
            snapping: {
                translate: 1.0,
                rotate: 15.0,
                scale: 0.5
            }
        });
        
        // Gizmo controls are now integrated into the left sidebar
        // No need to create separate UI elements
        
        // Gizmo control functions
        window.setGizmoMode = function(mode) {
            gizmo.setMode(mode);
            
            // Update button states
            document.querySelectorAll('.gizmo-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            updateGizmoStatus(`Mode: ${mode}`);
        };
        
        window.toggleGizmo = function() {
            if (gizmo.isVisible()) {
                gizmo.hide();
                updateGizmoStatus('Gizmo hidden');
            } else {
                gizmo.show();
                updateGizmoStatus('Gizmo visible');
            }
        };
        
        window.selectNextModel = function() {
            const models = Array.from(modelImporter.getImportedModels().values());
            if (models.length === 0) {
                updateGizmoStatus('No models to select');
                return;
            }
            
            // For now, just select the first model
            const model = models[0];
            modelImporter.selectModel(model.entity);
            updateGizmoStatus(`Selected: ${model.file.name}`);
        };
        
        function updateGizmoStatus(message) {
            const statusElement = document.getElementById('gizmoStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }
        
        // Listen for model selection events
        viewer.canvas.addEventListener('modelSelected', (e) => {
            const model = e.detail.model;
            updateGizmoStatus('Model selected for manipulation');
            gizmo.setSelectedEntity(model);
        });
        
        console.log(' Gizmo system initialized successfully!');
        
        // Function to add all custom tools to the toolbar
        function addAllToolsToToolbar() {
            let toolbar = document.querySelector('.cesium-viewer-toolbar');
            
            if (!toolbar) {
                // Create fallback toolbar if none exists
                toolbar = document.createElement('div');
                toolbar.className = 'cesium-viewer-toolbar';
                toolbar.setAttribute('data-custom-toolbar', 'true');
                document.body.appendChild(toolbar);
            } else {
                // Mark existing toolbar as custom
                toolbar.setAttribute('data-custom-toolbar', 'true');
            }
            
            // Clear existing custom buttons (keep Cesium buttons)
            const existingCustomButtons = toolbar.querySelectorAll('[data-custom-tool]');
            existingCustomButtons.forEach(btn => btn.remove());
            
            // Create all custom tool buttons
            const tools = [
                {
                    id: 'coordinatesTool',
                    title: 'Coordinates',
                    icon: '',
                    onClick: () => {
                        const coordinatesInfo = document.getElementById('coordinatesInfo');
                        if (coordinatesInfo) {
                            coordinatesInfo.style.display = coordinatesInfo.style.display === 'none' ? 'block' : 'none';
                        }
                    }
                },
                {
                    id: 'measureTool',
                    title: 'Measure Tool',
                    icon: '',
                    onClick: () => toggleMeasurementTool()
                },
                {
                    id: 'gizmoTool',
                    title: '3D Gizmo',
                    icon: '',
                    onClick: () => {
                        if (window.toggleGizmo) {
                            window.toggleGizmo();
                        }
                    }
                },
                {
                    id: 'zoomInTool',
                    title: 'Zoom In',
                    icon: '+',
                    onClick: () => {
                        if (window.zoomIn) {
                            window.zoomIn();
                        } else {
                            viewer.camera.zoomIn(1000000.0);
                        }
                    }
                },
                {
                    id: 'zoomOutTool',
                    title: 'Zoom Out',
                    icon: '-',
                    onClick: () => {
                        if (window.zoomOut) {
                            window.zoomOut();
                        } else {
                            viewer.camera.zoomOut(1000000.0);
                        }
                    }
                },
                {
                    id: 'resetNorthTool',
                    title: 'Reset to North',
                    icon: '',
                    onClick: () => {
                        if (window.resetViewToNorth) {
                            window.resetViewToNorth();
                        }
                    }
                }
            ];
            
            // Create and add each tool button
            tools.forEach(tool => {
                const button = document.createElement('button');
                button.className = 'cesium-button';
                button.setAttribute('data-custom-tool', tool.id);
                button.title = tool.title;
                button.innerHTML = tool.icon;
                button.onclick = tool.onClick;
                
                // Add to toolbar
                toolbar.appendChild(button);
            });
            
            console.log(' All custom tools added to right toolbar');
            
            // Forcefully remove any remaining old Cesium buttons
            setTimeout(() => {
                const oldButtons = document.querySelectorAll('.cesium-navigation-help-button, .cesium-home-button, .cesium-scene-mode-picker, .cesium-base-layer-picker, .cesium-geocoder-container, .cesium-compass, .cesium-compass-wrapper');
                oldButtons.forEach(btn => {
                    btn.style.display = 'none';
                    btn.style.visibility = 'hidden';
                    btn.style.opacity = '0';
                    btn.style.pointerEvents = 'none';
                    btn.style.position = 'absolute';
                    btn.style.top = '-9999px';
                    btn.style.left = '-9999px';
                    btn.style.width = '0';
                    btn.style.height = '0';
                });
                console.log(` Removed ${oldButtons.length} old Cesium buttons`);
            }, 100);
            
            // Additional aggressive removal with multiple attempts
            const removeOldButtons = () => {
                const toolbar = document.querySelector('.cesium-viewer-toolbar');
                if (toolbar) {
                    const allButtons = toolbar.querySelectorAll('button, div');
                    allButtons.forEach(btn => {
                        if (!btn.hasAttribute('data-custom-tool')) {
                            btn.remove();
                        }
                    });
                }
            };
            
            // Try multiple times to ensure removal
            setTimeout(removeOldButtons, 200);
            setTimeout(removeOldButtons, 500);
            setTimeout(removeOldButtons, 1000);
            setTimeout(removeOldButtons, 2000);
            
            // Continuous monitoring to prevent old buttons from reappearing
            setInterval(() => {
                // Remove any toolbar that doesn't have our custom attribute
                const allToolbars = document.querySelectorAll('.cesium-viewer-toolbar');
                allToolbars.forEach(tb => {
                    if (!tb.hasAttribute('data-custom-toolbar')) {
                        tb.remove();
                    }
                });
                
                // Remove any buttons without our custom attribute
                removeOldButtons();
            }, 1000);
        }
        
        // Initialize Print Overlay System
        console.log(' Initializing Print Overlay System...');
        
        // Ensure jsPDF is available before initializing
        const ensureJsPDF = async () => {
            // Check if jsPDF is already available
            if (typeof window.jspdf !== 'undefined' || typeof jsPDF !== 'undefined') {
                console.log(' jsPDF already available');
                return true;
            }
            
            // Wait a bit for scripts to load
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Check again
            if (typeof window.jspdf !== 'undefined' || typeof jsPDF !== 'undefined') {
                console.log(' jsPDF loaded after delay');
                return true;
            }
            
            console.warn(' jsPDF not available, attempting to load...');
            
            // Try to load jsPDF manually
            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                script.onload = () => {
                    console.log(' jsPDF loaded manually');
                    resolve(true);
                };
                script.onerror = () => {
                    console.error(' Failed to load jsPDF manually');
                    resolve(false);
                };
                document.head.appendChild(script);
            });
        };
        
        // Initialize PrintOverlay after ensuring jsPDF is available
        ensureJsPDF().then((jsPDFAvailable) => {
            if (jsPDFAvailable) {
                const printOverlay = new PrintOverlay(viewer, {
                    defaultPaperSize: 'A4',
                    defaultOrientation: 'portrait',
                    defaultScale: '1:1\'500\'000', // Swiss standard default
                    includeLegend: true,
                    includeGrid: false,
                    includeTitle: true,
                    includeCopyright: true
                });
                
                // Make printOverlay globally accessible
                window.printOverlay = printOverlay;
                console.log(' Print overlay system initialized successfully!');
                
                // Add all tools to toolbar after print overlay is ready
                setTimeout(addAllToolsToToolbar, 500);
            } else {
                console.error(' Cannot initialize PrintOverlay: jsPDF not available');
            }
        });
        
        // Add print button integrated into the right toolbar
        setTimeout(() => {
            // Create print button with proper Cesium toolbar styling
            const printButton = document.createElement('button');
            printButton.innerHTML = '';
            printButton.title = 'Print to PDF';
            printButton.className = 'cesium-button'; // Use Cesium's button class for consistent styling
            
            // Add click handler
            printButton.onclick = () => {
                console.log(' Print button clicked');
                if (window.printOverlay) {
                    window.printOverlay.togglePrintMode();
                } else {
                    alert('Print overlay not found! Check console for errors.');
                }
            };
            
            // Find the right toolbar and add the print button
            const addToToolbar = () => {
                // Look for the Cesium viewer toolbar
                let toolbar = document.querySelector('.cesium-viewer-toolbar');
                
                if (!toolbar) {
                    // Try alternative selectors
                    toolbar = document.querySelector('.cesium-viewer-toolbar-container');
                }
                
                if (!toolbar) {
                    // Look for any container with multiple circular buttons
                    const containers = document.querySelectorAll('div');
                    for (let container of containers) {
                        const buttons = container.querySelectorAll('button');
                        if (buttons.length >= 6 && buttons[0].style.borderRadius === '50%') {
                            toolbar = container;
                            break;
                        }
                    }
                }
                
                if (toolbar) {
                    // Insert the print button at the bottom of the toolbar
                    toolbar.appendChild(printButton);
                    console.log(' Print button integrated into right toolbar with consistent styling');
                } else {
                    // Fallback: create a minimal toolbar container
                    const fallbackToolbar = document.createElement('div');
                    fallbackToolbar.className = 'cesium-viewer-toolbar';
                    fallbackToolbar.style.cssText = `
                        position: fixed;
                        top: 50%;
                        right: 20px;
                        transform: translateY(-50%);
                        background: rgba(255, 255, 255, 0.5);
                        backdrop-filter: blur(10px);
                        border-radius: 12px;
                        padding: 8px;
                        flex-direction: column;
                        display: flex;
                        gap: 6px;
                        z-index: 1000;
                    `;
                    fallbackToolbar.appendChild(printButton);
                    document.body.appendChild(fallbackToolbar);
                    console.log(' Toolbar not found, created fallback toolbar for print button');
                }
            };
            
            // Try to add to toolbar
            addToToolbar();
            
            // Retry after a delay in case toolbar loads later
            setTimeout(addToToolbar, 1000);
            setTimeout(addToToolbar, 3000);
            
            // Add all custom tools to the toolbar
            addAllToolsToToolbar();
            
        }, 2000);
        
        console.log(' Print overlay system initialized successfully!');

        // Handle window resize events for responsiveness
        window.addEventListener('resize', function() {
            viewer.resize();
        }, false);

        // Disable right-click context menu over the viewer
        viewer.cesiumWidget.canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        }, false);
        
        // Add additional rotation input handlers for immediate north arrow response
        const canvas = viewer.canvas;
        let isRotating = false;
        
        // Mouse down to detect start of rotation
        canvas.addEventListener('mousedown', function(e) {
            if (e.button === 2 || e.ctrlKey) { // Right click or Ctrl+click
                isRotating = true;
            }
        });
        
        // Mouse move during rotation
        canvas.addEventListener('mousemove', function(e) {
            if (isRotating) {
                // Immediate north arrow update during rotation
                setTimeout(updateNorthArrow, 0);
            }
        });
        
        // Mouse up to end rotation
        canvas.addEventListener('mouseup', function(e) {
            isRotating = false;
        });

        // Hide credit container for cleaner look
        viewer.cesiumWidget.creditContainer.style.display = "none";


        
        // Add search elements
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const suggestionsDropdown = document.getElementById('suggestionsDropdown');
        
        // Add layer control elements
        const baseLayerToggle = document.getElementById('baseLayerToggle');
        
        // Add drag and drop elements
        const dragDropOverlay = document.getElementById('dragDropOverlay');
        const modelFileInput = document.getElementById('modelFileInput');
        const modelUploadButton = document.getElementById('modelUploadButton');
        
        // Add scale bar and coordinate display elements
        const bottomLeftPanel = document.getElementById('bottomLeftPanel');
        const scaleBar = document.getElementById('scaleBar');
        const scaleLine = document.getElementById('scaleLine');
        const scaleText = document.getElementById('scaleText');
        const coordinatesInfo = document.getElementById('coordinatesInfo');
        
        // Autocomplete state
        let searchTimeout;
        let currentSuggestions = [];
        let selectedSuggestionIndex = -1;



        // Function to check if input is coordinates
        function isCoordinates(input) {
            const coordPattern = /^-?\d+\.?\d*,\s*-?\d+\.?\d*$|^-?\d+\.?\d*\s+-?\d+\.?\d*$/;
            return coordPattern.test(input.trim());
        }

        // Function to parse coordinates from input
        function parseCoordinates(input) {
            const cleaned = input.trim().replace(/,/, ' ');
            const parts = cleaned.split(/\s+/);
            if (parts.length === 2) {
                const lat = parseFloat(parts[0]);
                const lon = parseFloat(parts[1]);
                if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    return { lat, lon };
                }
            }
            return null;
        }

        // Function to get autocomplete suggestions
        async function getAutocompleteSuggestions(query) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&addressdetails=1&limit=5`);
                const data = await response.json();
                return data.map(item => ({
                    lat: parseFloat(item.lat),
                    lon: parseFloat(item.lon),
                    name: item.name || item.display_name.split(',')[0],
                    displayName: item.display_name,
                    type: item.type,
                    address: item.address
                }));
            } catch (error) {
                console.error('Autocomplete error:', error);
                return [];
            }
        }

        // Function to geocode using Nominatim API
        async function geocodeLocation(query) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon),
                        displayName: data[0].display_name
                    };
                }
                return null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        // Function to fly to coordinates with vertical view
        function flyToLocation(lat, lon, altitude = 2000) {
            const destination = Cesium.Cartesian3.fromDegrees(lon, lat, altitude);
            
            viewer.camera.flyTo({
                destination: destination,
                orientation: {
                    heading: Cesium.Math.toRadians(0), // North direction
                    pitch: Cesium.Math.toRadians(-90), // Vertical (straight down) view
                    roll: 0.0
                },
                duration: 2.0
            });
        }

        // Universal search functionality
        async function performSearch(queryOverride = null) {
            const topSearchInput = document.getElementById('topSearchInput');
            const query = queryOverride || (topSearchInput ? topSearchInput.value.trim() : '');
            if (!query) return;

            // Show loading spinner
            const spinner = document.getElementById('topLoadingSpinner');
            const button = document.getElementById('topSearchButton');
            
            if (spinner) spinner.style.display = 'block';
            if (button) button.disabled = true;

            try {
                // Check if input is coordinates
                const coords = parseCoordinates(query);
                if (coords) {
                    flyToLocation(coords.lat, coords.lon);
                    searchInput.value = '';
                } else {
                    // Geocode the location
                    const result = await geocodeLocation(query);
                    if (result) {
                        flyToLocation(result.lat, result.lon);
                        const topSearchInput = document.getElementById('topSearchInput');
                        if (topSearchInput) topSearchInput.value = '';
                        hideSuggestions();
                    } else {
                        alert('Location not found. Please try a different search term.');
                    }
                }
            } catch (error) {
                alert('Search failed. Please check your internet connection and try again.');
            } finally {
                // Hide loading spinner
                if (spinner) spinner.style.display = 'none';
                if (button) button.disabled = false;
            }
        }

        // Function to display suggestions
        function displaySuggestions(suggestions) {
            currentSuggestions = suggestions;
            selectedSuggestionIndex = -1;
            
            if (suggestions.length === 0) {
                hideSuggestions();
                return;
            }
            
            const dropdown = document.getElementById('topSuggestionsDropdown');
            const html = suggestions.map((suggestion, index) => {
                const name = suggestion.name || 'Unknown';
                const details = formatSuggestionDetails(suggestion);
                return `
                    <div class="top-suggestion-item" data-index="${index}">
                        <div class="suggestion-name">${escapeHtml(name)}</div>
                        <div class="suggestion-details">${escapeHtml(details)}</div>
                    </div>
                `;
            }).join('');
            
            dropdown.innerHTML = html;
            dropdown.style.display = 'block';
            
            // Add click event listeners to suggestions
            dropdown.querySelectorAll('.top-suggestion-item').forEach((item, index) => {
                item.addEventListener('click', () => selectSuggestion(index));
            });
        }

        // Function to format suggestion details
        function formatSuggestionDetails(suggestion) {
            const parts = [];
            if (suggestion.address) {
                if (suggestion.address.city) parts.push(suggestion.address.city);
                if (suggestion.address.state) parts.push(suggestion.address.state);
                if (suggestion.address.country) parts.push(suggestion.address.country);
            }
            return parts.length > 0 ? parts.join(', ') : suggestion.displayName;
        }

        // Function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Function to hide suggestions
        function hideSuggestions() {
            const dropdown = document.getElementById('topSuggestionsDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
            currentSuggestions = [];
            selectedSuggestionIndex = -1;
        }

        // Function to select a suggestion
        function selectSuggestion(index) {
            if (index >= 0 && index < currentSuggestions.length) {
                const suggestion = currentSuggestions[index];
                flyToLocation(suggestion.lat, suggestion.lon);
                const topSearchInput = document.getElementById('topSearchInput');
                if (topSearchInput) topSearchInput.value = '';
                hideSuggestions();
            }
        }

        // Function to highlight selected suggestion
        function updateSelectedSuggestion() {
            const dropdown = document.getElementById('topSuggestionsDropdown');
            if (dropdown) {
                dropdown.querySelectorAll('.top-suggestion-item').forEach((item, index) => {
                    if (index === selectedSuggestionIndex) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            }
        }

        // Debounced autocomplete function
        function handleInputChange() {
            const query = searchInput.value.trim();
            
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            // Hide suggestions if input is empty
            if (!query) {
                hideSuggestions();
                return;
            }
            
            // Don't autocomplete if input looks like coordinates
            if (isCoordinates(query)) {
                hideSuggestions();
                return;
            }
            
            // Set new timeout for autocomplete
            searchTimeout = setTimeout(async () => {
                try {
                    const suggestions = await getAutocompleteSuggestions(query);
                    displaySuggestions(suggestions);
                } catch (error) {
                    console.error('Autocomplete failed:', error);
                    hideSuggestions();
                }
            }, 300); // 300ms debounce
        }

        // Add top search event listeners
        const topSearchInput = document.getElementById('topSearchInput');
        const topLoadingSpinner = document.getElementById('topLoadingSpinner');
        const topSuggestionsDropdown = document.getElementById('topSuggestionsDropdown');
        
        if (topSearchInput) {
            topSearchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    performSearch(topSearchInput.value.trim());
                }
            });
        }
        
        // Handle input changes with debouncing for top search
        function handleTopInputChange() {
            const topSearchInput = document.getElementById('topSearchInput');
            const query = topSearchInput.value.trim();
            
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            if (query.length < 2) {
                hideSuggestions();
                return;
            }
            
            // Don't autocomplete if input looks like coordinates
            if (isCoordinates(query)) {
                hideSuggestions();
                return;
            }
            
            // Set new timeout for debouncing
            searchTimeout = setTimeout(async () => {
                try {
                    const suggestions = await getAutocompleteSuggestions(query);
                    displaySuggestions(suggestions);
                } catch (error) {
                    console.error('Autocomplete failed:', error);
                    hideSuggestions();
                }
            }, 300); // 300ms debounce
        }

        // Enhanced input event listeners for top search
        if (topSearchInput) {
            topSearchInput.addEventListener('input', handleTopInputChange);
        }
        
        if (topSearchInput) {
            topSearchInput.addEventListener('keydown', function(e) {
                if (topSuggestionsDropdown.style.display === 'block' && currentSuggestions.length > 0) {
                    switch (e.key) {
                        case 'ArrowDown':
                            e.preventDefault();
                            selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, currentSuggestions.length - 1);
                            updateSelectedSuggestion();
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                            updateSelectedSuggestion();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            if (selectedSuggestionIndex >= 0) {
                                selectSuggestion(selectedSuggestionIndex);
                            } else {
                                performSearch();
                            }
                            break;
                        case 'Escape':
                            hideSuggestions();
                            break;
                    }
                } else if (e.key === 'Enter') {
                    performSearch();
                }
            });
        }

        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.top-search-container')) {
                hideSuggestions();
            }
        });

        // Toggle help menu
        function toggleHelpMenu() {
            const helpInfo = `My Earth - 3D Globe Viewer

CONTROLS:
 Mouse: Click and drag to rotate
 Scroll: Zoom in/out
 Right-click: Pan view
 Double-click: Zoom to location

SEARCH:
 Enter location names or coordinates
 Autocomplete suggestions provided
 Press Enter to search

TOOLS:
 North Arrow: Reset to north orientation
 Home: Return to default view
 Zoom In/Out: Precise zoom control
 Search: Find locations worldwide
 Measurement: Measure distances and areas
 Markers: Place point markers
 Models: Load 3D models
 Layers: Manage map layers
 Capture: Take screenshots
 Fullscreen: Toggle fullscreen view
 Settings: Customize appearance
 Print: Print current view

SUPPORT:
                <!-- Email removed -->

Version: 1.0
Built with CesiumJS`;
            
            alert(helpInfo);
        }

        /**
         * Live Coordinates Tracking System
         * 
         * Implements real-time coordinate display that shows latitude, longitude,
         * and height of terrain under the mouse cursor. Uses Cesium's camera ray
         * casting to determine precise geographic coordinates.
         */

        // Coordinate tracking handler with throttling for performance
        let coordinateUpdateThrottle = null;
        const COORDINATE_UPDATE_INTERVAL = 50; // Update every 50ms for smooth tracking

        /**
         * Calculates and updates the scale bar based on current map view
         * Uses geodesic distance calculation for accurate metric representation
         */
        function updateScaleBar() {
            try {
                const canvas = viewer.canvas;
                const ellipsoid = viewer.scene.globe.ellipsoid;
                
                // Get canvas dimensions
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                // Define two points on screen separated by 100 pixels
                const left = new Cesium.Cartesian2((width / 2) - 50, height / 2);
                const right = new Cesium.Cartesian2((width / 2) + 50, height / 2);
                
                // Pick ellipsoid positions for both points
                const leftPosition = viewer.camera.pickEllipsoid(left, ellipsoid);
                const rightPosition = viewer.camera.pickEllipsoid(right, ellipsoid);
                
                let pixelDistance;
                
                if (leftPosition && rightPosition) {
                    // Low altitude - use precise ellipsoid picking
                    const leftCartographic = ellipsoid.cartesianToCartographic(leftPosition);
                    const rightCartographic = ellipsoid.cartesianToCartographic(rightPosition);
                    
                    // Calculate geodesic distance between the two points
                    const geodesic = new Cesium.EllipsoidGeodesic(leftCartographic, rightCartographic);
                    pixelDistance = geodesic.surfaceDistance; // Distance in meters for 100 pixels
                } else {
                    // High altitude - calculate scale based on camera height and perspective
                    const cameraPosition = viewer.camera.position;
                    const cameraCartographic = ellipsoid.cartesianToCartographic(cameraPosition);
                    const cameraHeight = cameraCartographic.height;
                    
                    // Use camera's field of view and height to estimate ground distance per pixel
                    const camera = viewer.camera;
                    const frustum = camera.frustum;
                    
                    // Calculate the angular width of 100 pixels at screen center
                    const fovRadians = frustum.fov || (Math.PI / 3); // Default 60 degrees if undefined
                    const pixelAngle = fovRadians / canvas.clientHeight * 100; // 100 pixels worth of angle
                    
                    // At high altitude, approximate ground distance using camera height and angle
                    pixelDistance = 2 * cameraHeight * Math.tan(pixelAngle / 2);
                    
                    // Ensure reasonable bounds for very high altitudes
                    if (pixelDistance > 50000000) { // 50,000 km limit
                        pixelDistance = 50000000;
                    }
                }
                
                // Determine appropriate scale values
                let targetDistance, scaleWidth, scaleLabel;
                
                if (pixelDistance >= 1000000) {
                    // For very large scales (>1000km), use nice round values
                    const scaleOptions = [1000000, 2000000, 5000000, 10000000, 20000000, 50000000]; // 1000km, 2000km, 5000km, etc.
                    
                    // Find the largest scale option that's smaller than pixelDistance
                    targetDistance = 1000000; // Default fallback
                    for (let i = scaleOptions.length - 1; i >= 0; i--) {
                        if (scaleOptions[i] <= pixelDistance) {
                            targetDistance = scaleOptions[i];
                            break;
                        }
                    }
                    
                    // If pixelDistance is larger than our largest option, use the largest
                    if (pixelDistance > 50000000) {
                        targetDistance = 50000000;
                    }
                    
                    // Format the label appropriately
                    const kmValue = targetDistance / 1000;
                    if (kmValue >= 1000) {
                        scaleLabel = `${(kmValue/1000).toFixed(0)},000 km`;
                    } else {
                        scaleLabel = `${kmValue.toFixed(0)} km`;
                    }
                } else if (pixelDistance >= 100000) {
                    // For large scales, use 100km intervals
                    targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                    if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                    else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                    scaleLabel = (targetDistance / 1000) + ' km';
                } else if (pixelDistance >= 1000) {
                    // For medium scales, use km
                    targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                    if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                    else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                    scaleLabel = (targetDistance >= 1000) ? (targetDistance / 1000) + ' km' : targetDistance + ' m';
                } else {
                    // For small scales, use meters
                    targetDistance = Math.pow(10, Math.floor(Math.log10(pixelDistance)));
                    if (targetDistance * 5 <= pixelDistance) targetDistance *= 5;
                    else if (targetDistance * 2 <= pixelDistance) targetDistance *= 2;
                    scaleLabel = targetDistance + ' m';
                }
                
                // Calculate the width in pixels for our target distance
                scaleWidth = (targetDistance / pixelDistance) * 100;
                
                // Update the scale bar if elements exist
                if (scaleLine && scaleText) {
                    scaleLine.style.width = Math.max(Math.min(scaleWidth, 200), 30) + 'px';
                    scaleText.textContent = scaleLabel;
                }
                
            } catch (error) {
                console.warn('Scale bar calculation failed:', error);
                // Still try to show something useful based on camera height
                try {
                    const cameraPosition = viewer.camera.position;
                    const cameraCartographic = viewer.scene.globe.ellipsoid.cartesianToCartographic(cameraPosition);
                    const cameraHeight = cameraCartographic.height;
                    
                    let fallbackScale, fallbackLabel;
                    if (cameraHeight > 50000000) { // 50,000 km
                        fallbackScale = '50,000 km';
                    } else if (cameraHeight > 20000000) { // 20,000 km  
                        fallbackScale = '20,000 km';
                    } else if (cameraHeight > 10000000) { // 10,000 km
                        fallbackScale = '10,000 km';
                    } else if (cameraHeight > 5000000) { // 5,000 km
                        fallbackScale = '5,000 km';
                    } else if (cameraHeight > 2000000) { // 2,000 km
                        fallbackScale = '2,000 km';
                    } else {
                        fallbackScale = '1,000 km';
                    }
                    
                    if (scaleLine && scaleText) {
                        scaleLine.style.width = '100px';
                        scaleText.textContent = fallbackScale;
                    }
                } catch (fallbackError) {
                    if (scaleLine && scaleText) {
                        scaleLine.style.width = '60px';
                        scaleText.textContent = '1 km';
                    }
                }
            }
        }

        /**
         * Updates coordinate display with formatted values in WGS84 degrees
         * @param {number} latitude - Latitude in degrees
         * @param {number} longitude - Longitude in degrees  
         */
        function updateCoordinateDisplay(latitude, longitude) {
            try {
                // Compact coordinates display removed
                
                // Update coordinates in bottom band with cm precision
                const coordinatesInfo = document.getElementById('coordinatesInfo');
                if (coordinatesInfo) {
                    coordinatesInfo.textContent = `N: ${latitude.toFixed(8)} E: ${longitude.toFixed(8)}`;
                }
                
            } catch (error) {
                console.warn('Error updating coordinate display:', error);
            }
        }

        /**
         * Clears coordinate display when mouse is not over terrain
         */
        function clearCoordinateDisplay() {
            try {
                // Compact coordinates display removed
                
                // Clear coordinates in bottom panel
                const coordinatesInfo = document.getElementById('coordinatesInfo');
                if (coordinatesInfo) {
                    coordinatesInfo.textContent = 'Lat: ---.------ Lon: ---.------';
                }
                
            } catch (error) {
                console.warn('Error clearing coordinate display:', error);
            }
        }

        /**
         * Updates the north arrow rotation to always point to geographic north
         * Arrow compensates for camera rotation to maintain north orientation
         */
        function updateNorthArrow() {
            try {
                // Check if north arrow tool exists in the right panel
                const northArrowTool = document.getElementById('northArrow');
                if (!northArrowTool) {
                    return;
                }
                
                // Get the camera's current heading (rotation around the up axis)
                const heading = viewer.camera.heading;
                
                // Convert heading from radians to degrees and normalize to 0-360
                let headingDegrees = Cesium.Math.toDegrees(heading);
                headingDegrees = ((headingDegrees % 360) + 360) % 360;
                
                // Rotate the north arrow to compensate for camera rotation
                // Negative rotation because we want the arrow to point north regardless of camera heading
                const rotation = -headingDegrees;
                
                // Apply rotation transform to the north arrow in the right panel
                const northArrowElement = document.getElementById('northArrow');
                if (northArrowElement) {
                    const svg = northArrowElement.querySelector('svg');
                    if (svg) {
                        svg.style.transform = `rotate(${rotation}deg)`;
                    }
                }
                
            } catch (error) {
                console.warn('North arrow update failed:', error);
                // Reset to default orientation on error
                const northArrowElement = document.getElementById('northArrow');
                if (northArrowElement) {
                    const svg = northArrowElement.querySelector('svg');
                    if (svg) {
                        svg.style.transform = 'rotate(0deg)';
                    }
                }
            }
        }

        /**
         * Updates coordinates to show center of camera view
         * Uses camera position and center screen ray casting
         */
        function updateCenterCoordinates() {
            try {
                // Get center of screen coordinates
                const canvas = viewer.canvas;
                const centerX = canvas.clientWidth / 2;
                const centerY = canvas.clientHeight / 2;
                const centerPick = new Cesium.Cartesian2(centerX, centerY);
                
                // Cast ray from camera through center of screen
                const ray = viewer.camera.getPickRay(centerPick);
                let intersection = viewer.scene.globe.pick(ray, viewer.scene);
                
                // Fallback to ellipsoid intersection if no terrain intersection
                if (!intersection) {
                    const ellipsoidIntersection = Cesium.IntersectionTests.rayEllipsoid(ray, viewer.scene.globe.ellipsoid);
                    if (ellipsoidIntersection) {
                        intersection = Cesium.Ray.getPoint(ray, ellipsoidIntersection.start);
                    }
                }
                
                if (intersection) {
                    // Convert to geographic coordinates
                    const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    
                    updateCoordinateDisplay(latitude, longitude);
                } else {
                    clearCoordinateDisplay();
                }
                
            } catch (error) {
                console.warn('Center coordinate tracking error:', error);
                clearCoordinateDisplay();
            }
        }

        /**
         * Initialize coordinate tracking, scale bar, and north arrow systems
         * Attaches mouse move listener and camera change handlers
         */
        function initializeCoordinateTracking() {
            // Add camera change listeners for scale bar, north arrow, and center coordinates
            viewer.camera.changed.addEventListener(function() {
                updateScaleBar();
                if (typeof updateNorthArrow === 'function') {
                    updateNorthArrow();
                }
                updateCenterCoordinates();
                updateBottomBand();
            });
            
            // Add camera move events for more responsive updates
            viewer.camera.moveStart.addEventListener(function() {
                updateNorthArrow();
            });
            
            viewer.camera.moveEnd.addEventListener(function() {
                updateScaleBar();
                updateNorthArrow();
                updateCenterCoordinates();
            });
            
            // Add scene post-render event for continuous updates during any camera changes
            let lastHeading = viewer.camera.heading;
            viewer.scene.postRender.addEventListener(function() {
                // Check if heading has changed to update north arrow
                const currentHeading = viewer.camera.heading;
                if (Math.abs(currentHeading - lastHeading) > 0.001) {
                    updateNorthArrow();
                    lastHeading = currentHeading;
                }
            });
            
            viewer.scene.morphComplete.addEventListener(function() {
                updateScaleBar();
                updateNorthArrow();
                updateCenterCoordinates();
            });
            
            // Initial updates
            updateScaleBar();
            updateNorthArrow();
            updateCenterCoordinates();
            
            console.log('Center coordinate tracking, scale bar, and north arrow initialized');
        }

        /**
         * Toggles the base map layer visibility
         * @param {boolean} visible - Whether to show or hide the base layer
         */
        function toggleBaseLayer(visible) {
            try {
                if (viewer.imageryLayers.length > 0) {
                    const baseLayer = viewer.imageryLayers.get(0);
                    baseLayer.show = visible;
                    console.log(`Base layer ${visible ? 'enabled' : 'disabled'}`);
                }
            } catch (error) {
                console.warn('Error toggling base layer:', error);
            }
        }

        /**
         * Initialize layer controls
         */
        function initializeLayerControls() {
            // Base layer toggle functionality
            baseLayerToggle.addEventListener('change', function() {
                toggleBaseLayer(this.checked);
            });
            
            // Model upload button functionality
            modelUploadButton.addEventListener('click', function() {
                modelFileInput.click();
            });
            
            console.log('Layer controls initialized');
        }

        /**
         * Check if file format is a recognized 3D model format
         * @param {string} filename - The filename to check
         * @returns {object} - Object with format info and support status
         */
        function check3DFileFormat(filename) {
            const extension = filename.toLowerCase().split('.').pop();
            
            const supportedFormats = {
                'glb': { name: 'GLTF Binary', supported: true, description: 'Optimized for web display' },
                'gltf': { name: 'GLTF JSON', supported: true, description: 'Standard web 3D format' }
            };
            
            const unsupportedFormats = {
                'obj': { name: 'Wavefront OBJ', supported: false, description: 'Legacy 3D mesh format' },
                'fbx': { name: 'Autodesk FBX', supported: false, description: 'Animation-rich format' },
                'dae': { name: 'COLLADA', supported: false, description: 'XML-based 3D format' },
                'stl': { name: 'Stereolithography', supported: false, description: '3D printing format' },
                'ply': { name: 'Polygon File Format', supported: false, description: 'Point cloud/mesh format' },
                'las': { name: 'LAS Point Cloud', supported: false, description: 'LiDAR data format' },
                'dxf': { name: 'AutoCAD DXF', supported: false, description: 'CAD drawing format' },
                'usdz': { name: 'Universal Scene Description', supported: false, description: 'Apple AR format' }
            };
            
            if (supportedFormats[extension]) {
                return { ...supportedFormats[extension], extension, isKnown3D: true };
            } else if (unsupportedFormats[extension]) {
                return { ...unsupportedFormats[extension], extension, isKnown3D: true };
            } else {
                return { name: 'Unknown', supported: false, extension, isKnown3D: false };
            }
        }

        /**
         * Show format compatibility warning for unsupported 3D files
         * @param {object} formatInfo - Format information object
         * @param {string} filename - The filename
         */
        function showFormatWarning(formatInfo, filename) {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 152, 0, 0.95);
                color: white;
                padding: 25px;
                border-radius: 12px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                max-width: 450px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            
            warningDiv.innerHTML = `
                <h3 style="margin: 0 0 15px 0;">Format Not Supported in Browser</h3>
                <div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <strong>${formatInfo.name} (.${formatInfo.extension})</strong><br>
                    <span style="font-size: 13px;">${formatInfo.description}</span>
                </div>
                <p style="margin-bottom: 20px; font-size: 14px;">
                    This file format is not supported in the browser. Please convert to <strong>.glb</strong> or <strong>3D Tiles</strong> before importing.
                </p>
                <div style="text-align: left; background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 20px;">
                    <strong>Recommended Converters:</strong>
                    <ul style="font-size: 13px; margin-top: 8px; line-height: 1.6;">
                        <li><strong>Blender</strong> - Free, supports most formats  GLB export</li>
                        <li><strong>FBX2glTF</strong> - Facebook's official FBX converter</li>
                        <li><strong>obj2gltf</strong> - Command line OBJ to GLTF converter</li>
                        <li><strong>Online converters</strong> - Search "convert ${formatInfo.extension} to glb"</li>
                    </ul>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="this.parentElement.parentElement.remove()" style="background: white; color: #333; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">OK</button>
                    <button onclick="showModelAlternatives(); this.parentElement.parentElement.remove();" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Get Help</button>
                </div>
            `;
            
            document.body.appendChild(warningDiv);
        }

        /**
         * Validate file format (universal 3D model support)
         * @param {File} file - The file to validate
         * @returns {object} - Validation result with isValid and message
         */
        function validateFileFormat(file) {
            const fileName = file.name.toLowerCase();
            const universalFormats = [
                // Cesium 3D Tiles
                '.json', '.cmpt', '.b3dm', '.i3dm', '.pnts',
                // glTF formats
                '.glb', '.gltf',
                // Traditional 3D formats
                '.obj', '.fbx', '.dae', '.3ds', '.blend', '.stl', '.ply', '.max', '.ma', '.mb',
                // Point cloud formats
                '.las', '.laz',
                // Gaussian Splatting
                '.splat',
                // Geospatial formats
                '.kml', '.kmz', '.citygml', '.gml',
                // Archive formats
                '.zip', '.7z', '.rar',
                // Image formats for photogrammetry
                '.jpg', '.jpeg', '.png', '.tiff', '.tif',
                // BIM formats
                '.ifc', '.rvt', '.dwg'
            ];
            
            const isValid = universalFormats.some(format => fileName.endsWith(format));
            
            if (!isValid) {
                return {
                    isValid: false,
                    message: `Unsupported format. We support 30+ formats including 3D Tiles, glTF, OBJ, FBX, LAS, KML, and more. We'll try to process your file automatically.`
                };
            }
            
            return { isValid: true, message: null };
        }

        /**
         * Validate file size (increased to 500MB for large models)
         * @param {File} file - The file to validate
         * @returns {object} - Validation result with isValid and message
         */
        function validateFileSize(file) {
            const maxSize = 500 * 1024 * 1024; // 500MB in bytes
            const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
            
            if (file.size > maxSize) {
                return {
                    isValid: false,
                    message: `This model (${fileSizeMB}MB) exceeds the 500MB limit. Please reduce the file size or simplify the model.`,
                    size: fileSizeMB
                };
            }
            
            return { isValid: true, message: null };
        }

        /**
         * Validate GLB/GLTF file format integrity
         * @param {File} file - The file to validate
         * @returns {Promise<object>} - Validation result with isValid and message
         */
        async function validateModelFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    const dataView = new DataView(arrayBuffer);
                    
                    try {
                        // Check GLB magic number (first 4 bytes should be "glTF")
                        if (file.name.toLowerCase().endsWith('.glb')) {
                            const magic = dataView.getUint32(0, true);
                            const glTFMagic = 0x46546C67; // "glTF" in little-endian
                            const isValid = magic === glTFMagic;
                            resolve({
                                isValid,
                                message: isValid ? null : "Invalid GLB file format. File may be corrupted or not a valid GLB."
                            });
                        } else if (file.name.toLowerCase().endsWith('.gltf')) {
                            // For GLTF JSON files, try to parse as JSON
                            const text = new TextDecoder().decode(arrayBuffer);
                            const json = JSON.parse(text);
                            const isValid = json.asset && json.asset.version;
                            resolve({
                                isValid,
                                message: isValid ? null : "Invalid GLTF file format. Missing required asset information."
                            });
                        } else {
                            resolve({
                                isValid: false,
                                message: "Unsupported file format."
                            });
                        }
                    } catch (error) {
                        console.warn('File validation error:', error);
                        resolve({
                            isValid: false,
                            message: "Could not read file. File may be corrupted."
                        });
                    }
                };
                reader.onerror = () => resolve({
                    isValid: false,
                    message: "Error reading file."
                });
                reader.readAsArrayBuffer(file.slice(0, 1024)); // Read first 1KB for validation
            });
        }

        /**
         * Show error modal with consistent styling
         * @param {string} title - Modal title
         * @param {string} message - Main message
         * @param {Array} buttons - Array of button objects {text, action, style}
         */
        function showErrorModal(title, message, buttons = null) {
            // Remove any existing modals
            const existingModals = document.querySelectorAll('.error-modal');
            existingModals.forEach(modal => modal.remove());
            
            const modal = document.createElement('div');
            modal.className = 'error-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: Arial, sans-serif;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 480px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                position: relative;
                animation: modalSlideIn 0.3s ease-out;
            `;
            
            // Add animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes modalSlideIn {
                    from { transform: translateY(-20px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            modalContent.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 16px;">
                    <span style="font-size: 24px; margin-right: 12px;">${title.includes('') ? title : ' ' + title}</span>
                </div>
                <div style="color: #333; line-height: 1.6; margin-bottom: 24px;">
                    ${message}
                </div>
                <div id="modalButtons" style="display: flex; gap: 12px; justify-content: flex-end;"></div>
            `;
            
            const buttonsContainer = modalContent.querySelector('#modalButtons');
            
            // Default buttons if none provided
            if (!buttons) {
                buttons = [
                    { text: 'Got It', action: () => modal.remove(), style: 'primary' }
                ];
            }
            
            buttons.forEach(button => {
                const btn = document.createElement('button');
                btn.textContent = button.text;
                btn.onclick = button.action;
                
                const baseStyle = `
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: all 0.2s ease;
                `;
                
                if (button.style === 'primary') {
                    btn.style.cssText = baseStyle + `
                        background: #007bff;
                        color: white;
                    `;
                    btn.onmouseover = () => btn.style.background = '#0056b3';
                    btn.onmouseout = () => btn.style.background = '#007bff';
                } else {
                    btn.style.cssText = baseStyle + `
                        background: #f8f9fa;
                        color: #333;
                        border: 1px solid #dee2e6;
                    `;
                    btn.onmouseover = () => btn.style.background = '#e9ecef';
                    btn.onmouseout = () => btn.style.background = '#f8f9fa';
                }
                
                buttonsContainer.appendChild(btn);
            });
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close on overlay click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            
            // Close on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        /**
         * Global Keyboard Shortcuts System
         * Provides convenient hotkeys for common actions
         */
        function initializeKeyboardShortcuts() {
            document.addEventListener('keydown', (event) => {
                // Don't trigger shortcuts when typing in inputs
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable) {
                    return;
                }
                
                // Don't trigger if any modifier keys are pressed (except for specific combos)
                const hasModifier = event.ctrlKey || event.metaKey || event.altKey;
                
                switch (event.key.toLowerCase()) {
                    case 'escape':
                        // Close search bar if open
                        const searchContainer = document.querySelector('.top-search-container');
                        if (searchContainer && searchContainer.classList.contains('active')) {
                            event.preventDefault();
                            searchContainer.classList.remove('active');
                            const searchTool = document.getElementById('searchTool');
                            if (searchTool) searchTool.classList.remove('active');
                            console.log(' Search bar closed with Escape');
                            return;
                        }
                        
                        // Close any open panels or modals
                        event.preventDefault();
                        closeAllPanels();
                        showMessage('Panels closed', 'info');
                        break;
                        
                    case ' ': // Spacebar
                        // Reset camera to home view
                        event.preventDefault();
                        resetToHomeView();
                        showMessage('Camera reset to home', 'info');
                        break;
                        
                    case 'h':
                        // Toggle help/info
                        event.preventDefault();
                        toggleHelpMenu();
                        break;
                        
                    case 'f':
                        // Toggle fullscreen
                        if (!hasModifier) {
                            event.preventDefault();
                            toggleFullscreen();
                        }
                        break;
                        
                    case 'l':
                        // Toggle layers panel
                        event.preventDefault();
                        toggleLayersPanel();
                        showMessage('Layers panel toggled', 'info');
                        break;
                        
                    case 'm':
                        // Toggle measurement tool
                        event.preventDefault();
                        toggleMeasurementTool();
                        break;
                        
                    case 'p':
                        // Toggle print mode
                        if (!hasModifier) {
                            event.preventDefault();
                            if (window.printOverlay) {
                                window.printOverlay.toggle();
                            }
                        }
                        break;
                        
                    case 'g':
                        // Toggle gizmo (if available)
                        event.preventDefault();
                        if (window.toggleGizmo) {
                            window.toggleGizmo();
                        }
                        break;
                        
                    case 'n':
                        // Reset camera to north
                        event.preventDefault();
                        resetCameraToNorth();
                        showMessage('Camera oriented to north', 'info');
                        break;
                        
                    case '+':
                    case '=':
                        // Zoom in
                        event.preventDefault();
                        zoomIn();
                        break;
                        
                    case '-':
                        // Zoom out
                        event.preventDefault();
                        zoomOut();
                        break;
                        
                    case 't':
                        // Toggle 3D/2D view mode
                        event.preventDefault();
                        toggle3DMode();
                        break;
                        
                    case 'c':
                        // Toggle coordinates display
                        event.preventDefault();
                        toggleCoordinatesDisplay();
                        break;
                        
                    case '?':
                        // Show keyboard shortcuts help
                        event.preventDefault();
                        showKeyboardShortcutsHelp();
                        break;
                }
            });
            
            console.log(' Keyboard shortcuts initialized');
        }

        /**
         * Close all open panels and overlays
         */
        function closeAllPanels() {
            // Close measurement panel
            const measurementControls = document.getElementById('measurementControls');
            if (measurementControls && measurementControls.style.display === 'block') {
                toggleMeasurementTool();
            }
            
            // Close marker panel
            const markerControls = document.getElementById('markerControls');
            if (markerControls && markerControls.style.display === 'block') {
                toggleMarkerPanel();
            }
            
            // Close layers panel
            const sidebar = document.querySelector('.sidebar');
            if (sidebar && sidebar.classList.contains('active')) {
                toggleLayersPanel();
            }
            
            // Close print overlay
            if (window.printOverlay && window.printOverlay.isActive) {
                window.printOverlay.hide();
            }
            
            // Close any modals
            const modals = document.querySelectorAll('.error-modal, .success-modal');
            modals.forEach(modal => modal.remove());
        }

        /**
         * Reset camera to home view (Europe)
         */
        function resetToHomeView() {
            const europeHomeView = {
                destination: Cesium.Cartesian3.fromDegrees(10.0, 40.0, 8000000.0),
                orientation: {
                    heading: Cesium.Math.toRadians(0),
                    pitch: Cesium.Math.toRadians(-90),
                    roll: 0.0
                }
            };
            viewer.camera.setView(europeHomeView);
        }

        /**
         * Reset camera orientation to north
         */
        function resetCameraToNorth() {
            const currentPosition = viewer.camera.position;
            const cartographic = Cesium.Cartographic.fromCartesian(currentPosition);
            
            viewer.camera.setView({
                destination: currentPosition,
                orientation: {
                    heading: Cesium.Math.toRadians(0), // North
                    pitch: viewer.camera.pitch, // Keep current pitch
                    roll: 0.0
                }
            });
        }

        /**
         * Toggle 3D/2D view mode
         */
        function toggle3DMode() {
            const currentMode = viewer.scene.mode;
            
            if (currentMode === Cesium.SceneMode.SCENE3D) {
                viewer.scene.mode = Cesium.SceneMode.SCENE2D;
                showMessage('Switched to 2D mode', 'info');
            } else {
                viewer.scene.mode = Cesium.SceneMode.SCENE3D;
                showMessage('Switched to 3D mode', 'info');
            }
        }

        /**
         * Toggle coordinates display
         */
        function toggleCoordinatesDisplay() {
            const coordinatesInfo = document.getElementById('coordinatesInfo');
            if (coordinatesInfo) {
                const isHidden = coordinatesInfo.style.display === 'none';
                coordinatesInfo.style.display = isHidden ? 'block' : 'none';
                showMessage(`Coordinates display ${isHidden ? 'enabled' : 'disabled'}`, 'info');
            }
        }

        /**
         * Show keyboard shortcuts help dialog
         */
        function showKeyboardShortcutsHelp() {
            const shortcuts = `
 MyEarth Keyboard Shortcuts

NAVIGATION:
 Space - Reset camera to home view
 N - Orient camera to north
 + / = - Zoom in
 - - Zoom out
 T - Toggle 2D/3D mode

TOOLS:
 L - Toggle layers panel
 M - Toggle measurement tool
 P - Toggle print mode
 G - Toggle 3D gizmo (if available)
 C - Toggle coordinates display

GENERAL:
 ESC - Close all panels
 F - Toggle fullscreen
 H - Show help information
 ? - Show this shortcuts guide

TIP: These shortcuts work when not typing in input fields.
            `;
            
            alert(shortcuts);
        }

        /**
         * Zoom in function
         */
        function zoomIn() {
            const camera = viewer.camera;
            const currentHeight = camera.positionCartographic.height;
            const newHeight = currentHeight * 0.7; // Zoom in by 30%
            
            const currentPosition = camera.position;
            const cartographic = Cesium.Cartographic.fromCartesian(currentPosition);
            
            const newPosition = Cesium.Cartesian3.fromRadians(
                cartographic.longitude,
                cartographic.latitude,
                newHeight
            );
            
            camera.setView({
                destination: newPosition,
                orientation: {
                    heading: camera.heading,
                    pitch: camera.pitch,
                    roll: camera.roll
                }
            });
        }

        /**
         * Zoom out function
         */
        function zoomOut() {
            const camera = viewer.camera;
            const currentHeight = camera.positionCartographic.height;
            const newHeight = currentHeight * 1.4; // Zoom out by 40%
            
            const currentPosition = camera.position;
            const cartographic = Cesium.Cartographic.fromCartesian(currentPosition);
            
            const newPosition = Cesium.Cartesian3.fromRadians(
                cartographic.longitude,
                cartographic.latitude,
                newHeight
            );
            
            camera.setView({
                destination: newPosition,
                orientation: {
                    heading: camera.heading,
                    pitch: camera.pitch,
                    roll: camera.roll
                }
            });
        }

        /**
         * Toggle fullscreen mode
         */
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                document.documentElement.requestFullscreen().then(() => {
                    showMessage('Entered fullscreen mode (Press F or ESC to exit)', 'info');
                }).catch(err => {
                    showMessage('Failed to enter fullscreen mode', 'error');
                    console.error('Fullscreen error:', err);
                });
            } else {
                // Exit fullscreen
                document.exitFullscreen().then(() => {
                    showMessage('Exited fullscreen mode', 'info');
                }).catch(err => {
                    showMessage('Failed to exit fullscreen mode', 'error');
                    console.error('Fullscreen exit error:', err);
                });
            }
        }

        // Initialize keyboard shortcuts after viewer is ready
        setTimeout(() => {
            initializeKeyboardShortcuts();
        }, 1000);

        /**
         * Show compatibility error modal with detailed guidance and multi-format support
         * @param {string} fileName - Name of the failed file
         */
        function showCompatibilityError(fileName) {
            const fileExt = fileName.split('.').pop().toLowerCase();
            const isConverted = fileName.includes('converted_');
            
            let formatSpecificTips = '';
            if (fileExt === 'obj') {
                formatSpecificTips = '<strong>For OBJ files:</strong> Try converting to GLB using Blender or online converters.';
            } else if (fileExt === 'fbx') {
                formatSpecificTips = '<strong>For FBX files:</strong> Export from your 3D software as GLB or simplify the model.';
            } else if (fileExt === 'dae') {
                formatSpecificTips = '<strong>For DAE files:</strong> Use Blender to import and re-export as GLB with simplified settings.';
            } else if (fileExt === 'stl') {
                formatSpecificTips = '<strong>For STL files:</strong> These are typically simple geometry and should work. Try reducing polygon count.';
            }
            
            const message = `
                <p>This 3D model (${fileName}) includes features that CesiumJS cannot render properly. Common issues include:</p>
                <ul style="margin: 12px 0; padding-left: 20px; color: #666;">
                    <li>Complex animations or rigging</li>
                    <li>Advanced shaders or materials</li>
                    <li>Unsupported glTF extensions</li>
                    <li>Too many polygons or vertices</li>
                    <li>Non-standard coordinate systems</li>
                    <li>Format-specific compatibility issues</li>
                </ul>
                <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 16px 0;">
                    <strong style="color: #007bff;"> Quick Fix Tips:</strong>
                    <div style="margin-top: 8px; font-size: 14px; color: #555;">
                        <strong>For Blender:</strong> Export as GLB with "Apply Modifiers" checked, disable animations, and use simple materials.<br>
                        <strong>For other software:</strong> Simplify the model, remove animations, and ensure it's under 50MB.<br>
                        ${formatSpecificTips}
                    </div>
                </div>
                <div style="background: #fff3cd; padding: 12px; border-radius: 6px; margin: 16px 0; border-left: 4px solid #ffc107;">
                    <strong>Note:</strong> The model was uploaded successfully${isConverted ? ' and converted to GLB' : ''}, but CesiumJS couldn't display it. A marker has been placed at the location.
                </div>
            `;
            
            const buttons = [
                {
                    text: 'Got It',
                    action: () => document.querySelector('.error-modal').remove(),
                    style: 'primary'
                },
                {
                    text: 'How to Fix',
                    action: () => {
                        showModelHelp();
                    },
                    style: 'secondary'
                }
            ];
            
            showErrorModal('Model Not Compatible', message, buttons);
        }

        /**
         * Show message function for user feedback
         */
        function showMessage(message, type = 'info') {
            // Disabled popup messages - do nothing
            return;
        }

        /**
         * Show processing success message
         */
        function showProcessingSuccess(uploadResult) {
            const { processing_type, message, original_format } = uploadResult;
            
            let icon = '';
            let color = '#4CAF50';
            
            if (processing_type.includes('fallback') || processing_type.includes('error')) {
                icon = '';
                color = '#ff9800';
            } else if (processing_type.includes('converted')) {
                icon = '';
                color = '#2196F3';
            }
            
            showMessage(`${icon} ${message}`, 'success');
        }

        /**
         * Load model based on processing type
         */
        async function loadModelByType(processingType, modelUrl, cesiumIonAssetId, filename, longitude, latitude, height) {
            try {
                switch (processingType) {
                    case '3d_tiles':
                    case 'point_cloud_3dtiles':
                    case 'gaussian_splats_3dtiles':
                    case 'geospatial_3dtiles':
                        await load3DTileset(modelUrl, filename, longitude, latitude, height);
                        break;
                        
                    case 'gltf':
                    case 'converted_gltf':
                        await loadGltfModel(modelUrl, filename, longitude, latitude, height);
                        break;
                        
                    case 'cesium_ion':
                        await loadCesiumIonAsset(cesiumIonAssetId, filename, longitude, latitude, height);
                        break;
                        
                    case 'point_cloud_raw':
                    case 'gaussian_splats_raw':
                    case 'geospatial_raw':
                    case 'traditional_fallback':
                    case 'archive_raw':
                    case 'photogrammetry_raw':
                    case 'bim_raw':
                    case 'unknown_raw':
                    default:
                        await loadFallbackModel(modelUrl, filename, longitude, latitude, height, processingType);
                        break;
                }
            } catch (error) {
                console.error('Model loading error:', error);
                showMessage(` Failed to load model: ${error.message}`, 'error');
                // Place fallback marker
                placeFallbackMarker(filename, longitude, latitude, height, 'error', modelUrl);
            }
        }

        /**
         * Load 3D Tileset
         */
        async function load3DTileset(modelUrl, filename, longitude, latitude, height) {
            try {
                console.log('Loading 3D Tileset:', modelUrl);
                
                let tileset;
                if (modelUrl.startsWith('ion://')) {
                    const assetId = modelUrl.replace('ion://', '');
                    tileset = await Cesium.Cesium3DTileset.fromIonAssetId(assetId);
                } else {
                    tileset = await Cesium.Cesium3DTileset.fromUrl(modelUrl);
                }
                
                // Position the tileset
                const position = Cesium.Cartesian3.fromDegrees(longitude, latitude, height);
                const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
                tileset.modelMatrix = modelMatrix;
                
                // Add to scene
                viewer.scene.primitives.add(tileset);
                
                // Fly to the tileset
                await viewer.flyTo(tileset);
                
                showMessage(` 3D Tileset "${filename}" loaded successfully!`, 'success');
                
            } catch (error) {
                console.error('3D Tileset loading error:', error);
                throw error;
            }
        }

        /**
         * Load glTF model
         */
        async function loadGltfModel(modelUrl, filename, longitude, latitude, height) {
            try {
                console.log('Loading glTF model:', modelUrl);
                
                const position = Cesium.Cartesian3.fromDegrees(longitude, latitude, height);
                
                const entity = viewer.entities.add({
                    position: position,
                    model: {
                        uri: modelUrl,
                        minimumPixelSize: 128,
                        maximumScale: 20000,
                        scale: 1.0,
                        backFaceCulling: false,
                        debugShowBoundingVolume: false,
                        debugWireframe: false,
                        enableCollision: false,
                        distanceDisplayCondition: undefined,
                        silhouetteColor: Cesium.Color.WHITE,
                        silhouetteSize: 0.0
                    }
                });
                
                // Wait for model to load
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Model loading timeout')), 30000);
                    
                    const checkReady = () => {
                        if (entity.model && entity.model.ready) {
                            clearTimeout(timeout);
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
                
                // Fly to the model
                viewer.flyTo(entity);
                
                showMessage(` glTF model "${filename}" loaded successfully!`, 'success');
                
            } catch (error) {
                console.error('glTF loading error:', error);
                throw error;
            }
        }

        /**
         * Load Cesium ion asset
         */
        async function loadCesiumIonAsset(assetId, filename, longitude, latitude, height) {
            try {
                console.log('Loading Cesium ion asset:', assetId);
                
                const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(assetId);
                
                // Position the tileset
                const position = Cesium.Cartesian3.fromDegrees(longitude, latitude, height);
                const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
                tileset.modelMatrix = modelMatrix;
                
                // Add to scene
                viewer.scene.primitives.add(tileset);
                
                // Fly to the tileset
                await viewer.flyTo(tileset);
                
                showMessage(` Cesium ion asset "${filename}" loaded successfully!`, 'success');
                
            } catch (error) {
                console.error('Cesium ion asset loading error:', error);
                throw error;
            }
        }

        /**
         * Load fallback model (unsupported or failed conversion)
         */
        async function loadFallbackModel(modelUrl, filename, longitude, latitude, height, processingType) {
            console.log('Loading fallback model:', modelUrl, 'Type:', processingType);
            
            // Place a marker indicating the file location
            placeFallbackMarker(filename, longitude, latitude, height, processingType, modelUrl);
            
            showMessage(` "${filename}" uploaded but requires client-side processing. Click the marker for details.`, 'warning');
        }

        /**
         * Place fallback marker for unsupported formats
         */
        function placeFallbackMarker(filename, longitude, latitude, height, processingType = 'unknown', modelUrl = null) {
            const entity = viewer.entities.add({
                position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                billboard: {
                    image: 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
                            <rect width="64" height="64" fill="#FF9800" rx="8"/>
                            <text x="32" y="20" text-anchor="middle" fill="white" font-size="8" font-family="Arial">3D</text>
                            <text x="32" y="32" text-anchor="middle" fill="white" font-size="6" font-family="Arial">FILE</text>
                            <text x="32" y="42" text-anchor="middle" fill="white" font-size="4" font-family="Arial">${filename.substring(0, 8)}...</text>
                        </svg>
                    `),
                    scale: 1.0,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                },
                label: {
                    text: ` ${filename}`,
                    font: '12pt sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    verticalOrigin: Cesium.VerticalOrigin.TOP,
                    pixelOffset: new Cesium.Cartesian2(0, -80)
                }
            });
            
            // Add click handler to show file info
            const urlText = modelUrl ? `<p><strong>URL:</strong> <a href="${modelUrl}" target="_blank">View File</a></p>` : '';
            entity.description = new Cesium.ConstantProperty(`
                <div style="padding: 10px;">
                    <h3> 3D File: ${filename}</h3>
                    <p><strong>Type:</strong> ${processingType}</p>
                    <p><strong>Status:</strong> <span style="color: orange;"> Requires Processing</span></p>
                    ${urlText}
                    <hr>
                    <p><strong>Next Steps:</strong></p>
                    <ul>
                        <li>Download the file for local processing</li>
                        <li>Convert to glTF/GLB format</li>
                        <li>Use Cesium ion for cloud processing</li>
                        <li>Try a different file format</li>
                    </ul>
                </div>
            `);
        }

        /**
         * Show comprehensive model help guide
         */
        function showModelHelp() {
            const helpMessage = `
                <h3 style="margin-top: 0;"> How to Create CesiumJS-Compatible 3D Models</h3>
                
                <h4> General Guidelines:</h4>
                <ul style="margin: 12px 0; padding-left: 20px; color: #666;">
                    <li><strong>File Size:</strong> Keep under 50MB for best performance</li>
                    <li><strong>Format:</strong> GLB/GLTF preferred, but we support many formats</li>
                    <li><strong>Geometry:</strong> Simple, clean meshes work best</li>
                    <li><strong>Materials:</strong> Basic PBR materials only</li>
                    <li><strong>Animations:</strong> Disable or remove complex animations</li>
                </ul>
                
                <h4> Software-Specific Instructions:</h4>
                
                <h5>Blender:</h5>
                <ol style="margin: 12px 0; padding-left: 20px; color: #666;">
                    <li>Apply all modifiers (Object  Apply  All Modifiers)</li>
                    <li>Remove animations (Delete all keyframes)</li>
                    <li>Use simple materials (Principled BSDF only)</li>
                    <li>Export as GLB (File  Export  glTF 2.0)</li>
                    <li>Check "Apply Modifiers" in export settings</li>
                </ol>
                
                <h5>Maya/3ds Max:</h5>
                <ol style="margin: 12px 0; padding-left: 20px; color: #666;">
                    <li>Bake animations if needed</li>
                    <li>Simplify materials</li>
                    <li>Export as FBX, then convert to GLB</li>
                </ol>
                
                <h5>SketchUp:</h5>
                <ol style="margin: 12px 0; padding-left: 20px; color: #666;">
                    <li>Use simple textures</li>
                    <li>Export as OBJ, then convert to GLB</li>
                </ol>
                
                <h4> Conversion Tools:</h4>
                <ul style="margin: 12px 0; padding-left: 20px; color: #666;">
                    <li><strong>Online:</strong> <a href="https://modelconverter.com" target="_blank">ModelConverter</a></li>
                    <li><strong>Desktop:</strong> Blender (free), MeshLab (free)</li>
                    <li><strong>Command Line:</strong> assimp, meshlabserver</li>
                </ul>
                
                <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 15px; border-radius: 8px; margin: 16px 0;">
                    <strong> Pro Tip:</strong> Start with simple geometric shapes to test the system, then gradually add complexity!
                </div>
            `;
            
            const buttons = [
                {
                    text: 'Got It',
                    action: () => document.querySelector('.error-modal').remove(),
                    style: 'primary'
                }
            ];
            
            showErrorModal('3D Model Help Guide', helpMessage, buttons);
        }

        /**
         * Universal 3D model loader with support for 30+ formats
         * @param {File} file - The 3D model file to load (supports all major formats)
         */
        async function loadModelAtCameraCenter(file) {
            console.log('Loading 3D model:', file.name, 'Size:', file.size, 'bytes');
            
            try {
                // Step 1: Validate file format (universal support)
                const formatValidation = validateFileFormat(file);
                if (!formatValidation.isValid) {
                    showErrorModal('Unsupported File Format', formatValidation.message);
                    return;
                }
                
                // Step 2: Validate file size (increased to 500MB)
                const sizeValidation = validateFileSize(file);
                if (!sizeValidation.isValid) {
                    showErrorModal('Large File Warning', sizeValidation.message, [
                        {
                            text: 'Continue Anyway',
                            action: () => {
                                document.querySelector('.error-modal').remove();
                                proceedWithModelLoading(file);
                            },
                            style: 'primary'
                        },
                        {
                            text: 'Cancel',
                            action: () => document.querySelector('.error-modal').remove(),
                            style: 'secondary'
                        }
                    ]);
                    return;
                }
                
                // All validations passed, proceed with loading
                proceedWithModelLoading(file);
                
            } catch (error) {
                console.error('Error in model validation:', error);
                showErrorModal('Validation Error', 'An error occurred while validating the file. Please try again.');
            }
        }

        /**
         * Proceed with model loading after validation
         * @param {File} file - Validated file to load
         */
        async function proceedWithModelLoading(file) {
            try {
                
                // Get center of camera view coordinates
                const canvas = viewer.canvas;
                const centerX = canvas.clientWidth / 2;
                const centerY = canvas.clientHeight / 2;
                const centerPick = new Cesium.Cartesian2(centerX, centerY);
                
                // Cast ray to find intersection point
                const ray = viewer.camera.getPickRay(centerPick);
                let intersection = viewer.scene.globe.pick(ray, viewer.scene);
                
                // Fallback to ellipsoid intersection if no terrain
                if (!intersection) {
                    const ellipsoidIntersection = Cesium.IntersectionTests.rayEllipsoid(ray, viewer.scene.globe.ellipsoid);
                    if (ellipsoidIntersection) {
                        intersection = Cesium.Ray.getPoint(ray, ellipsoidIntersection.start);
                    }
                }
                
                if (!intersection) {
                    console.warn('Could not determine model placement position');
                    alert('Could not determine placement position. Please try from a different view.');
                    return;
                }
                
                // Convert to geographic coordinates
                const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                const height = cartographic.height + 10; // Slightly above ground
                
                console.log(`Placing model at: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}, height: ${height.toFixed(2)}m`);
                
                // Upload file to server first
                console.log('Uploading file to server...');
                const formData = new FormData();
                formData.append('file', file);
                
                const uploadResponse = await fetch('/api/upload-model', {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    const errorData = await uploadResponse.json();
                    throw new Error(errorData.detail || 'Upload failed');
                }
                
                const uploadResult = await uploadResponse.json();
                console.log('Upload successful:', uploadResult);
                
                // Handle different processing types
                const processingType = uploadResult.processing_type;
                const modelUrl = uploadResult.url;
                const cesiumIonAssetId = uploadResult.cesium_ion_asset_id;
                
                console.log('Processing type:', processingType);
                console.log('Using URL:', modelUrl);
                
                // Show success message based on processing type
                showProcessingSuccess(uploadResult);
                
                // Load model based on processing type
                await loadModelByType(processingType, modelUrl, cesiumIonAssetId, file.name, longitude, latitude, height);
                
                // Show loading indicator
                const loadingMessage = document.createElement('div');
                loadingMessage.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0,0,0,0.8);
                    color: white;
                    padding: 20px;
                    border-radius: 8px;
                    z-index: 10000;
                    font-family: Arial, sans-serif;
                `;
                loadingMessage.textContent = 'Loading 3D model...';
                document.body.appendChild(loadingMessage);
                
                // Set up comprehensive error handling and camera protection
                let modelLoadFailed = false;
                let modelEntity = null;
                let errorRecoveryTimeout = null;
                
                // Store current camera state for recovery
                const cameraBackup = {
                    position: viewer.camera.position.clone(),
                    direction: viewer.camera.direction.clone(),
                    up: viewer.camera.up.clone(),
                    right: viewer.camera.right.clone()
                };
                
                // Function to restore camera controls and clean up
                const restoreCameraControls = () => {
                    try {
                        // Force enable camera controls
                        viewer.scene.screenSpaceCameraController.enableRotate = true;
                        viewer.scene.screenSpaceCameraController.enableTranslate = true;
                        viewer.scene.screenSpaceCameraController.enableZoom = true;
                        viewer.scene.screenSpaceCameraController.enableTilt = true;
                        viewer.scene.screenSpaceCameraController.enableLook = true;
                        
                        // Reset camera if needed
                        if (viewer.camera.position.equals(Cesium.Cartesian3.ZERO)) {
                            viewer.camera.position = cameraBackup.position;
                            viewer.camera.direction = cameraBackup.direction;
                            viewer.camera.up = cameraBackup.up;
                            viewer.camera.right = cameraBackup.right;
                        }
                        
                        // Force scene update
                        viewer.scene.requestRender();
                        console.log('Camera controls restored successfully');
                    } catch (error) {
                        console.warn('Camera restoration error:', error);
                    }
                };
                
                // Override console.error to catch CesiumJS model errors
                const originalConsoleError = console.error;
                const errorHandler = function(...args) {
                    const errorString = args.join(' ');
                    if (!modelLoadFailed && (
                        errorString.includes('midpoint') || 
                        errorString.includes('incrementallyLoadTextures') || 
                        errorString.includes('Cannot read properties of undefined') ||
                        errorString.includes('reading \'x\'') ||
                        errorString.includes('fromCornerPoints') ||
                        errorString.includes('new yue') ||
                        errorString.includes('buildDrawCommands') ||
                        errorString.includes('Ske') ||
                        errorString.includes('To.update') ||
                        errorString.includes('pn.fromCornerPoints') ||
                        errorString.includes('qs.update') ||
                        errorString.includes('Yl.updateAndExecuteCommands') ||
                        errorString.includes('AttributeType.SCALAR') ||
                        errorString.includes('ModelExperimental')
                    )) {
                        modelLoadFailed = true;
                        console.warn('3D model compatibility error detected');
                        
                        // Immediate camera control restoration
                        restoreCameraControls();
                        
                        // Clean up loading indicator
                        if (document.body.contains(loadingMessage)) {
                            document.body.removeChild(loadingMessage);
                        }
                        
                        // Remove failed model entity if it exists
                        if (modelEntity) {
                            try {
                                viewer.entities.remove(modelEntity);
                            } catch (e) {
                                console.warn('Error removing failed model entity:', e);
                            }
                        }
                        
                        // Clear any pending timeouts
                        if (errorRecoveryTimeout) {
                            clearTimeout(errorRecoveryTimeout);
                        }
                        
                        // Show compatibility error modal
                        showCompatibilityError(file.name);
                        
                        // Place a marker at the intended location
                        try {
                            viewer.entities.add({
                                name: `Failed Model - ${file.name}`,
                                position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                                point: {
                                    pixelSize: 12,
                                    color: Cesium.Color.RED,
                                    outlineColor: Cesium.Color.WHITE,
                                    outlineWidth: 2
                                },
                                label: {
                                    text: ` ${file.name}`,
                                    font: '11pt Arial',
                                    fillColor: Cesium.Color.WHITE,
                                    outlineColor: Cesium.Color.BLACK,
                                    outlineWidth: 1,
                                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                    pixelOffset: new Cesium.Cartesian2(0, -30)
                                }
                            });
                            
                            viewer.camera.setView({
                                destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 100),
                                orientation: {
                                    heading: 0,
                                    pitch: Cesium.Math.toRadians(-30),
                                    roll: 0
                                }
                            });
                        } catch (markerError) {
                            console.warn('Could not place error marker:', markerError);
                        }
                        
                        // Auto-remove error message
                        setTimeout(function() {
                            if (document.body.contains(errorDiv)) {
                                document.body.removeChild(errorDiv);
                            }
                        }, 8000);
                        
                        return;
                    }
                    originalConsoleError.apply(console, args);
                };
                
                console.error = errorHandler;
                
                // Create a simple point marker as fallback visualization
                const fallbackEntity = viewer.entities.add({
                    name: `Model Location - ${file.name}`,
                    position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                    point: {
                        pixelSize: 15,
                        color: Cesium.Color.YELLOW,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                    },
                    label: {
                        text: ` ${file.name}`,
                        font: '12pt Arial',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        pixelOffset: new Cesium.Cartesian2(0, -40),
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
                    }
                });
                
                console.log('Created fallback marker for model location');
                
                // Try to load the 3D model with simplified approach
                try {
                    console.log('Attempting to load 3D model...');
                    
                    // Create model with minimal settings for maximum compatibility
                    modelEntity = viewer.entities.add({
                        name: `3D Model - ${file.name}`,
                        position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                        model: {
                            uri: modelUrl,
                            scale: 1.0,
                            minimumPixelSize: 32,
                            maximumScale: 1000,
                            runAnimations: false,
                            clampAnimations: true,
                            heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                            // Minimal settings for compatibility
                            silhouetteColor: Cesium.Color.TRANSPARENT,
                            silhouetteSize: 0,
                            incrementallyLoadTextures: false,
                            backFaceCulling: false,
                            shadows: Cesium.ShadowMode.DISABLED,
                            // Additional compatibility settings
                            debugShowBoundingVolume: false,
                            debugWireframe: false
                        }
                    });
                    
                    // Handle model loading with readyPromise
                    if (modelEntity.model.readyPromise) {
                        modelEntity.model.readyPromise
                            .then(() => {
                                if (!modelLoadFailed) {
                                    console.log('Model loaded successfully via readyPromise');
                                    
                                    // Clean up loading indicator
                                    if (document.body.contains(loadingMessage)) {
                                        document.body.removeChild(loadingMessage);
                                    }
                                    
                                    // Remove fallback marker
                                    viewer.entities.remove(fallbackEntity);
                                    
                                    // Restore console.error
                                    console.error = originalConsoleError;
                                    
                                    // Fly to model
                                    viewer.camera.setView({
                                        destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 50),
                                        orientation: {
                                            heading: 0,
                                            pitch: Cesium.Math.toRadians(-30),
                                            roll: 0
                                        }
                                    });
                                }
                            })
                            .catch((error) => {
                                if (!modelLoadFailed) {
                                    console.warn('Model readyPromise failed, trying simplified approach:', error);
                                    
                                    // Try a second time with even more basic settings
                                    try {
                                        // Remove the failed model
                                        if (modelEntity) {
                                            viewer.entities.remove(modelEntity);
                                        }
                                        
                                        // Try with absolute minimal settings
                                        modelEntity = viewer.entities.add({
                                            name: `3D Model (Simple) - ${file.name}`,
                                            position: Cesium.Cartesian3.fromDegrees(longitude, latitude, height),
                                            model: {
                                                uri: modelUrl,
                                                scale: 1.0,
                                                minimumPixelSize: 32,
                                                maximumScale: 1000,
                                                runAnimations: false,
                                                clampAnimations: true,
                                                heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                                                // Absolute minimal settings
                                                silhouetteColor: Cesium.Color.TRANSPARENT,
                                                silhouetteSize: 0,
                                                incrementallyLoadTextures: false,
                                                backFaceCulling: false,
                                                shadows: Cesium.ShadowMode.DISABLED,
                                                debugShowBoundingVolume: false,
                                                debugWireframe: false,
                                                // Disable all advanced features
                                                enableCollision: false,
                                                distanceDisplayCondition: undefined
                                            }
                                        });
                                        
                                        // Try the readyPromise again
                                        if (modelEntity.model.readyPromise) {
                                            modelEntity.model.readyPromise
                                                .then(() => {
                                                    if (!modelLoadFailed) {
                                                        console.log('Model loaded successfully with simplified settings');
                                                        
                                                        // Clean up loading indicator
                                                        if (document.body.contains(loadingMessage)) {
                                                            document.body.removeChild(loadingMessage);
                                                        }
                                                        
                                                        // Remove fallback marker
                                                        viewer.entities.remove(fallbackEntity);
                                                        
                                                        // Restore console.error
                                                        console.error = originalConsoleError;
                                                        
                                                        // Fly to model
                                                        viewer.camera.setView({
                                                            destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 50),
                                                            orientation: {
                                                                heading: 0,
                                                                pitch: Cesium.Math.toRadians(-30),
                                                                roll: 0
                                                            }
                                                        });
                                                    }
                                                })
                                                .catch((secondError) => {
                                                    console.warn('Second attempt also failed:', secondError);
                                    modelLoadFailed = true;
                                    
                                    // Clean up
                                    if (document.body.contains(loadingMessage)) {
                                        document.body.removeChild(loadingMessage);
                                    }
                                    
                                    if (modelEntity) {
                                        try {
                                            viewer.entities.remove(modelEntity);
                                        } catch (e) {
                                            console.warn('Error removing failed model:', e);
                                        }
                                    }
                                    
                                    restoreCameraControls();
                                    console.error = originalConsoleError;
                                    
                                    // Show compatibility error
                                    showCompatibilityError(file.name);
                                                });
                                        }
                                    } catch (secondAttemptError) {
                                        console.warn('Second attempt failed:', secondAttemptError);
                                        modelLoadFailed = true;
                                        
                                        // Clean up
                                        if (document.body.contains(loadingMessage)) {
                                            document.body.removeChild(loadingMessage);
                                        }
                                        
                                        if (modelEntity) {
                                            try {
                                                viewer.entities.remove(modelEntity);
                                            } catch (e) {
                                                console.warn('Error removing failed model:', e);
                                            }
                                        }
                                        
                                        restoreCameraControls();
                                        console.error = originalConsoleError;
                                        
                                        // Show compatibility error
                                        showCompatibilityError(file.name);
                                    }
                                }
                            });
                    }
                    
                    // Set up monitoring for successful model loading
                    let loadingTimeout;
                    let checkModelLoaded = false;
                    
                    const checkIfModelLoaded = () => {
                        if (modelLoadFailed) return;
                        
                        try {
                            // Check if model has loaded successfully
                            if (modelEntity.model && modelEntity.model.readyPromise) {
                                modelEntity.model.readyPromise.then(() => {
                                    if (!modelLoadFailed) {
                                        // Model loaded successfully
                                        console.log('Model loaded successfully');
                                        checkModelLoaded = true;
                                        
                                        // Remove loading indicator
                                        if (document.body.contains(loadingMessage)) {
                                            document.body.removeChild(loadingMessage);
                                        }
                                        
                                        // Remove fallback marker since model loaded
                                        viewer.entities.remove(fallbackEntity);
                                        
                                        // Restore console.error
                                        console.error = originalConsoleError;
                                        
                                        // Clear monitoring timeout
                                        if (loadingTimeout) {
                                            clearTimeout(loadingTimeout);
                                        }
                                        
                                        // Fly to model
                                        viewer.camera.setView({
                                            destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 50),
                                            orientation: {
                                                heading: 0,
                                                pitch: Cesium.Math.toRadians(-30),
                                                roll: 0
                                            }
                                        });
                                    }
                                }).catch((error) => {
                                    if (!modelLoadFailed) {
                                        console.warn('Model ready promise failed:', error);
                                        errorHandler(['Model loading failed during ready promise']);
                                    }
                                });
                            }
                        } catch (checkError) {
                            console.warn('Error checking model load status:', checkError);
                        }
                    };
                    
                    // Start monitoring
                    setTimeout(checkIfModelLoaded, 500);
                    
                    // Fallback timeout for problematic models
                    loadingTimeout = setTimeout(() => {
                        if (!checkModelLoaded && !modelLoadFailed) {
                            console.log('Model loading failed, showing fallback marker');
                            modelLoadFailed = true;
                            
                            // Clean up loading indicator
                            if (document.body.contains(loadingMessage)) {
                                document.body.removeChild(loadingMessage);
                            }
                            
                            // Remove model entity
                            if (modelEntity) {
                                try {
                                    viewer.entities.remove(modelEntity);
                                } catch (e) {
                                    console.warn('Error removing timeout model entity:', e);
                                }
                            }
                            
                            // Restore camera controls
                            restoreCameraControls();
                            
                            // Restore console.error
                            console.error = originalConsoleError;
                            
                            // Show timeout modal
                            showErrorModal(
                                'Model Loading Timeout',
                                `The model is taking too long to load. This could indicate compatibility issues.
                                <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 16px 0;">
                                    <strong style="color: #007bff;"> Try This:</strong>
                                    <ul style="margin: 8px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>Use a smaller file (under 5MB)</li>
                                        <li>Export with basic materials only</li>
                                        <li>Disable animations before export</li>
                                    </ul>
                                </div>`
                            );
                        }
                    }, 8000); // 8 second timeout
                    
                } catch (modelError) {
                    console.error('Error creating model entity:', modelError);
                    // Restore original console.error
                    console.error = originalConsoleError;
                    
                    if (document.body.contains(loadingMessage)) {
                        document.body.removeChild(loadingMessage);
                    }
                    
                    // Show fallback marker
                    viewer.camera.setView({
                        destination: Cesium.Cartesian3.fromDegrees(longitude, latitude, height + 100),
                        orientation: {
                            heading: 0,
                            pitch: Cesium.Math.toRadians(-30),
                            roll: 0
                        }
                    });
                    
                    showErrorModal('Model Loading Error', 'Could not load 3D model. A marker has been placed at the location.');
                }
                
            } catch (error) {
                console.error('Error in model loading process:', error);
                showErrorModal('Processing Error', 'Error processing 3D model file: ' + error.message);
            }
        }

        // Global camera restoration function for emergency recovery
        window.restoreCameraControls = function() {
            try {
                if (viewer && viewer.scene && viewer.scene.screenSpaceCameraController) {
                    viewer.scene.screenSpaceCameraController.enableRotate = true;
                    viewer.scene.screenSpaceCameraController.enableTranslate = true;
                    viewer.scene.screenSpaceCameraController.enableZoom = true;
                    viewer.scene.screenSpaceCameraController.enableTilt = true;
                    viewer.scene.screenSpaceCameraController.enableLook = true;
                    viewer.scene.requestRender();
                    console.log('Global camera controls restored');
                }
            } catch (error) {
                console.warn('Global camera restoration error:', error);
            }
        };

        /**
         * Show sample compatible 3D models for testing
         */
        function showSampleModels() {
            const sampleDiv = document.createElement('div');
            sampleDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(44, 62, 80, 0.95);
                color: white;
                padding: 25px;
                border-radius: 12px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                max-width: 550px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            sampleDiv.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #52c41a;">Test with Compatible Models</h3>
                <div style="text-align: left; margin-bottom: 20px;">
                    <p style="margin-bottom: 15px;">Try these known CesiumJS-compatible sources:</p>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                        <strong> Free 3D Model Sites:</strong>
                        <ul style="font-size: 13px; line-height: 1.6; margin-top: 8px;">
                            <li><strong>Cesium Sandcastle</strong> - Official examples with GLB models</li>
                            <li><strong>Khronos Group</strong> - Official GLTF sample models</li>
                            <li><strong>Sketchfab</strong> - Filter by "Downloadable" + "GLTF"</li>
                            <li><strong>Poly Haven</strong> - Simple objects, good for testing</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px;">
                        <strong> What Works Best:</strong>
                        <ul style="font-size: 13px; line-height: 1.6; margin-top: 8px;">
                            <li>Simple geometric objects (cubes, spheres, vehicles)</li>
                            <li>Models under 5MB with basic materials</li>
                            <li>GLTF 2.0 format without custom extensions</li>
                            <li>Static models without skeletal animation</li>
                        </ul>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="openModelSources(); this.parentElement.parentElement.remove();" style="background: #52c41a; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Find Models</button>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">Close</button>
                </div>
            `;
            document.body.appendChild(sampleDiv);
        }

        /**
         * Open useful 3D model sources in new tabs
         */
        function openModelSources() {
            // Open multiple useful sources for finding compatible 3D models
            const sources = [
                'https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0',
                'https://sketchfab.com/3d-models?features=downloadable&sort_by=-likeCount&file_formats=gltf',
                'https://polyhaven.com/models',
                'https://sandcastle.cesium.com/?src=3D%20Models.html'
            ];
            
            // Open first two sources (avoid popup blockers)
            sources.slice(0, 2).forEach((url, index) => {
                setTimeout(() => {
                    window.open(url, '_blank');
                }, index * 100); // Small delay to avoid popup blocker
            });
            
            // Show message about additional sources
            setTimeout(() => {
                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(52, 152, 219, 0.95);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    z-index: 10002;
                    font-family: Arial, sans-serif;
                    max-width: 300px;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                `;
                infoDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;"> Model Sources Opened</div>
                    <div style="font-size: 13px; line-height: 1.4;">
                        Check your new tabs for:<br>
                         Khronos GLTF samples<br>
                         Sketchfab downloadable models<br>
                        <br>
                        <span style="opacity: 0.9;">Look for small, simple GLB files under 5MB</span>
                    </div>
                    <button onclick="this.parentElement.remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-top: 10px;">Got it</button>
                `;
                document.body.appendChild(infoDiv);
                
                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (document.body.contains(infoDiv)) {
                        infoDiv.remove();
                    }
                }, 8000);
            }, 500);
        }

        /**
         * Show alternatives for incompatible models
         */
        function showModelAlternatives() {
            const altDiv = document.createElement('div');
            altDiv.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(52, 73, 94, 0.95);
                color: white;
                padding: 25px;
                border-radius: 12px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                max-width: 500px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            altDiv.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #3498db;">Alternative Solutions</h3>
                <div style="text-align: left; margin-bottom: 20px;">
                    <p style="margin-bottom: 15px;"><strong>Free 3D Model Converters:</strong></p>
                    <ul style="font-size: 13px; line-height: 1.6;">
                        <li><strong>Blender</strong> - Free, powerful 3D software with GLTF export</li>
                        <li><strong>Sketchfab</strong> - Online model viewer with download options</li>
                        <li><strong>Three.js Editor</strong> - Web-based GLTF optimizer</li>
                        <li><strong>gltf-pipeline</strong> - Command line GLTF optimizer</li>
                    </ul>
                    
                    <p style="margin: 15px 0 10px 0;"><strong>Quick Export Tips:</strong></p>
                    <ul style="font-size: 13px; line-height: 1.6;">
                        <li>In Blender: File  Export  glTF 2.0  "Include: Selected Objects"</li>
                        <li>Disable "Include Animations" and "Apply Modifiers"</li>
                        <li>Use "GLTF Separate" format instead of "GLTF Binary"</li>
                        <li>Reduce polygon count with Decimate modifier</li>
                    </ul>
                </div>
                <button onclick="this.parentElement.remove()" style="background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">Got It</button>
            `;
            document.body.appendChild(altDiv);
        }

        // Measurement tool state and variables
        let measurementTool = {
            isActive: false,
            mode: 'line', // 'line', 'area', 'vertical'
            units: 'metric', // 'metric', 'imperial'
            points: [],
            entities: [],
            activePoints: [],
            clickHandler: null,
            results: {}
        };

        /**
         * Toggle measurement tool visibility and functionality
         */
        function toggleMeasurementTool() {
            const measurementControls = document.getElementById('measurementControls');
            const measurementToolEl = document.getElementById('measurementTool');
            
            if (measurementControls.style.display === 'none' || measurementControls.style.display === '') {
                // Close marker panel if open
                const markerControls = document.getElementById('markerControls');
                if (markerControls.style.display === 'block') {
                    markerControls.style.display = 'none';
                    const markerTool = document.getElementById('markerTool');
                    if (markerTool) markerTool.classList.remove('active');
                }
                
                measurementControls.style.display = 'block';
                measurementTool.isActive = true;
                if (measurementToolEl) measurementToolEl.classList.add('active');
                startMeasurement();
                console.log('Measurement panel activated');
            } else {
                measurementControls.style.display = 'none';
                measurementTool.isActive = false;
                if (measurementToolEl) measurementToolEl.classList.remove('active');
                stopMeasurement();
                console.log('Measurement panel deactivated');
            }
        }

        /**
         * Set measurement mode (line, area, vertical)
         */
        function setMeasurementMode(mode) {
            // Update UI
            document.querySelectorAll('.measurement-mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            
            // Update measurement state
            measurementTool.mode = mode;
            newMeasurement();
            
            // Update instructions
            updateInstructions();
        }

        /**
         * Update measurement instructions based on current mode
         */
        function updateInstructions() {
            const instructionsEl = document.getElementById('measurementInstructions');
            
            switch(measurementTool.mode) {
                case 'line':
                    instructionsEl.textContent = 'Click two points to measure distance';
                    break;
                case 'area':
                    instructionsEl.textContent = 'Click points to create area boundary (double-click to finish)';
                    break;
                case 'vertical':
                    instructionsEl.textContent = 'Click two points to measure vertical distance';
                    break;
                default:
                    instructionsEl.textContent = 'Select measurement mode';
            }
        }

        /**
         * Start measurement functionality
         */
        function startMeasurement() {
            if (!viewer || !measurementTool.isActive) return;
            
            // Disable default click behavior temporarily
            viewer.cesiumWidget.screenSpaceEventHandler.setInputAction(function(event) {
                handleMeasurementClick(event);
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
            
            updateInstructions();
        }

        /**
         * Stop measurement functionality
         */
        function stopMeasurement() {
            if (!viewer) return;
            
            // Re-enable default click behavior
            viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }

        /**
         * Handle click events for measurement
         */
        function handleMeasurementClick(event) {
            if (!measurementTool.isActive) return;
            
            // Pick position on globe/terrain
            const pickedPosition = viewer.camera.pickEllipsoid(event.position, viewer.scene.globe.ellipsoid);
            if (!pickedPosition) return;
            
            measurementTool.activePoints.push(pickedPosition);
            
            // Add visual point marker
            addPointMarker(pickedPosition, measurementTool.activePoints.length);
            
            // Handle different measurement modes
            switch(measurementTool.mode) {
                case 'line':
                case 'vertical':
                    if (measurementTool.activePoints.length === 2) {
                        completeMeasurement();
                    }
                    break;
                case 'area':
                    if (measurementTool.activePoints.length >= 3) {
                        // Area measurement requires at least 3 points
                        // Will be completed with double-click or explicit finish
                        updateAreaMeasurement();
                    }
                    break;
            }
        }

        /**
         * Update area measurement (for incremental area updates)
         */
        function updateAreaMeasurement() {
            if (measurementTool.activePoints.length >= 3) {
                // Clear previous area visualization
                measurementTool.entities.forEach(entity => {
                    if (entity.polygon) {
                        viewer.entities.remove(entity);
                    }
                });
                
                // Draw current area
                drawAreaPolygon();
                
                // Calculate and display current results
                const results = calculateAreaMeasurement();
                measurementTool.results = results;
                displayResults(results);
            }
        }

        /**
         * Add visual point marker
         */
        function addPointMarker(position, pointNumber) {
            const pointEntity = viewer.entities.add({
                position: position,
                point: {
                    pixelSize: 8,
                    color: Cesium.Color.ORANGE,
                    outlineColor: Cesium.Color.WHITE,
                    outlineWidth: 2,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                },
                label: {
                    text: pointNumber.toString(),
                    font: '12pt Arial',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    pixelOffset: new Cesium.Cartesian2(0, -20),
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                }
            });
            
            measurementTool.entities.push(pointEntity);
        }

        /**
         * Complete measurement and show results
         */
        function completeMeasurement() {
            if (measurementTool.activePoints.length < 2) return;
            
            let results = {};
            
            if (measurementTool.mode === 'line') {
                results = calculateLineDistance();
            } else if (measurementTool.mode === 'vertical') {
                results = calculateVerticalDistance();
            } else if (measurementTool.mode === 'area') {
                results = calculateAreaMeasurement();
                drawAreaPolygon();
                measurementTool.results = results;
                displayResults(results);
                return;
            }
            
            // Set results first, then draw line with label
            measurementTool.results = results;
            drawMeasurementLine();
            displayResults(results);
        }

        /**
         * Calculate line distance measurements
         */
        function calculateLineDistance() {
            const point1 = measurementTool.activePoints[0];
            const point2 = measurementTool.activePoints[1];
            
            // Convert to cartographic for height information
            const cartographic1 = Cesium.Cartographic.fromCartesian(point1);
            const cartographic2 = Cesium.Cartographic.fromCartesian(point2);
            
            // Calculate 3D direct distance
            const distance3D = Cesium.Cartesian3.distance(point1, point2);
            
            // Calculate horizontal distance (geodesic distance on ellipsoid)
            const geodesic = new Cesium.EllipsoidGeodesic(cartographic1, cartographic2);
            const horizontalDistance = geodesic.surfaceDistance || 0;
            
            // Calculate vertical distance (ensure heights are valid)
            const height1 = cartographic1.height || 0;
            const height2 = cartographic2.height || 0;
            const verticalDistance = Math.abs(height2 - height1);
            
            // Calculate slope and azimuth (with safety checks)
            const slope = horizontalDistance > 0 ? verticalDistance / horizontalDistance : 0;
            const slopeAngle = Math.atan(slope) * (180 / Math.PI);
            
            // Get azimuth (heading) with fallback
            let azimuth = 0;
            try {
                azimuth = (geodesic.startHeading || 0) * (180 / Math.PI);
                // Normalize azimuth to 0-360 degrees
                azimuth = azimuth < 0 ? azimuth + 360 : azimuth;
            } catch (e) {
                console.warn('Azimuth calculation failed:', e);
                azimuth = 0;
            }
            
            return {
                direct: distance3D || 0,
                horizontal: horizontalDistance || 0,
                vertical: verticalDistance || 0,
                slope: slopeAngle || 0,
                azimuth: azimuth || 0,
                point1Height: height1,
                point2Height: height2
            };
        }

        /**
         * Calculate vertical distance measurements
         */
        function calculateVerticalDistance() {
            const results = calculateLineDistance();
            return {
                vertical: results.vertical,
                point1Height: results.point1Height,
                point2Height: results.point2Height,
                heightDifference: results.point2Height - results.point1Height
            };
        }

        /**
         * Calculate area measurement (simplified polygon area)
         */
        function calculateAreaMeasurement() {
            if (measurementTool.activePoints.length < 3) return {};
            
            // Convert points to cartographic
            const cartographicPoints = measurementTool.activePoints.map(point => 
                Cesium.Cartographic.fromCartesian(point)
            );
            
            // Calculate approximate area using spherical excess method
            let area = 0;
            const R = 6371000; // Earth radius in meters
            
            for (let i = 0; i < cartographicPoints.length; i++) {
                const j = (i + 1) % cartographicPoints.length;
                const lat1 = cartographicPoints[i].latitude;
                const lon1 = cartographicPoints[i].longitude;
                const lat2 = cartographicPoints[j].latitude;
                const lon2 = cartographicPoints[j].longitude;
                
                area += (lon2 - lon1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }
            
            area = Math.abs(area * R * R / 2);
            
            // Calculate perimeter
            let perimeter = 0;
            for (let i = 0; i < measurementTool.activePoints.length; i++) {
                const j = (i + 1) % measurementTool.activePoints.length;
                perimeter += Cesium.Cartesian3.distance(
                    measurementTool.activePoints[i], 
                    measurementTool.activePoints[j]
                );
            }
            
            return {
                area: area,
                perimeter: perimeter,
                points: measurementTool.activePoints.length
            };
        }

        /**
         * Draw measurement line between points
         */
        function drawMeasurementLine() {
            const lineEntity = viewer.entities.add({
                polyline: {
                    positions: measurementTool.activePoints,
                    width: 3,
                    material: Cesium.Color.ORANGE,
                    clampToGround: true
                }
            });
            
            measurementTool.entities.push(lineEntity);
            
            // Add distance label at midpoint
            if (measurementTool.activePoints.length === 2) {
                const midpoint = Cesium.Cartesian3.midpoint(
                    measurementTool.activePoints[0],
                    measurementTool.activePoints[1],
                    new Cesium.Cartesian3()
                );
                
                const distance = formatDistance(measurementTool.results.direct || 0);
                
                const labelEntity = viewer.entities.add({
                    position: midpoint,
                    label: {
                        text: distance,
                        font: '14pt Arial',
                        fillColor: Cesium.Color.ORANGE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        pixelOffset: new Cesium.Cartesian2(0, -30),
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                    }
                });
                
                measurementTool.entities.push(labelEntity);
            }
        }

        /**
         * Draw area polygon
         */
        function drawAreaPolygon() {
            const polygonEntity = viewer.entities.add({
                polygon: {
                    hierarchy: measurementTool.activePoints,
                    material: Cesium.Color.ORANGE.withAlpha(0.3),
                    outline: true,
                    outlineColor: Cesium.Color.ORANGE,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                }
            });
            
            measurementTool.entities.push(polygonEntity);
        }

        /**
         * Format distance value based on current units
         */
        function formatDistance(meters) {
            // Ensure meters is a valid number
            const validMeters = parseFloat(meters) || 0;
            
            if (measurementTool.units === 'metric') {
                if (validMeters >= 1000) {
                    return (validMeters / 1000).toFixed(2) + ' km';
                } else {
                    return validMeters.toFixed(2) + ' m';
                }
            } else {
                const feet = validMeters * 3.28084;
                if (feet >= 5280) {
                    return (feet / 5280).toFixed(2) + ' mi';
                } else {
                    return feet.toFixed(2) + ' ft';
                }
            }
        }

        /**
         * Format area value based on current units
         */
        function formatArea(squareMeters) {
            // Ensure squareMeters is a valid number
            const validSquareMeters = parseFloat(squareMeters) || 0;
            
            if (measurementTool.units === 'metric') {
                if (validSquareMeters >= 10000) {
                    return (validSquareMeters / 10000).toFixed(2) + ' ha';
                } else {
                    return validSquareMeters.toFixed(2) + ' m';
                }
            } else {
                const squareFeet = validSquareMeters * 10.7639;
                if (squareFeet >= 43560) {
                    return (squareFeet / 43560).toFixed(2) + ' acres';
                } else {
                    return squareFeet.toFixed(2) + ' ft';
                }
            }
        }

        /**
         * Display measurement results in the UI
         */
        function displayResults(results) {
            const resultsEl = document.getElementById('measurementResults');
            let html = '';
            
            // Add debugging
            console.log('Display results called with:', results);
            
            try {
                if (measurementTool.mode === 'line') {
                    html = `
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Direct Distance:</span>
                            <span class="measurement-result-value">${formatDistance(results.direct || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Horizontal:</span>
                            <span class="measurement-result-value">${formatDistance(results.horizontal || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Vertical:</span>
                            <span class="measurement-result-value">${formatDistance(results.vertical || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Slope:</span>
                            <span class="measurement-result-value">${(parseFloat(results.slope) || 0).toFixed(1)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Azimuth:</span>
                            <span class="measurement-result-value">${(parseFloat(results.azimuth) || 0).toFixed(1)}</span>
                        </div>
                    `;
                } else if (measurementTool.mode === 'vertical') {
                    html = `
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Vertical Distance:</span>
                            <span class="measurement-result-value">${formatDistance(results.vertical || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Height Difference:</span>
                            <span class="measurement-result-value">${formatDistance(Math.abs(results.heightDifference || 0))}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Point 1 Height:</span>
                            <span class="measurement-result-value">${formatDistance(results.point1Height || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Point 2 Height:</span>
                            <span class="measurement-result-value">${formatDistance(results.point2Height || 0)}</span>
                        </div>
                    `;
                } else if (measurementTool.mode === 'area') {
                    html = `
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Area:</span>
                            <span class="measurement-result-value">${formatArea(results.area || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Perimeter:</span>
                            <span class="measurement-result-value">${formatDistance(results.perimeter || 0)}</span>
                        </div>
                        <div class="measurement-result-item">
                            <span class="measurement-result-label">Points:</span>
                            <span class="measurement-result-value">${results.points || 0}</span>
                        </div>
                    `;
                }
                
                resultsEl.innerHTML = html;
            } catch (error) {
                console.error('Error displaying results:', error);
                resultsEl.innerHTML = `
                    <div style="text-align: center; color: #ff6b6b; font-size: 11px; margin-top: 15px;">
                        Error displaying measurements
                    </div>
                `;
            }
        }

        /**
         * Update measurement units and refresh display
         */
        function updateMeasurementUnits() {
            const unitsSelect = document.getElementById('measurementUnits');
            measurementTool.units = unitsSelect.value;
            
            // Refresh results display if we have results
            if (Object.keys(measurementTool.results).length > 0) {
                displayResults(measurementTool.results);
                
                // Update line labels if present
                updateLineLabels();
            }
        }

        /**
         * Update line labels with new units
         */
        function updateLineLabels() {
            // Remove existing line labels and redraw
            measurementTool.entities.forEach(entity => {
                if (entity.label) {
                    viewer.entities.remove(entity);
                }
            });
            
            // Redraw measurement line to update labels
            if (measurementTool.mode === 'line' || measurementTool.mode === 'vertical') {
                drawMeasurementLine();
            }
        }

        /**
         * Start new measurement (clear current)
         */
        function newMeasurement() {
            clearCurrentMeasurement();
            measurementTool.activePoints = [];
            measurementTool.results = {};
            
            // Reset results display
            const resultsEl = document.getElementById('measurementResults');
            resultsEl.innerHTML = `
                <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 15px;">
                    No measurements yet
                </div>
            `;
            
            updateInstructions();
        }

        /**
         * Clear current measurement entities
         */
        function clearCurrentMeasurement() {
            measurementTool.entities.forEach(entity => {
                viewer.entities.remove(entity);
            });
            measurementTool.entities = [];
        }

        /**
         * Clear all measurements
         */
        function clearMeasurements() {
            clearCurrentMeasurement();
            measurementTool.activePoints = [];
            measurementTool.results = {};
            
            // Reset results display
            const resultsEl = document.getElementById('measurementResults');
            resultsEl.innerHTML = `
                <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 15px;">
                    No measurements yet
                </div>
            `;
            
            updateInstructions();
        }

        /**
         * Toggle atmospheric effects for 3D visualization
         */
        function toggleAtmosphere() {
            const toggle = document.getElementById('atmosphereToggle');
            const enabled = toggle.checked;
            
            // Only toggle fog to avoid lighting-related errors
            viewer.scene.fog.enabled = enabled;
            
            // Adjust fog density for better 3D depth effect
            if (enabled) {
                viewer.scene.fog.density = 0.0003;
                viewer.scene.fog.screenSpaceErrorFactor = 2.0;
            } else {
                viewer.scene.fog.density = 0.0;
            }
            
            console.log('3D fog effects:', enabled ? 'enabled' : 'disabled');
        }

        /**
         * Toggle 3D terrain on/off
         */
        function toggleTerrain() {
            const toggle = document.getElementById('terrainToggle');
            const enabled = toggle.checked;
            
            if (enabled) {
                // Enable enhanced terrain visualization
                applyRealTerrain();
            } else {
                // Use clean flat terrain
                viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
                viewer.scene.globe.material = undefined;
                viewer.scene.globe.enableLighting = false;
                viewer.scene.globe.terrainExaggeration = 1.0;
            }
            
            console.log('3D terrain:', enabled ? 'enabled' : 'disabled');
        }

        /**
         * Switch base map provider
         */
        function switchBaseMap() {
            const selectElement = document.getElementById('basemapSelect');
            const attributionElement = document.getElementById('basemapAttribution');
            const selectedMap = selectElement.value;
            
            if (baseMaps[selectedMap]) {
                try {
                    // Remove current imagery layers
                    viewer.imageryLayers.removeAll();
                    
                    // Add new imagery provider
                    viewer.imageryLayers.addImageryProvider(baseMaps[selectedMap].provider());
                    
                    // Update attribution
                    attributionElement.textContent = baseMaps[selectedMap].attribution;
                    
                    // Update current base map
                    currentBaseMap = selectedMap;
                    
                    console.log(`Switched to base map: ${selectedMap}`);
                } catch (error) {
                    console.error('Error switching base map:', error);
                    
                    // Fallback to OpenStreetMap on error
                    if (selectedMap !== 'osm') {
                        selectElement.value = 'osm';
                        viewer.imageryLayers.removeAll();
                        viewer.imageryLayers.addImageryProvider(baseMaps['osm'].provider());
                        attributionElement.textContent = baseMaps['osm'].attribution;
                        currentBaseMap = 'osm';
                    }
                }
            }
        }

        /**
         * Initialize drag and drop functionality for 3D models
         */
        function initializeDragAndDrop() {
            let dragCounter = 0;
            
            // Prevent default drag behaviors on document
            document.addEventListener('dragenter', function(e) {
                e.preventDefault();
                dragCounter++;
                
                // Check if dragged item contains files
                if (e.dataTransfer.types.includes('Files')) {
                    dragDropOverlay.style.display = 'flex';
                }
            });
            
            document.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dragCounter--;
                
                if (dragCounter === 0) {
                    dragDropOverlay.style.display = 'none';
                }
            });
            
            document.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            document.addEventListener('drop', function(e) {
                e.preventDefault();
                dragCounter = 0;
                dragDropOverlay.style.display = 'none';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const fileName = file.name.toLowerCase();
                    
                    // Check if it's a 3D model file
                    const formatInfo = check3DFileFormat(file.name);
                    
                    if (formatInfo.isKnown3D) {
                        loadModelAtCameraCenter(file);
                    } else {
                        alert('File not recognized as a 3D model. Supported: .glb, .gltf, .obj, .fbx, .dae, .stl, .ply, .las, .dxf, .usdz');
                    }
                }
            });
            
            // Add Escape key handler to close drag and drop overlay
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && dragDropOverlay.style.display === 'flex') {
                    dragDropOverlay.style.display = 'none';
                    dragCounter = 0;
                }
            });
            
            // Also handle file input for alternative upload method
            modelFileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    loadModelAtCameraCenter(file);
                    // Clear input for future uploads
                    e.target.value = '';
                }
            });
            
            console.log('Drag and drop for 3D models initialized');
        }
        
        /**
         * Toggle Service Loader Panel visibility
         */
        function toggleServiceLoader() {
            const panel = document.getElementById('serviceLoaderPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                updateServiceInputs(); // Initialize with default format
            } else {
                panel.style.display = 'none';
            }
        }
        
        /**
         * Update input fields based on selected service format
         */
        function updateServiceInputs() {
            const format = document.getElementById('serviceFormat').value;
            const geojsonInputs = document.getElementById('geojsonInputs');
            const wmsInputs = document.getElementById('wmsInputs');
            const tilejsonInputs = document.getElementById('tilejsonInputs');
            
            // Hide all input sections
            geojsonInputs.style.display = 'none';
            wmsInputs.style.display = 'none';
            tilejsonInputs.style.display = 'none';
            
            // Show selected format inputs
            switch(format) {
                case 'geojson':
                    geojsonInputs.style.display = 'block';
                    break;
                case 'wms':
                    wmsInputs.style.display = 'block';
                    break;
                case 'tilejson':
                    tilejsonInputs.style.display = 'block';
                    break;
            }
        }
        
        /**
         * Load selected service based on current format
         */
        function loadSelectedService() {
            const format = document.getElementById('serviceFormat').value;
            
            try {
                switch(format) {
                    case 'geojson':
                        loadGeoJsonLayer();
                        break;
                    case 'wms':
                        loadWmsLayer();
                        break;
                    case 'tilejson':
                        loadTileJsonLayer();
                        break;
                    default:
                        showServiceError('Unknown service format selected');
                }
            } catch (error) {
                console.error('Service loading error:', error);
                showServiceError(`Failed to load ${format.toUpperCase()} service: ${error.message}`);
            }
        }
        
        /**
         * Load GeoJSON data from URL
         * Uses Cesium.GeoJsonDataSource.load() with random colors per feature
         */
        function loadGeoJsonLayer() {
            const url = document.getElementById('geojsonUrl').value.trim();
            
            if (!url) {
                showServiceError('Please enter a GeoJSON URL');
                return;
            }
            
            console.log('Loading GeoJSON from:', url);
            
            Cesium.GeoJsonDataSource.load(url, {
                stroke: Cesium.Color.fromRandom({ alpha: 0.8 }),
                fill: Cesium.Color.fromRandom({ alpha: 0.5 }),
                strokeWidth: 2,
                markerSymbol: '?'
            }).then(function(dataSource) {
                // Add to viewer
                viewer.dataSources.add(dataSource);
                
                // Generate layer info
                const layerId = `geojson_${++layerCounter}`;
                const layerName = url.split('/').pop() || `GeoJSON Layer ${layerCounter}`;
                
                // Store layer reference
                activeDataLayers.set(layerId, {
                    id: layerId,
                    name: layerName,
                    type: 'GeoJSON',
                    dataSource: dataSource,
                    visible: true,
                    url: url
                });
                
                // Add click handlers for feature popups
                addGeoJsonClickHandler(dataSource);
                
                // Update UI
                updateActiveLayersList();
                
                // Zoom to data if possible
                try {
                    viewer.flyTo(dataSource);
                } catch (e) {
                    console.warn('Could not zoom to GeoJSON data:', e);
                }
                
                console.log(' GeoJSON layer loaded successfully:', layerName);
                
                // Clear input
                document.getElementById('geojsonUrl').value = '';
                
            }).catch(function(error) {
                console.error('GeoJSON loading failed:', error);
                showServiceError(`Failed to load GeoJSON: ${error.message}`);
            });
        }
        
        /**
         * Add click handler for GeoJSON features to show popups
         */
        function addGeoJsonClickHandler(dataSource) {
            viewer.selectedEntityChanged.addEventListener(function(selectedEntity) {
                if (selectedEntity && dataSource.entities.contains(selectedEntity)) {
                    const properties = selectedEntity.properties;
                    if (properties) {
                        let popupContent = '<h4>Feature Properties:</h4>';
                        
                        for (const propertyName of properties.propertyNames) {
                            const value = properties[propertyName];
                            if (value !== undefined) {
                                popupContent += `<p><strong>${propertyName}:</strong> ${value}</p>`;
                            }
                        }
                        
                        // Create simple popup (can be enhanced with better styling)
                        console.log('Feature clicked:', popupContent);
                    }
                }
            });
        }
        
        /**
         * Load WMS (Web Map Service) as imagery overlay
         * Uses WebMapServiceImageryProvider
         */
        function loadWmsLayer() {
            const url = document.getElementById('wmsUrl').value.trim();
            const layers = document.getElementById('wmsLayers').value.trim();
            const format = document.getElementById('wmsFormat').value;
            
            if (!url || !layers) {
                showServiceError('Please enter WMS URL and layer name(s)');
                return;
            }
            
            console.log('Loading WMS service:', { url, layers, format });
            
            try {
                const wmsProvider = new Cesium.WebMapServiceImageryProvider({
                    url: url,
                    layers: layers,
                    parameters: {
                        format: format,
                        transparent: true,
                        version: '1.3.0'
                    },
                    credit: `WMS: ${url}`
                });
                
                // Add as imagery layer
                const imageryLayer = viewer.imageryLayers.addImageryProvider(wmsProvider);
                
                // Generate layer info
                const layerId = `wms_${++layerCounter}`;
                const layerName = `WMS: ${layers}`;
                
                // Store layer reference
                activeDataLayers.set(layerId, {
                    id: layerId,
                    name: layerName,
                    type: 'WMS',
                    imageryLayer: imageryLayer,
                    visible: true,
                    url: url,
                    layers: layers
                });
                
                // Update UI
                updateActiveLayersList();
                
                console.log(' WMS layer loaded successfully:', layerName);
                
                // Clear inputs
                document.getElementById('wmsUrl').value = '';
                document.getElementById('wmsLayers').value = '';
                
            } catch (error) {
                console.error('WMS loading failed:', error);
                showServiceError(`Failed to load WMS service: ${error.message}`);
            }
        }
        
        /**
         * Load TileJSON service (Mapbox-style raster tiles)
         * Fetches TileJSON spec and creates UrlTemplateImageryProvider
         */
        function loadTileJsonLayer() {
            const url = document.getElementById('tilejsonUrl').value.trim();
            
            if (!url) {
                showServiceError('Please enter a TileJSON URL');
                return;
            }
            
            console.log('Loading TileJSON from:', url);
            
            // Fetch TileJSON specification
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(tileJsonSpec => {
                    if (!tileJsonSpec.tiles || !tileJsonSpec.tiles.length) {
                        throw new Error('Invalid TileJSON: missing tiles array');
                    }
                    
                    // Create imagery provider from TileJSON
                    const tileProvider = new Cesium.UrlTemplateImageryProvider({
                        url: tileJsonSpec.tiles[0], // Use first tile URL template
                        credit: tileJsonSpec.attribution || `TileJSON: ${url}`,
                        minimumLevel: tileJsonSpec.minzoom || 0,
                        maximumLevel: tileJsonSpec.maxzoom || 18
                    });
                    
                    // Add as imagery layer
                    const imageryLayer = viewer.imageryLayers.addImageryProvider(tileProvider);
                    
                    // Generate layer info
                    const layerId = `tilejson_${++layerCounter}`;
                    const layerName = tileJsonSpec.name || `TileJSON Layer ${layerCounter}`;
                    
                    // Store layer reference
                    activeDataLayers.set(layerId, {
                        id: layerId,
                        name: layerName,
                        type: 'TileJSON',
                        imageryLayer: imageryLayer,
                        visible: true,
                        url: url,
                        spec: tileJsonSpec
                    });
                    
                    // Update UI
                    updateActiveLayersList();
                    
                    console.log(' TileJSON layer loaded successfully:', layerName);
                    
                    // Clear input
                    document.getElementById('tilejsonUrl').value = '';
                })
                .catch(error => {
                    console.error('TileJSON loading failed:', error);
                    showServiceError(`Failed to load TileJSON: ${error.message}`);
                });
        }
        
        /**
         * Update the active layers list UI
         */
        function updateActiveLayersList() {
            const listContainer = document.getElementById('activeLayersList');
            
            if (activeDataLayers.size === 0) {
                listContainer.innerHTML = `
                    <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 10px;">
                        No data layers loaded
                    </div>
                `;
                return;
            }
            
            let html = '';
            for (const [layerId, layer] of activeDataLayers) {
                const toggleClass = layer.visible ? '' : 'disabled';
                const toggleText = layer.visible ? 'Hide' : 'Show';
                
                html += `
                    <div class="layer-item">
                        <div class="layer-info">
                            <div class="layer-name">${layer.name}</div>
                            <div class="layer-type">${layer.type}</div>
                        </div>
                        <div class="layer-controls">
                            <button class="layer-toggle-btn ${toggleClass}" onclick="toggleDataLayer('${layerId}')">
                                ${toggleText}
                            </button>
                            <button class="layer-remove-btn" onclick="removeDataLayer('${layerId}')">
                                Remove
                            </button>
                        </div>
                    </div>
                `;
            }
            
            listContainer.innerHTML = html;
        }
        
        /**
         * Toggle visibility of a data layer
         */
        function toggleDataLayer(layerId) {
            const layer = activeDataLayers.get(layerId);
            if (!layer) return;
            
            layer.visible = !layer.visible;
            
            // Toggle visibility based on layer type
            if (layer.dataSource) {
                // GeoJSON data source
                layer.dataSource.show = layer.visible;
            } else if (layer.imageryLayer) {
                // WMS/TileJSON imagery layer
                layer.imageryLayer.show = layer.visible;
            }
            
            // Update UI
            updateActiveLayersList();
            
            console.log(`Layer ${layer.name} ${layer.visible ? 'shown' : 'hidden'}`);
        }
        
        /**
         * Remove a data layer completely
         */
        function removeDataLayer(layerId) {
            const layer = activeDataLayers.get(layerId);
            if (!layer) return;
            
            // Remove from viewer based on layer type
            if (layer.dataSource) {
                // GeoJSON data source
                viewer.dataSources.remove(layer.dataSource);
            } else if (layer.imageryLayer) {
                // WMS/TileJSON imagery layer
                viewer.imageryLayers.remove(layer.imageryLayer);
            }
            
            // Remove from active layers
            activeDataLayers.delete(layerId);
            
            // Update UI
            updateActiveLayersList();
            
            console.log(`Layer ${layer.name} removed`);
        }
        
        /**
         * Show user-friendly error message
         */
        function showServiceError(message) {
            // Create simple error modal
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(231, 76, 60, 0.95);
                color: white;
                padding: 20px;
                border-radius: 8px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                text-align: center;
                max-width: 400px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            errorDiv.innerHTML = `
                <h3 style="margin: 0 0 10px 0;">Service Loading Error</h3>
                <p style="margin: 0 0 15px 0;">${message}</p>
                <button onclick="this.parentElement.remove()" style="background: white; color: #e74c3c; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
                    OK
                </button>
            `;
            document.body.appendChild(errorDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentElement) {
                    errorDiv.remove();
                }
            }, 5000);
        }
        
        console.log(' Service Loader system initialized');

        /**
         * Service Loader System
         * 
         * Modular system for loading external geospatial data services
         * Supports: GeoJSON, WMS, and TileJSON formats
         */
        
        // Active data layers management
        let activeDataLayers = new Map();
        let layerCounter = 0;
        
        /**
         * Toggle Service Loader Panel visibility
         */
        function toggleServiceLoader() {
            const panel = document.getElementById('serviceLoaderPanel');
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                updateServiceInputs(); // Initialize with default format
            } else {
                panel.style.display = 'none';
            }
        }
        
        /**
         * Update input fields based on selected service format
         */
        function updateServiceInputs() {
            const format = document.getElementById('serviceFormat').value;
            const geojsonInputs = document.getElementById('geojsonInputs');
            const wmsInputs = document.getElementById('wmsInputs');
            const tilejsonInputs = document.getElementById('tilejsonInputs');
            
            // Hide all input sections
            geojsonInputs.style.display = 'none';
            wmsInputs.style.display = 'none';
            tilejsonInputs.style.display = 'none';
            
            // Show selected format inputs
            switch(format) {
                case 'geojson':
                    geojsonInputs.style.display = 'block';
                    break;
                case 'wms':
                    wmsInputs.style.display = 'block';
                    break;
                case 'tilejson':
                    tilejsonInputs.style.display = 'block';
                    break;
            }
        }
        
        /**
         * Load selected service based on current format
         */
        function loadSelectedService() {
            const format = document.getElementById('serviceFormat').value;
            
            try {
                switch(format) {
                    case 'geojson':
                        loadGeoJsonLayer();
                        break;
                    case 'wms':
                        loadWmsLayer();
                        break;
                    case 'tilejson':
                        loadTileJsonLayer();
                        break;
                    default:
                        showServiceError('Unknown service format selected');
                }
            } catch (error) {
                console.error('Service loading error:', error);
                showServiceError(`Failed to load ${format.toUpperCase()} service: ${error.message}`);
            }
        }
        
        /**
         * Load GeoJSON data from URL
         * Uses Cesium.GeoJsonDataSource.load() with random colors per feature
         */
        function loadGeoJsonLayer() {
            const url = document.getElementById('geojsonUrl').value.trim();
            
            if (!url) {
                showServiceError('Please enter a GeoJSON URL');
                return;
            }
            
            console.log('Loading GeoJSON from:', url);
            
            Cesium.GeoJsonDataSource.load(url, {
                stroke: Cesium.Color.fromRandom({ alpha: 0.8 }),
                fill: Cesium.Color.fromRandom({ alpha: 0.5 }),
                strokeWidth: 2,
                markerSymbol: '?'
            }).then(function(dataSource) {
                // Add to viewer
                viewer.dataSources.add(dataSource);
                
                // Generate layer info
                const layerId = `geojson_${++layerCounter}`;
                const layerName = url.split('/').pop() || `GeoJSON Layer ${layerCounter}`;
                
                // Store layer reference
                activeDataLayers.set(layerId, {
                    id: layerId,
                    name: layerName,
                    type: 'GeoJSON',
                    dataSource: dataSource,
                    visible: true,
                    url: url
                });
                
                // Add click handlers for feature popups
                addGeoJsonClickHandler(dataSource);
                
                // Update UI
                updateActiveLayersList();
                
                // Zoom to data if possible
                try {
                    viewer.flyTo(dataSource);
                } catch (e) {
                    console.warn('Could not zoom to GeoJSON data:', e);
                }
                
                console.log(' GeoJSON layer loaded successfully:', layerName);
                
                // Clear input
                document.getElementById('geojsonUrl').value = '';
                
            }).catch(function(error) {
                console.error('GeoJSON loading failed:', error);
                showServiceError(`Failed to load GeoJSON: ${error.message}`);
            });
        }
        
        /**
         * Add click handler for GeoJSON features to show popups
         */
        function addGeoJsonClickHandler(dataSource) {
            viewer.selectedEntityChanged.addEventListener(function(selectedEntity) {
                if (selectedEntity && dataSource.entities.contains(selectedEntity)) {
                    const properties = selectedEntity.properties;
                    if (properties) {
                        let popupContent = '<h4>Feature Properties:</h4>';
                        
                        for (const propertyName of properties.propertyNames) {
                            const value = properties[propertyName];
                            if (value !== undefined) {
                                popupContent += `<p><strong>${propertyName}:</strong> ${value}</p>`;
                            }
                        }
                        
                        // Create simple popup (can be enhanced with better styling)
                        console.log('Feature clicked:', popupContent);
                    }
                }
            });
        }
        
        /**
         * Load WMS (Web Map Service) as imagery overlay
         * Uses WebMapServiceImageryProvider
         */
        function loadWmsLayer() {
            const url = document.getElementById('wmsUrl').value.trim();
            const layers = document.getElementById('wmsLayers').value.trim();
            const format = document.getElementById('wmsFormat').value;
            
            if (!url || !layers) {
                showServiceError('Please enter WMS URL and layer name(s)');
                return;
            }
            
            console.log('Loading WMS service:', { url, layers, format });
            
            try {
                const wmsProvider = new Cesium.WebMapServiceImageryProvider({
                    url: url,
                    layers: layers,
                    parameters: {
                        format: format,
                        transparent: true,
                        version: '1.3.0'
                    },
                    credit: `WMS: ${url}`
                });
                
                // Add as imagery layer
                const imageryLayer = viewer.imageryLayers.addImageryProvider(wmsProvider);
                
                // Generate layer info
                const layerId = `wms_${++layerCounter}`;
                const layerName = `WMS: ${layers}`;
                
                // Store layer reference
                activeDataLayers.set(layerId, {
                    id: layerId,
                    name: layerName,
                    type: 'WMS',
                    imageryLayer: imageryLayer,
                    visible: true,
                    url: url,
                    layers: layers
                });
                
                // Update UI
                updateActiveLayersList();
                
                console.log(' WMS layer loaded successfully:', layerName);
                
                // Clear inputs
                document.getElementById('wmsUrl').value = '';
                document.getElementById('wmsLayers').value = '';
                
            } catch (error) {
                console.error('WMS loading failed:', error);
                showServiceError(`Failed to load WMS service: ${error.message}`);
            }
        }
        
        /**
         * Load TileJSON service (Mapbox-style raster tiles)
         * Fetches TileJSON spec and creates UrlTemplateImageryProvider
         */
        function loadTileJsonLayer() {
            const url = document.getElementById('tilejsonUrl').value.trim();
            
            if (!url) {
                showServiceError('Please enter a TileJSON URL');
                return;
            }
            
            console.log('Loading TileJSON from:', url);
            
            // Fetch TileJSON specification
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(tileJsonSpec => {
                    if (!tileJsonSpec.tiles || !tileJsonSpec.tiles.length) {
                        throw new Error('Invalid TileJSON: missing tiles array');
                    }
                    
                    // Create imagery provider from TileJSON
                    const tileProvider = new Cesium.UrlTemplateImageryProvider({
                        url: tileJsonSpec.tiles[0], // Use first tile URL template
                        credit: tileJsonSpec.attribution || `TileJSON: ${url}`,
                        minimumLevel: tileJsonSpec.minzoom || 0,
                        maximumLevel: tileJsonSpec.maxzoom || 18
                    });
                    
                    // Add as imagery layer
                    const imageryLayer = viewer.imageryLayers.addImageryProvider(tileProvider);
                    
                    // Generate layer info
                    const layerId = `tilejson_${++layerCounter}`;
                    const layerName = tileJsonSpec.name || `TileJSON Layer ${layerCounter}`;
                    
                    // Store layer reference
                    activeDataLayers.set(layerId, {
                        id: layerId,
                        name: layerName,
                        type: 'TileJSON',
                        imageryLayer: imageryLayer,
                        visible: true,
                        url: url,
                        spec: tileJsonSpec
                    });
                    
                    // Update UI
                    updateActiveLayersList();
                    
                    console.log(' TileJSON layer loaded successfully:', layerName);
                    
                    // Clear input
                    document.getElementById('tilejsonUrl').value = '';
                })
                .catch(error => {
                    console.error('TileJSON loading failed:', error);
                    showServiceError(`Failed to load TileJSON: ${error.message}`);
                });
        }
        
        /**
         * Update the active layers list UI
         */
        function updateActiveLayersList() {
            const listContainer = document.getElementById('activeLayersList');
            
            if (activeDataLayers.size === 0) {
                listContainer.innerHTML = `
                    <div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 10px;">
                        No data layers loaded
                    </div>
                `;
                return;
            }
            
            let html = '';
            for (const [layerId, layer] of activeDataLayers) {
                const toggleClass = layer.visible ? '' : 'disabled';
                const toggleText = layer.visible ? 'Hide' : 'Show';
                
                html += `
                    <div class="layer-item">
                        <div class="layer-info">
                            <div class="layer-name">${layer.name}</div>
                            <div class="layer-type">${layer.type}</div>
                        </div>
                        <div class="layer-controls">
                            <button class="layer-toggle-btn ${toggleClass}" onclick="toggleDataLayer('${layerId}')">
                                ${toggleText}
                            </button>
                            <button class="layer-remove-btn" onclick="removeDataLayer('${layerId}')">
                                Remove
                            </button>
                        </div>
                    </div>
                `;
            }
            
            listContainer.innerHTML = html;
        }
        
        /**
         * Toggle visibility of a data layer
         */
        function toggleDataLayer(layerId) {
            const layer = activeDataLayers.get(layerId);
            if (!layer) return;
            
            layer.visible = !layer.visible;
            
            // Toggle visibility based on layer type
            if (layer.dataSource) {
                // GeoJSON data source
                layer.dataSource.show = layer.visible;
            } else if (layer.imageryLayer) {
                // WMS/TileJSON imagery layer
                layer.imageryLayer.show = layer.visible;
            }
            
            // Update UI
            updateActiveLayersList();
            
            console.log(`Layer ${layer.name} ${layer.visible ? 'shown' : 'hidden'}`);
        }
        
        /**
         * Remove a data layer completely
         */
        function removeDataLayer(layerId) {
            const layer = activeDataLayers.get(layerId);
            if (!layer) return;
            
            // Remove from viewer based on layer type
            if (layer.dataSource) {
                // GeoJSON data source
                viewer.dataSources.remove(layer.dataSource);
            } else if (layer.imageryLayer) {
                // WMS/TileJSON imagery layer
                viewer.imageryLayers.remove(layer.imageryLayer);
            }
            
            // Remove from active layers
            activeDataLayers.delete(layerId);
            
            // Update UI
            updateActiveLayersList();
            
            console.log(`Layer ${layer.name} removed`);
        }
        
        /**
         * Show user-friendly error message
         */
        function showServiceError(message) {
            // Create simple error modal
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(231, 76, 60, 0.95);
                color: white;
                padding: 20px;
                border-radius: 8px;
                z-index: 10001;
                font-family: Arial, sans-serif;
                text-align: center;
                max-width: 400px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            errorDiv.innerHTML = `
                <h3 style="margin: 0 0 10px 0;">Service Loading Error</h3>
                <p style="margin: 0 0 15px 0;">${message}</p>
                <button onclick="this.parentElement.remove()" style="background: white; color: #e74c3c; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
                    OK
                </button>
            `;
            document.body.appendChild(errorDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentElement) {
                    errorDiv.remove();
                }
            }, 5000);
        }
        
        console.log(' Service Loader system initialized');
        
        /**
         * Swiss-style Sidebar Functions
         */
        
        // Toggle sidebar visibility with floating menu button
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const floatingButton = document.getElementById('floatingMenuButton');
            
            if (!sidebar) {
                console.error('Sidebar element not found');
                return;
            }
            
            const isCollapsed = sidebar.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expand sidebar
                sidebar.classList.remove('collapsed');
                sidebar.style.transform = 'translateX(0)';
                if (floatingButton) {
                    floatingButton.style.display = 'none';
                }
                console.log('Sidebar expanded');
            } else {
                // Collapse sidebar
                sidebar.classList.add('collapsed');
                sidebar.style.transform = 'translateX(-100%)';
                setTimeout(() => {
                    if (floatingButton) {
                        floatingButton.style.display = 'flex';
                    }
                }, 300);
                console.log('Sidebar collapsed');
            }
            
            // Update toggle button text
            const toggleBtn = sidebar.querySelector('.sidebar-toggle');
            if (toggleBtn) {
                toggleBtn.innerHTML = sidebar.classList.contains('collapsed') ? 
                    '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>' : 
                    '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
            }
        }
        
        // Toggle section collapse/expand
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            if (!content) return;
            
            const header = content.previousElementSibling;
            if (!header) return;
            
            const arrow = header.querySelector('span:last-child');
            if (!arrow) return;
            
            content.classList.toggle('collapsed');
            arrow.innerHTML = content.classList.contains('collapsed') ? 
                '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9,18 15,12 9,6"/></svg>' : 
                '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>';
        }
        
        // Show sample models function (placeholder)
        function showSampleModels() {
            alert('Sample 3D models feature - placeholder for future implementation');
        }

        /**
         * Toggle Right Panel Visibility
         */
        function toggleRightPanel() {
            const rightPanel = document.getElementById('rightPanel');
            if (rightPanel) {
                rightPanel.classList.toggle('collapsed');
                const isCollapsed = rightPanel.classList.contains('collapsed');
                
                // Update icon visibility
                const hamburgerIcon = rightPanel.querySelector('.hamburger-icon');
                const closeIcon = rightPanel.querySelector('.close-icon');
                
                if (isCollapsed) {
                    // Panel is closed - show hamburger icon
                    if (hamburgerIcon) hamburgerIcon.style.display = 'block';
                    if (closeIcon) closeIcon.style.display = 'none';
                } else {
                    // Panel is open - show X icon
                    if (hamburgerIcon) hamburgerIcon.style.display = 'none';
                    if (closeIcon) closeIcon.style.display = 'block';
                }
                
                console.log(' Right panel', isCollapsed ? 'collapsed' : 'expanded');
            }
        }

        // New functionality functions
        function resetNorth() {
            if (viewer && viewer.camera) {
                // Reset to north orientation with smooth animation
                viewer.camera.setView({
                    orientation: {
                        heading: 0, // North
                        pitch: viewer.camera.pitch, // Keep current pitch
                        roll: 0 // Level the view
                    }
                });
                
                // Add visual feedback
                const northArrow = document.getElementById('northArrow');
                if (northArrow) {
                    northArrow.style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        northArrow.style.transform = 'scale(1)';
                    }, 200);
                }
                
                console.log(' Reset to North orientation');
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                        } else {
                document.exitFullscreen();
            }
            console.log(' Toggled fullscreen');
        }

        function toggleTheme() {
            const body = document.body;
            const isDark = body.classList.contains('dark-theme');
            body.classList.toggle('dark-theme', !isDark);
            console.log(' Toggled theme:', !isDark ? 'dark' : 'light');
        }

        function toggleSearch() {
            // Toggle top search bar visibility
            const searchContainer = document.querySelector('.top-search-container');
            const searchTool = document.getElementById('searchTool');
            
            if (searchContainer.classList.contains('active')) {
                // Hide search bar
                searchContainer.classList.remove('active');
                searchTool.classList.remove('active');
                console.log(' Search bar hidden');
            } else {
                // Show search bar
                searchContainer.classList.add('active');
                searchTool.classList.add('active');
                // Focus on the search input
                const searchInput = document.getElementById('topSearchInput');
                if (searchInput) {
                    searchInput.focus();
                }
                console.log(' Search bar shown');
            }
        }

        function toggleForestLayer() {
            // Toggle forest layer
            console.log(' Forest layer toggled');
        }

        function toggleWaterLayer() {
            // Toggle water layer
            console.log(' Water layer toggled');
        }

        function toggleTerrainLayer() {
            // Toggle terrain layer
            console.log(' Terrain layer toggled');
        }

        function toggleFlyMode() {
            // Toggle fly mode
            console.log(' Fly mode toggled');
        }

        function toggleGlobeView() {
            // Toggle between globe and flat view
            console.log(' Globe view toggled');
        }

        function toggleLayersPanel() {
            const layersPanel = document.getElementById('layersPanel');
            const layersTool = document.getElementById('layersTool');
            
            if (layersPanel.style.display === 'none') {
                // Show layers panel
                layersPanel.style.display = 'block';
                layersTool.classList.add('active');
                console.log(' Layers panel opened');
            } else {
                // Hide layers panel
                layersPanel.style.display = 'none';
                layersTool.classList.remove('active');
                console.log(' Layers panel closed');
            }
        }

        function selectBaseMap(mapType) {
            // Update visual selection
            const cards = document.querySelectorAll('.base-map-card');
            
            // Remove all selections
            cards.forEach(card => card.classList.remove('selected'));
            
            // Select the clicked card
            const selectedCard = document.querySelector(`[data-value="${mapType}"]`);
            
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }
            
            // Map the UI values to actual base map keys
            const mapTypeMapping = {
                'none': 'none',
                'openstreetmap': 'osm',
                'opentopomap': 'otm',
                'monochrome': 'cartodb-positron',
                'esri_world': 'esri-imagery'
            };
            
            const actualMapType = mapTypeMapping[mapType] || 'osm';
            
            // Switch the actual base map using the real switching logic
            if (actualMapType === 'none') {
                // Remove all imagery layers for "no background"
                viewer.imageryLayers.removeAll();
                console.log(' Removed all base maps');
            } else if (baseMaps[actualMapType]) {
                try {
                    // Remove current imagery layers
                    viewer.imageryLayers.removeAll();
                    
                    // Add new imagery provider
                    viewer.imageryLayers.addImageryProvider(baseMaps[actualMapType].provider());
                    
                    // Update attribution
                    const attributionElement = document.querySelector('.cesium-credit-textContainer');
                    if (attributionElement) {
                        attributionElement.innerHTML = baseMaps[actualMapType].attribution;
                    }
                    
                    // Update current base map
                    currentBaseMap = actualMapType;
                    
                    console.log(` Switched to base map: ${actualMapType}`);
                } catch (error) {
                    console.error('Error switching base map:', error);
                    
                    // Fallback to OpenStreetMap on error
                    viewer.imageryLayers.removeAll();
                    viewer.imageryLayers.addImageryProvider(baseMaps['osm'].provider());
                    const attributionElement = document.querySelector('.cesium-credit-textContainer');
                    if (attributionElement) {
                        attributionElement.innerHTML = baseMaps['osm'].attribution;
                    }
                    currentBaseMap = 'osm';
                    
                    // Update visual selection to OSM
                    const osmCard = document.querySelector('[data-value="openstreetmap"]');
                    if (osmCard) {
                        cards.forEach(card => card.classList.remove('selected'));
                        osmCard.classList.add('selected');
                    }
                }
            }
            
            // Keep panel open - no auto-close
            
            console.log(` Base map switched to: ${mapType} (${actualMapType})`);
        }

        function showMoreMaps() {
            // Placeholder for showing additional map options
            console.log(' More maps option clicked');
            alert('Additional map options coming soon!');
        }

        function shareCurrentView() {
            const url = window.location.href;
            if (navigator.share) {
                navigator.share({
                    title: 'MyEarth View',
                    url: url
                });
            } else {
                navigator.clipboard.writeText(url);
                alert('View URL copied to clipboard!');
            }
            console.log(' Shared current view');
        }

        function toggleBookmarks() {
            // Toggle bookmarks panel
            console.log(' Bookmarks toggled');
        }

        function openAboutPanel() {
            // Open about panel
            console.log(' About panel opened');
        }

        function openGitHub() {
            window.open('https://github.com/your-repo/myearth', '_blank');
            console.log(' GitHub repository opened');
        }

        function toggleInfoPanel() {
            // Toggle info panel
            console.log(' Info panel toggled');
        }

        function openContactEmail() {
            // Open email client with support email
            window.open('mailto:support@myearth.app', '_blank');
            console.log(' Contact email opened');
        }

        function undoAction() {
            // Undo last action
            console.log(' Undo action');
        }

        function redoAction() {
            // Redo last action
            console.log(' Redo action');
        }



        /**
         * Switch Base Map
         */
        function switchBaseMap(mapType) {
            const baseMapSelector = document.getElementById('baseMapSelector');
            if (baseMapSelector) {
                baseMapSelector.value = mapType;
                baseMapSelector.dispatchEvent(new Event('change'));
            }
        }

        /**
         * Reset View to North
         */
        function resetViewToNorth() {
            if (viewer) {
                viewer.scene.camera.setView({
                    destination: viewer.scene.camera.position,
                    orientation: {
                        heading: 0.0,
                        pitch: viewer.scene.camera.pitch,
                        roll: 0.0
                    }
                });
            }
        }

        /**
         * Zoom Functions
         */
        function zoomIn() {
            if (viewer) {
                viewer.scene.camera.zoomIn(viewer.scene.camera.getMagnitude() * 0.3);
            }
        }

        function zoomOut() {
            if (viewer) {
                viewer.scene.camera.zoomOut(viewer.scene.camera.getMagnitude() * 0.3);
            }
        }

        function resetView() {
            if (viewer) {
                viewer.scene.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(0, 0, 15000000)
                });
            }
        }

        function refreshMap() {
            if (viewer) {
                viewer.scene.requestRender();
            }
        }

        function toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        }

        function toggleSearchPanel() {
            const searchSection = document.getElementById('searchSection');
            const searchTool = document.getElementById('searchTool');
            
            if (searchSection) {
                searchSection.classList.toggle('collapsed');
                const arrow = searchSection.previousElementSibling.querySelector('span:last-child');
                if (arrow) {
                    arrow.textContent = searchSection.classList.contains('collapsed') ? '' : '';
                }
                
                // Toggle tool activation state
                if (searchTool) {
                    searchTool.classList.toggle('active', !searchSection.classList.contains('collapsed'));
                }
                
                console.log('Search panel', searchSection.classList.contains('collapsed') ? 'deactivated' : 'activated');
            }
        }

        function toggleBaseMapPanel() {
            const baseMapSection = document.getElementById('baseMapSection');
            if (baseMapSection) {
                baseMapSection.classList.toggle('collapsed');
                const arrow = baseMapSection.previousElementSibling.querySelector('span:last-child');
                if (arrow) {
                    arrow.textContent = baseMapSection.classList.contains('collapsed') ? '' : '';
                }
                console.log('Base map panel', baseMapSection.classList.contains('collapsed') ? 'deactivated' : 'activated');
            }
        }

        function toggleLayerPanel() {
            const layerSection = document.getElementById('layerSection');
            const layerTool = document.getElementById('layerTool');
            
            if (layerSection) {
                layerSection.classList.toggle('collapsed');
                const arrow = layerSection.previousElementSibling.querySelector('span:last-child');
                if (arrow) {
                    arrow.textContent = layerSection.classList.contains('collapsed') ? '' : '';
                }
                
                // Toggle tool activation state
                if (layerTool) {
                    layerTool.classList.toggle('active', !layerSection.classList.contains('collapsed'));
                }
                
                console.log('Layer panel', layerSection.classList.contains('collapsed') ? 'deactivated' : 'activated');
            }
        }

        function toggleMarkerPanel() {
            const markerControls = document.getElementById('markerControls');
            const markerTool = document.getElementById('markerTool');
            
            if (markerControls.style.display === 'none' || markerControls.style.display === '') {
                // Close measurement panel if open
                const measurementControls = document.getElementById('measurementControls');
                if (measurementControls.style.display === 'block') {
                    measurementControls.style.display = 'none';
                    const measurementToolEl = document.getElementById('measurementTool');
                    if (measurementToolEl) measurementToolEl.classList.remove('active');
                    stopMeasurement(); // Ensure measurement click handler is removed
                }
                
                markerControls.style.display = 'block';
                if (markerTool) markerTool.classList.add('active');
                enableMarkerMode();
                console.log('Marker panel activated');
            } else {
                markerControls.style.display = 'none';
                if (markerTool) markerTool.classList.remove('active');
                disableMarkerMode();
                console.log('Marker panel deactivated');
            }
        }

        function enableMarkerMode() {
            // Enable click handler for marker placement
            if (viewer) {
                // First ensure any existing handlers are removed
                viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
                
                // Then set up new handler
                viewer.markerClickHandler = viewer.cesiumWidget.screenSpaceEventHandler.setInputAction(function(event) {
                    // Only place markers if marker panel is actually open
                    const markerControls = document.getElementById('markerControls');
                    if (!markerControls || markerControls.style.display !== 'block') {
                        return;
                    }
                    
                    const pickedPosition = viewer.camera.pickEllipsoid(event.position, viewer.scene.globe.ellipsoid);
                    if (pickedPosition) {
                        const cartographic = Cesium.Cartographic.fromCartesian(pickedPosition);
                        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                        placeMarker(longitude, latitude);
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
            }
        }

        function disableMarkerMode() {
            // Remove click handler for marker placement
            if (viewer) {
                // Always remove any existing click handlers to ensure clean state
                viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
                viewer.markerClickHandler = null;
            }
        }

        function placeMarker(longitude, latitude) {
            const markerCount = markers.size + 1;
            const color = availableColors[markerCount % availableColors.length];
            const label = `Marker ${markerCount}`;
            
            const marker = createMarker(longitude, latitude, label, color);
            updatePointsUI(); // Update the correct UI
        }

        function updateMarkersList() {
            const pointsList = document.getElementById('pointsList');
            if (!pointsList) return;
            
            if (markers.size === 0) {
                pointsList.innerHTML = '<div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px;">No markers placed</div>';
                return;
            }
            
            let listHTML = '';
            markers.forEach((marker, id) => {
                listHTML += `
                    <div class="marker-item" style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span style="font-size: 11px; color: white;">${marker.label}</span>
                        <button onclick="removeMarker('${id}')" style="background: #e74c3c; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 9px; cursor: pointer;">Remove</button>
                    </div>
                `;
            });
            pointsList.innerHTML = listHTML;
        }

        function removeMarker(markerId) {
            const marker = markers.get(markerId);
            if (marker) {
                viewer.entities.remove(marker.entity);
                markers.delete(markerId);
                updatePointsUI(); // Update the correct UI
            }
        }
        
        function updateMarkerLabel(markerId, newLabel) {
            const marker = markers.get(markerId);
            if (marker && newLabel && newLabel.trim()) {
                // Update the stored marker data
                marker.label = newLabel.trim();
                
                // Update the entity's label
                if (marker.entity && marker.entity.label) {
                    marker.entity.label.text = newLabel.trim();
                }
                
                console.log(`Marker ${markerId} renamed to: ${newLabel.trim()}`);
            }
        }

        function toggleModelPanel() {
            const modelSection = document.getElementById('modelSection');
            const modelTool = document.getElementById('modelTool');
            
            if (modelSection) {
                modelSection.classList.toggle('collapsed');
                const arrow = modelSection.previousElementSibling.querySelector('span:last-child');
                if (arrow) {
                    arrow.textContent = modelSection.classList.contains('collapsed') ? '' : '';
                }
                
                // Toggle tool activation state
                if (modelTool) {
                    modelTool.classList.toggle('active', !modelSection.classList.contains('collapsed'));
                }
                
                console.log('Model panel', modelSection.classList.contains('collapsed') ? 'deactivated' : 'activated');
            }
        }

        function toggleSettingsPanel() {
            const settingsSection = document.getElementById('settingsSection');
            const settingsTool = document.getElementById('settingsTool');
            
            if (settingsSection) {
                settingsSection.classList.toggle('collapsed');
                const arrow = settingsSection.previousElementSibling.querySelector('span:last-child');
                if (arrow) {
                    arrow.textContent = settingsSection.classList.contains('collapsed') ? '' : '';
                }
                
                // Toggle tool activation state
                if (settingsTool) {
                    settingsTool.classList.toggle('active', !settingsSection.classList.contains('collapsed'));
                }
                
                console.log('Settings panel', settingsSection.classList.contains('collapsed') ? 'deactivated' : 'activated');
            }
        }

        function resetToHomeView() {
            if (viewer) {
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(10, 40, 8000000),
                    orientation: {
                        heading: Cesium.Math.toRadians(0),
                        pitch: Cesium.Math.toRadians(-90), // Straight down view
                        roll: 0.0
                    }
                });
                console.log(' View reset to home position (Europe/North Africa) - looking down');
            }
        }

        function toggleHelpPanel() {
            // Create help overlay if it doesn't exist
            let helpOverlay = document.getElementById('helpOverlay');
            if (!helpOverlay) {
                helpOverlay = document.createElement('div');
                helpOverlay.id = 'helpOverlay';
                helpOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                helpOverlay.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 8px; max-width: 500px; position: relative;">
                        <button onclick="toggleHelpPanel()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 20px; cursor: pointer;"></button>
                        <h3 style="margin-top: 0; color: #333;"> CesiumJS Globe Viewer Help</h3>
                        <div style="color: #666; line-height: 1.6;">
                            <p><strong>Navigation:</strong></p>
                            <ul>
                                <li>Left click + drag to rotate</li>
                                <li>Right click + drag to pan</li>
                                <li>Mouse wheel to zoom</li>
                                <li>Middle click + drag to rotate around target</li>
                            </ul>
                            <p><strong>Right Panel Tools:</strong></p>
                            <ul>
                                <li>North arrow - Click to reset north</li>
                                <li>Search - Find locations</li>
                                <li>Measurement - Measure distances</li>
                                <li>Markers - Place point markers</li>
                                <li>Home - Return to global view</li>
                            </ul>
                            <p><strong>Base Maps:</strong> Switch between different map styles</p>
                            <p><strong>Data Layers:</strong> Toggle environmental data overlays</p>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(helpOverlay);
            }
            
            helpOverlay.style.display = helpOverlay.style.display === 'none' ? 'flex' : 'none';
            
            // Toggle help tool activation state
            const helpTool = document.getElementById('helpTool');
            if (helpTool) {
                helpTool.classList.toggle('active', helpOverlay.style.display === 'flex');
            }
        }

        /**
         * Night Mode Theme Toggle Functionality
         */
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            const isDark = body.hasAttribute('data-theme');
            
            if (isDark) {
                body.removeAttribute('data-theme');
                themeIcon.textContent = '';
                localStorage.setItem('theme', 'light');
                console.log(' Light theme enabled');
            } else {
                body.setAttribute('data-theme', 'dark');
                themeIcon.textContent = '';
                localStorage.setItem('theme', 'dark');
                console.log(' Dark theme enabled');
            }
        }



        /**
         * Initialize theme based on saved preference
         */
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.getElementById('themeIcon');
            
            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                if (themeIcon) themeIcon.textContent = '';
                console.log(' Dark theme restored from preferences');
            } else {
                if (themeIcon) themeIcon.textContent = '';
                console.log(' Light theme initialized');
            }
        }
        
        // Switch base map provider from integrated selector
        function switchBaseMap() {
            const selector = document.getElementById('baseMapSelector');
            const selectedProvider = selector.value;
            
            // Remove current imagery provider
            if (viewer.imageryLayers.length > 0) {
                viewer.imageryLayers.removeAll();
            }
            
            // Add new imagery provider based on selection
            let imageryProvider;
            
            switch(selectedProvider) {
                case 'openstreetmap':
                    imageryProvider = new Cesium.UrlTemplateImageryProvider({
                        url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                        subdomains: ['a', 'b', 'c'],
                        credit: ' OpenStreetMap contributors'
                    });
                    break;
                    

                    
                case 'opentopomap':
                    imageryProvider = new Cesium.UrlTemplateImageryProvider({
                        url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
                        subdomains: ['a', 'b', 'c'],
                        credit: ' OpenTopoMap, OpenStreetMap contributors'
                    });
                    break;
                    
                case 'monochrome':
                    imageryProvider = new Cesium.UrlTemplateImageryProvider({
                        url: 'https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png',
                        subdomains: ['a', 'b', 'c', 'd'],
                        credit: ' OpenStreetMap contributors  CARTO'
                    });
                    break;
                    
                case 'dark_mode':
                    imageryProvider = new Cesium.UrlTemplateImageryProvider({
                        url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                        subdomains: ['a', 'b', 'c', 'd'],
                        credit: ' OpenStreetMap contributors  CARTO'
                    });
                    break;
                    
                case 'cartodb_positron':
                    imageryProvider = new Cesium.UrlTemplateImageryProvider({
                        url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                        subdomains: ['a', 'b', 'c', 'd'],
                        credit: ' OpenStreetMap contributors  CARTO'
                    });
                    break;
                    
                case 'esri_world':
                    imageryProvider = new Cesium.UrlTemplateImageryProvider({
                        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                        credit: 'Tiles  Esri  Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                    });
                    break;
                    
                default:
                    imageryProvider = new Cesium.UrlTemplateImageryProvider({
                        url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                        subdomains: ['a', 'b', 'c'],
                        credit: ' OpenStreetMap contributors'
                    });
            }
            
            // Add the new imagery layer with error handling
            try {
                viewer.imageryLayers.addImageryProvider(imageryProvider);
                console.log(` Switched to ${selectedProvider} base map provider`);
            } catch (error) {
                console.error(`Failed to load ${selectedProvider} base map:`, error);
                
                // Fallback to OpenStreetMap on error
                const fallbackProvider = new Cesium.UrlTemplateImageryProvider({
                    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    subdomains: ['a', 'b', 'c'],
                    credit: ' OpenStreetMap contributors'
                });
                viewer.imageryLayers.addImageryProvider(fallbackProvider);
                console.log(' Fallback to OpenStreetMap base map');
                
                // Reset selector to OpenStreetMap
                selector.value = 'openstreetmap';
            }
        }
        
        // Initialize UI panels and bottom band on page load
        document.addEventListener('DOMContentLoaded', function() {
            const leftPanel = document.getElementById('leftPanel');
            const rightPanel = document.getElementById('rightPanel');
            const cesiumContainer = document.getElementById('cesiumContainer');
            // Start with both panels collapsed by default
            if (leftPanel) {
                leftPanel.classList.add('collapsed');
                cesiumContainer.classList.remove('with-left-panel');
            }
            
            // Ensure right panel is visible
            if (rightPanel) {
                rightPanel.classList.remove('collapsed');
            }
            
            // Initialize bottom band updates
            setInterval(updateBottomBand, 1000);
            
            // Toggle functions for panel controls are defined later
        
        // ========================================
        // RIGHT PANEL TOGGLE FUNCTION
        // ========================================
        // 
        // RIGHT PANEL TOGGLE FUNCTION
        // - Function: toggleRightPanel()
        // - Element: rightPanel (tool toolbar)
        // - Toggle Button: panel-toggle-btn (hamburger menu)
        // - Purpose: Expands/collapses the right tool toolbar
        // - Behavior: 
        //   * When collapsed: Shows only toggle button
        //   * When expanded: Shows full 2-column grid of 20 tools
        // - CSS Classes: 'collapsed'
        // - Console: Logs panel state changes
        // - Default: Panel is visible by default
        //
        function toggleRightPanel() {
            const rightPanel = document.getElementById('rightPanel');
            if (rightPanel) {
                rightPanel.classList.toggle('collapsed');
                const isCollapsed = rightPanel.classList.contains('collapsed');
                console.log(isCollapsed ? 'Right panel collapsed' : 'Right panel expanded');
            }
        }
        
        // Make functions globally available
        window.toggleLeftPanel = toggleLeftPanel;
        window.toggleRightPanel = toggleRightPanel;
        
        console.log(' Menu system initialized - left panel collapsed, right panel visible by default');
        });

        // Update bottom band information
        function updateBottomBand() {
            const coordinatesInfo = document.getElementById('coordinatesInfo');
            const activeLayersInfo = document.getElementById('activeLayersInfo');
            const attributionInfo = document.getElementById('attributionInfo');
            
            if (viewer && viewer.scene) {
                // Update coordinates from center of screen
                try {
                    const canvas = viewer.canvas;
                    const centerX = canvas.clientWidth / 2;
                    const centerY = canvas.clientHeight / 2;
                    const centerPick = new Cesium.Cartesian2(centerX, centerY);
                    
                    const ray = viewer.camera.getPickRay(centerPick);
                    let intersection = viewer.scene.globe.pick(ray, viewer.scene);
                    
                    if (!intersection) {
                        const ellipsoidIntersection = Cesium.IntersectionTests.rayEllipsoid(ray, viewer.scene.globe.ellipsoid);
                        if (ellipsoidIntersection) {
                            intersection = Cesium.Ray.getPoint(ray, ellipsoidIntersection.start);
                        }
                    }
                    
                    if (intersection && coordinatesInfo) {
                        const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                        // Display with cm precision (8 decimal places  1.1 cm at equator)
                        coordinatesInfo.textContent = `N: ${latitude.toFixed(8)} E: ${longitude.toFixed(8)}`;
                    }
                } catch (error) {
                    if (coordinatesInfo) {
                        coordinatesInfo.textContent = 'N: ---.--- E: ---.---';
                    }
                }
                
                // Update scale bar
                updateScaleBar();
                
                // Update active layers
                const activeLayersList = [];
                const selector = document.getElementById('baseMapSelector');
                if (selector) {
                    const selectedOption = selector.options[selector.selectedIndex];
                    if (selectedOption) {
                        activeLayersList.push(selectedOption.text);
                    }
                }
                if (document.getElementById('protected_areasWms')?.checked) {
                    activeLayersList.push('Protected Areas');
                }
                if (document.getElementById('landDegradationWms')?.checked) {
                    activeLayersList.push('Land Degradation');
                }
                if (activeLayersInfo) {
                    activeLayersInfo.textContent = `Active Layers: ${activeLayersList.join(', ')}`;
                }
                
                // Update attribution - get clean text and condense
                const currentAttribution = document.querySelector('.cesium-credit-textContainer');
                if (currentAttribution && attributionInfo) {
                    let attributionText = currentAttribution.textContent || ' OpenStreetMap contributors';
                    // Clean up and condense attribution text
                    attributionText = attributionText.replace(/\s+/g, ' ').trim();
                    // Further condense common phrases for mobile
                    attributionText = attributionText.replace('OpenStreetMap contributors', 'OSM');
                    attributionText = attributionText.replace('contributors', 'contrib.');
                    attributionText = attributionText.replace('Copyright', '');
                    
                    // More aggressive condensing for mobile
                    if (window.innerWidth <= 768) {
                        if (attributionText.length > 25) {
                            attributionText = attributionText.substring(0, 22) + '...';
                        }
                    } else if (attributionText.length > 35) {
                        attributionText = attributionText.substring(0, 32) + '...';
                    }
                    attributionInfo.textContent = attributionText;
                }
            }
        }

        // Update scale bar in bottom band
        function updateScaleBar() {
            if (!viewer || !viewer.scene) return;
            
            const scaleLine = document.getElementById('scaleLine');
            const scaleText = document.getElementById('scaleText');
            
            if (!scaleLine || !scaleText) return;
            
            try {
                const canvas = viewer.canvas;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                // Calculate scale using two points at the bottom of the screen
                const left = new Cesium.Cartesian2(width * 0.1, height * 0.9);
                const right = new Cesium.Cartesian2(width * 0.3, height * 0.9);
                
                const leftRay = viewer.camera.getPickRay(left);
                const rightRay = viewer.camera.getPickRay(right);
                
                let leftIntersection = viewer.scene.globe.pick(leftRay, viewer.scene);
                let rightIntersection = viewer.scene.globe.pick(rightRay, viewer.scene);
                
                let metersPerPixel;
                
                if (leftIntersection && rightIntersection) {
                    // Standard calculation for low to medium altitudes
                    const distance = Cesium.Cartesian3.distance(leftIntersection, rightIntersection);
                    const pixelDistance = width * 0.2; // 20% of screen width
                    metersPerPixel = distance / pixelDistance;
                } else {
                    // Fallback calculation for very high altitudes using camera height
                    const cameraPosition = viewer.camera.position;
                    const cameraCartographic = viewer.scene.globe.ellipsoid.cartesianToCartographic(cameraPosition);
                    const cameraHeight = cameraCartographic.height;
                    
                    // Approximate calculation based on camera height and field of view
                    const fovy = viewer.camera.frustum.fovy;
                    const pixelDistance = width * 0.2;
                    
                    // Calculate ground distance based on camera height and viewing angle
                    const groundDistance = 2 * cameraHeight * Math.tan(fovy / 2) * (pixelDistance / width);
                    metersPerPixel = groundDistance / pixelDistance;
                }
                
                // Calculate appropriate scale - force larger values at high altitudes
                let basePixels = 100;
                let baseDistance = metersPerPixel * basePixels;
                
                // Calculate appropriate scale values that match the map
                let scaleDistance, scalePixels, scaleLabel;
                
                // Get viewport width for mobile-friendly scale bar size
                let maxScaleWidth;
                if (window.innerWidth <= 480) {
                    maxScaleWidth = Math.min(40, window.innerWidth * 0.12); // Much smaller on mobile
                } else if (window.innerWidth <= 768) {
                    maxScaleWidth = Math.min(60, window.innerWidth * 0.15); // Medium on tablet
                } else {
                    maxScaleWidth = Math.min(100, window.innerWidth / 5); // Standard on desktop
                }
                
                if (baseDistance >= 1000) {
                    // For kilometers - find the best scale that fits within size limits
                    const kmDistance = baseDistance / 1000;
                    const roundedKm = getRoundScaleValue(kmDistance);
                    scaleDistance = roundedKm * 1000;
                    scalePixels = (scaleDistance / metersPerPixel);
                    
                    // If scale bar would be too long, use a smaller scale value
                    if (scalePixels > maxScaleWidth) {
                        // Find largest scale that fits
                        const scales = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000];
                        for (let i = scales.length - 1; i >= 0; i--) {
                            const testDistance = scales[i] * 1000;
                            const testPixels = testDistance / metersPerPixel;
                            if (testPixels <= maxScaleWidth) {
                                scaleDistance = testDistance;
                                scalePixels = testPixels;
                                scaleLabel = scales[i] >= 1000 ? `${scales[i].toLocaleString()} km` : `${scales[i]} km`;
                                break;
                            }
                        }
                    } else {
                        // Format large numbers appropriately
                        if (roundedKm >= 1000) {
                            scaleLabel = `${roundedKm.toLocaleString()} km`;
                        } else {
                            scaleLabel = `${roundedKm} km`;
                        }
                    }
                } else {
                    // For meters - find the best scale that fits within size limits
                    const roundedM = getRoundScaleValue(baseDistance);
                    scaleDistance = roundedM;
                    scalePixels = (scaleDistance / metersPerPixel);
                    
                    // If scale bar would be too long, use a smaller scale value
                    if (scalePixels > maxScaleWidth) {
                        const scales = [1, 2, 5, 10, 20, 50, 100, 200, 500];
                        for (let i = scales.length - 1; i >= 0; i--) {
                            const testPixels = scales[i] / metersPerPixel;
                            if (testPixels <= maxScaleWidth) {
                                scaleDistance = scales[i];
                                scalePixels = testPixels;
                                scaleLabel = `${scales[i]} m`;
                                break;
                            }
                        }
                    } else {
                        scaleLabel = `${roundedM} m`;
                    }
                }
                
                // Set the scale bar width to exactly match the real map distance
                // Mobile optimization: ensure scale bar doesn't exceed container
                let finalWidth = Math.max(10, scalePixels);
                if (window.innerWidth <= 480) {
                    finalWidth = Math.min(finalWidth, 40);
                } else if (window.innerWidth <= 768) {
                    finalWidth = Math.min(finalWidth, 60);
                }
                scaleLine.style.width = `${finalWidth}px`;
                scaleText.textContent = scaleLabel;
            } catch (error) {
                scaleText.textContent = 'Scale: N/A';
            }
        }
        
        // Helper function to get round scale values - prioritizes larger scales for better readability
        function getRoundScaleValue(value) {
            const scales = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000];
            
            // Find the first scale that is greater than or equal to the value
            // This ensures we show meaningful scale increments rather than exact matches
            for (let i = 0; i < scales.length; i++) {
                const scale = scales[i];
                if (scale >= value * 0.5) { // Allow scale to be up to 2x the calculated value for better readability
                    return scale;
                }
            }
            
            // If no suitable scale found, return the largest
            return scales[scales.length - 1];
        }

        // ========================================
        // LEFT PANEL TOGGLE FUNCTION
        // ========================================
        // 
        // LEFT PANEL TOGGLE FUNCTION
        // - Function: toggleLeftPanel()
        // - Element: leftPanel (sidebar)
        // - Toggle Button: leftPanelToggle
        // - Purpose: Expands/collapses the left sidebar panel
        // - Behavior: 
        //   * When collapsed: Expands panel, shows close icon (X)
        //   * When expanded: Collapses panel, shows hamburger icon ()
        // - CSS Classes: 'collapsed', 'with-left-panel'
        // - Console: Logs panel state changes
        //
        function toggleLeftPanel() {
            const leftPanelElement = document.getElementById('leftPanel');
            const cesiumContainer = document.getElementById('cesiumContainer');
            const toggleButton = document.getElementById('leftPanelToggle');
            
            if (leftPanelElement.classList.contains('collapsed')) {
                // Expand left panel
                leftPanelElement.classList.remove('collapsed');
                cesiumContainer.classList.add('with-left-panel');
                if (toggleButton) {
                    toggleButton.innerHTML = '<svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
                }
                console.log('Left panel expanded');
            } else {
                // Collapse left panel
                leftPanelElement.classList.add('collapsed');
                cesiumContainer.classList.remove('with-left-panel');
                if (toggleButton) {
                    toggleButton.innerHTML = '<svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>';
                }
                console.log('Left panel collapsed');
            }
        }

        // Tool panel functions
        function toggleBaseMapPanel() {
            const tool = document.getElementById('baseMapTool');
            const section = document.getElementById('mapsDisplayed');
            
            tool.classList.toggle('active');
            
            if (tool.classList.contains('active')) {
                // Ensure section is visible
                if (section.classList.contains('collapsed')) {
                    toggleSection('mapsDisplayed');
                }
                console.log('Base map panel activated');
            } else {
                console.log('Base map panel deactivated');
            }
        }

        function toggleLayerPanel() {
            const tool = document.getElementById('layerTool');
            const section = document.getElementById('dataServices');
            
            tool.classList.toggle('active');
            
            if (tool.classList.contains('active')) {
                if (section.classList.contains('collapsed')) {
                    toggleSection('dataServices');
                }
                console.log('Layer panel activated');
            } else {
                console.log('Layer panel deactivated');
            }
        }

        function toggleModelPanel() {
            const tool = document.getElementById('modelTool');
            const section = document.getElementById('models3d');
            
            tool.classList.toggle('active');
            
            if (tool.classList.contains('active')) {
                if (section.classList.contains('collapsed')) {
                    toggleSection('models3d');
                }
                console.log('Model panel activated');
            } else {
                console.log('Model panel deactivated');
            }
        }

        function toggleMarkerMode() {
            const tool = document.getElementById('markerTool');
            tool.classList.toggle('active');
            
            if (tool.classList.contains('active')) {
                console.log('Marker mode activated - click on globe to place markers');
            } else {
                console.log('Marker mode deactivated');
            }
        }

        // ========================================
        // PRINT TOOL FUNCTION
        // ========================================
        // 
        // PRINT TOOL FUNCTION
        // - Function: togglePrintMode()
        // - Element: printTool (print button)
        // - Purpose: Activates the print overlay system
        // - Behavior: 
        //   * Calls window.printOverlay.togglePrintMode()
        //   * Shows print overlay for PDF generation
        //   * Console: Logs print mode activation
        //
        function togglePrintMode() {
            console.log(' Print mode activated');
            if (window.printOverlay) {
                window.printOverlay.togglePrintMode();
            } else {
                console.error(' Print overlay not available');
                alert('Print functionality not available. Please refresh the page and try again.');
            }
        }

        // MapX-style tool functions
        function zoomIn() {
            if (viewer && viewer.camera) {
                const camera = viewer.camera;
                const currentHeight = camera.positionCartographic.height;
                const newHeight = currentHeight * 0.7;
                camera.setView({
                    destination: Cesium.Cartesian3.fromRadians(
                        camera.positionCartographic.longitude,
                        camera.positionCartographic.latitude,
                        newHeight
                    )
                });
            }
        }

        function zoomOut() {
            if (viewer && viewer.camera) {
                const camera = viewer.camera;
                const currentHeight = camera.positionCartographic.height;
                const newHeight = currentHeight * 1.4;
                camera.setView({
                    destination: Cesium.Cartesian3.fromRadians(
                        camera.positionCartographic.longitude,
                        camera.positionCartographic.latitude,
                        newHeight
                    )
                });
            }
        }

        function resetView() {
            if (viewer && viewer.camera) {
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(15.0, 45.0, 4000000),
                    orientation: {
                        heading: 0.0,
                        pitch: -Cesium.Math.PI_OVER_TWO,
                        roll: 0.0
                    }
                });
            }
        }

        function refreshMap() {
            if (viewer && viewer.scene) {
                viewer.scene.requestRender();
                console.log('Map refreshed');
            }
        }

        function resetViewToNorth() {
            if (viewer && viewer.camera) {
                const camera = viewer.camera;
                camera.setView({
                    orientation: {
                        heading: 0.0,
                        pitch: camera.pitch,
                        roll: 0.0
                    }
                });
            }
        }

        function toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        }

        function toggleSearchPanel() {
            const tool = document.getElementById('searchTool');
            const section = document.getElementById('searchSection');
            
            tool.classList.toggle('active');
            
            if (tool.classList.contains('active')) {
                if (section.classList.contains('collapsed')) {
                    toggleSection('searchSection');
                }
                console.log('Search panel activated');
            } else {
                console.log('Search panel deactivated');
            }
        }


        
        console.log(' Swiss-style sidebar initialized');
        
        // Predefined overlay services using reliable tile providers and WMS
        const predefinedWmsServices = {
            satellite: {
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                name: 'Satellite Imagery Overlay',
                type: 'tile'
            },
            labels: {
                url: 'https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}.png',
                name: 'Place Labels Overlay', 
                type: 'tile'
            },
            terrain: {
                url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-lines/{z}/{x}/{y}.png',
                name: 'Terrain Lines Overlay',
                type: 'tile'
            },
            protected_areas: {
                url: 'https://data-gis.unep-wcmc.org/server/rest/services/ProtectedSites/The_World_Database_of_Protected_Areas/MapServer/tile/{z}/{y}/{x}',
                name: 'World Database of Protected Areas',
                type: 'tile',
                format: 'image/png',
                transparent: true
            },
            land_degradation: {
                url: 'https://datacore.unepgrid.ch/geoserver/MapX_UNDP/ows',
                name: 'Global Land Degradation (Bare Ground Change 1982-2016)',
                type: 'wms',
                layers: 'MapX_UNDP:Bare_ground_change_1982-2016',
                format: 'image/png',
                transparent: true,
                version: '1.3.0'
            }
        };
        
        // Store predefined layer references (both WMS and tile services)
        const predefinedLayers = new Map();
        
        /**
         * Toggle predefined overlay layers on/off
         */
        function togglePredefinedLayer(serviceKey, enabled) {
            const service = predefinedWmsServices[serviceKey];
            console.log(` Attempting to ${enabled ? 'enable' : 'disable'} ${service.name}`);
            console.log(` Service details:`, service);
            
            if (enabled) {
                try {
                    let imageryProvider;
                    
                    if (service.type === 'wms') {
                        console.log(` Creating WMS provider for: ${service.name}`);
                        console.log(` WMS URL: ${service.url}`);
                        console.log(` Layers: ${service.layers}`);
                        console.log(` Format: ${service.format}`);
                        console.log(` Version: ${service.version}`);
                        
                        // Create WMS imagery provider for proper WMS services with enhanced error handling
                        try {
                            const wmsParameters = {
                                format: service.format || 'image/png',
                                transparent: service.transparent !== false,
                                version: service.version || '1.3.0',
                                service: 'WMS',
                                request: 'GetMap'
                            };
                            
                            console.log(` WMS Parameters:`, wmsParameters);
                            
                            imageryProvider = new Cesium.WebMapServiceImageryProvider({
                                url: service.url,
                                layers: service.layers || '0',
                                parameters: wmsParameters,
                                credit: service.name,
                                enablePickFeatures: false,
                                getFeatureInfoParameters: {
                                    service: 'WMS',
                                    version: service.version || '1.3.0',
                                    request: 'GetFeatureInfo'
                                }
                            });
                            
                            console.log(` WMS provider created successfully for ${service.name}`);
                            
                            // Test WMS service availability with enhanced error handling
                            const testUrl = `${service.url}?service=WMS&version=${service.version || '1.3.0'}&request=GetCapabilities`;
                            console.log(` Testing WMS service availability: ${testUrl}`);
                            
                            // Enhanced WMS service testing
                            fetch(testUrl, { 
                                method: 'GET',
                                mode: 'cors',
                                headers: {
                                    'Accept': 'application/xml, text/xml, */*',
                                    'User-Agent': 'MyEarth/1.0'
                                },
                                cache: 'no-cache'
                            }).then(response => {
                                console.log(` WMS test response: ${response.status} ${response.statusText}`);
                                console.log(` Response headers:`, Object.fromEntries(response.headers.entries()));
                                
                                if (!response.ok) {
                                    throw new Error(`WMS service unavailable: ${response.status} ${response.statusText}`);
                                }
                                console.log(` WMS service ${service.name} is available`);
                                return response.text();
                            }).then(data => {
                                console.log(` WMS capabilities response length: ${data.length} characters`);
                                console.log(` First 500 chars:`, data.substring(0, 500));
                                
                                // Basic XML validation
                                if (!data.includes('<WMS_Capabilities') && !data.includes('<wms:WMS_Capabilities')) {
                                    throw new Error('Invalid WMS capabilities response - no WMS_Capabilities found');
                                }
                                console.log(` WMS service ${service.name} returned valid capabilities`);
                            }).catch(error => {
                                console.error(` WMS service ${service.name} test failed:`, error);
                                console.error(` Error details:`, error.message);
                                
                                // Show user-friendly error message
                                let errorMessage = error.message;
                                if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                                    errorMessage = 'WMS service blocked by CORS policy or network error';
                                } else if (error.message.includes('404')) {
                                    errorMessage = 'WMS service endpoint not found';
                                } else if (error.message.includes('500')) {
                                    errorMessage = 'WMS service internal error';
                                } else if (error.message.includes('timeout')) {
                                    errorMessage = 'WMS service request timeout';
                                }
                                
                                showMessage(` WMS service "${service.name}" unavailable: ${errorMessage}`, 'warning');
                                
                                // Continue anyway - Cesium will handle the actual tile requests
                                // The layer might still work even if capabilities test fails
                            });
                            
                        } catch (error) {
                            console.error(`Failed to create WMS provider for ${service.name}:`, error);
                            throw error;
                        }
                    } else {
                        // Create reliable tile imagery provider for tile services
                        imageryProvider = new Cesium.UrlTemplateImageryProvider({
                            url: service.url,
                            credit: service.name
                        });
                    }
                    
                    console.log(` Adding imagery layer to Cesium viewer...`);
                    const imageryLayer = viewer.imageryLayers.addImageryProvider(imageryProvider);
                    console.log(` Imagery layer added successfully`);
                    
                    // Configure layer properties
                    imageryLayer.alpha = 0.7;
                    imageryLayer.brightness = 1.0;
                    imageryLayer.contrast = 1.1;
                    console.log(` Layer properties set: alpha=${imageryLayer.alpha}, brightness=${imageryLayer.brightness}, contrast=${imageryLayer.contrast}`);
                    
                    // Store layer reference
                    predefinedLayers.set(serviceKey, {
                        layer: imageryLayer,
                        name: service.name,
                        serviceKey: serviceKey
                    });
                    
                    console.log(` ${service.name} layer enabled successfully`);
                    console.log(` Total active layers: ${predefinedLayers.size}`);
                    
                    // Update UI
                    updateLayersList();
                    updateLegend();
                    
                    // Show success message
                    showMessage(` ${service.name} layer loaded successfully`, 'success');
                    
                } catch (error) {
                    console.error(`Failed to load ${service.name}:`, error);
                    showMessage(` Failed to load "${service.name}": ${error.message}`, 'error');
                    const checkbox = document.getElementById(`${serviceKey}Wms`);
                    if (checkbox) checkbox.checked = false;
                }
            } else {
                // Remove layer
                const layerInfo = predefinedLayers.get(serviceKey);
                if (layerInfo) {
                    viewer.imageryLayers.remove(layerInfo.layer);
                    predefinedLayers.delete(serviceKey);
                    console.log(` ${layerInfo.name} layer disabled`);
                    updateLayersList();
                    updateLegend();
                }
            }
        }
        
        /**
         * Update the layers list with drag-and-drop functionality
         */
        function updateLayersList() {
            const layersContainer = document.getElementById('activeLayersList');
            if (!layersContainer) return;
            
            layersContainer.innerHTML = '';
            
            if (predefinedLayers.size === 0) {
                layersContainer.innerHTML = '<div style="font-size: 11px; color: #666; padding: 8px;">No active layers</div>';
                return;
            }
            
            // Create sortable list of active layers ordered by their position in CesiumJS
            const layerArray = Array.from(predefinedLayers.entries());
            
            // Sort by layer index in CesiumJS viewer
            layerArray.sort((a, b) => {
                const indexA = viewer.imageryLayers.indexOf(a[1].layer);
                const indexB = viewer.imageryLayers.indexOf(b[1].layer);
                return indexB - indexA; // Reverse order (higher index = on top)
            });
            
            layerArray.forEach(([serviceKey, layerInfo]) => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                layerItem.draggable = false;
                layerItem.dataset.serviceKey = serviceKey;
                
                layerItem.innerHTML = `
                    <div class="layer-drag-handle" title="Drag to reorder layers" draggable="true">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="6" x2="21" y2="6"/>
                            <line x1="3" y1="12" x2="21" y2="12"/>
                            <line x1="3" y1="18" x2="21" y2="18"/>
                        </svg>
                    </div>
                    <div class="layer-info-area">
                        <span class="layer-name">${layerInfo.name}</span>
                    </div>
                    <div class="layer-controls">
                        <input type="range" min="0" max="100" value="70" class="opacity-slider" onchange="updateLayerOpacity('${serviceKey}', this.value)" draggable="false">
                        <button class="remove-layer-btn" onclick="removePredefinedLayer('${serviceKey}')" draggable="false"></button>
                    </div>
                `;
                
                // Add drag and drop events only to the drag handle
                const dragHandle = layerItem.querySelector('.layer-drag-handle');
                if (dragHandle) {
                    dragHandle.addEventListener('dragstart', handleLayerDragStart);
                    dragHandle.addEventListener('dragend', handleLayerDragEnd);
                }
                
                // Add drop zone events to the layer item
                layerItem.addEventListener('dragover', handleLayerDragOver);
                layerItem.addEventListener('dragenter', handleLayerDragEnter);
                layerItem.addEventListener('dragleave', handleLayerDragLeave);
                layerItem.addEventListener('drop', handleLayerDrop);
                
                layersContainer.appendChild(layerItem);
            });
        }
        
        /**
         * Update layer opacity
         */
        function updateLayerOpacity(serviceKey, opacity) {
            const layerInfo = predefinedLayers.get(serviceKey);
            if (layerInfo) {
                layerInfo.layer.alpha = opacity / 100;
            }
        }
        
        /**
         * Remove predefined layer
         */
        function removePredefinedLayer(serviceKey) {
            const checkbox = document.getElementById(`${serviceKey}Wms`);
            if (checkbox) {
                checkbox.checked = false;
                togglePredefinedLayer(serviceKey, false);
            }
        }
        
        // Drag and drop handlers for layer reordering
        let draggedElement = null;
        
        function handleLayerDragStart(e) {
            // Find the parent layer item
            const layerItem = e.target.closest('.layer-item');
            if (!layerItem) return false;
            
            draggedElement = layerItem;
            layerItem.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', layerItem.dataset.serviceKey);
            console.log('Started dragging layer:', layerItem.dataset.serviceKey);
        }
        
        function handleLayerDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Only add visual feedback if this is not the dragged element
            if (this !== draggedElement) {
                this.style.backgroundColor = 'rgba(52, 152, 219, 0.1)';
                this.style.borderColor = '#3498db';
            }
        }
        
        function handleLayerDragEnter(e) {
            e.preventDefault();
            if (this !== draggedElement) {
                this.style.backgroundColor = 'rgba(52, 152, 219, 0.1)';
                this.style.borderColor = '#3498db';
            }
        }
        
        function handleLayerDragLeave(e) {
            // Only remove feedback if we're actually leaving this element
            if (!this.contains(e.relatedTarget)) {
                this.style.backgroundColor = '';
                this.style.borderColor = '#ddd';
            }
        }
        
        function handleLayerDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Remove visual feedback
            this.style.backgroundColor = '';
            this.style.borderColor = '#ddd';
            
            if (draggedElement && draggedElement !== this) {
                const draggedServiceKey = draggedElement.dataset.serviceKey;
                const targetServiceKey = this.dataset.serviceKey;
                
                console.log('Successfully dropping layer:', draggedServiceKey, 'onto:', targetServiceKey);
                
                // Reorder layers in CesiumJS and update display
                reorderImageryLayers(draggedServiceKey, targetServiceKey);
                
                // Update the display order
                updateLayersList();
            } else {
                console.log('Drop ignored - same element or no dragged element');
            }
            
            return false;
        }
        
        function handleLayerDragEnd(e) {
            this.style.opacity = '1';
            
            // Remove visual feedback from all items
            const layerItems = document.querySelectorAll('.layer-item');
            layerItems.forEach(item => {
                item.style.backgroundColor = '';
                item.style.borderColor = '#ddd';
            });
            
            draggedElement = null;
            console.log('Drag ended');
        }
        
        /**
         * Update the legend section based on active layers
         */
        function updateLegend() {
            const legendSection = document.getElementById('legendSection');
            const legendContainer = document.getElementById('legendContainer');
            
            if (!legendSection || !legendContainer) return;
            
            // Check which layers are active
                    const hasProtectedAreas = predefinedLayers.has('protected_areas');
        const hasLandDegradation = predefinedLayers.has('land_degradation');
            
            if (hasProtectedAreas || hasLandDegradation) {
                legendSection.style.display = 'block';
                let legendContent = '';
                
                if (hasProtectedAreas) {
                    legendContent += createProtectedAreasLegend();
                }
                
                if (hasLandDegradation) {
                    if (legendContent) legendContent += '<hr style="margin: 12px 0; border: 0.5px solid #ddd;">';
                    legendContent += createLandDegradationLegend();
                }
                
                legendContainer.innerHTML = legendContent;
            } else {
                legendSection.style.display = 'none';
            }
        }
        
        /**
         * Create legend HTML for Protected Areas layer
         */
        function createProtectedAreasLegend() {
            return `
                <div style="font-weight: 600; margin-bottom: 6px; color: #2d5aa0;"> World Database of Protected Areas</div>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #006400; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Strict Nature Reserves</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #228B22; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>National Parks</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #32CD32; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Natural Monuments</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #7CFC00; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Habitat Management Areas</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #ADFF2F; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Protected Landscapes</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #9AFF9A; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Sustainable Use Areas</span>
                    </div>
                </div>
                <div style="margin-top: 6px; font-size: 9px; color: #666; font-style: italic;">
                    Source: UNEP-WCMC World Database on Protected Areas
                </div>
            `;
        }
        
        /**
         * Create legend HTML for Land Degradation layer
         */
        function createLandDegradationLegend() {
            return `
                <div style="font-weight: 600; margin-bottom: 6px; color: #8B4513;"> Global Land Degradation (Bare Ground Change)</div>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #006400; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Significant Decrease (Vegetation Recovery)</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #32CD32; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Moderate Decrease (Improvement)</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #FFFF99; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>No Significant Change</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #FFA500; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Moderate Increase (Degradation)</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 3px;">
                        <div style="width: 12px; height: 12px; background: #FF4500; border: 1px solid #333; margin-right: 4px; border-radius: 2px;"></div>
                        <span>Significant Increase (Severe Degradation)</span>
                    </div>
                </div>
                <div style="margin-top: 6px; font-size: 9px; color: #666; font-style: italic;">
                    Period: 1982-2016 | Source: UNEP-GRID Global Bare Ground Change Analysis
                </div>
            `;
        }
        
        /**
         * Reorder imagery layers in CesiumJS viewer
         */
        function reorderImageryLayers(draggedKey, targetKey) {
            const draggedLayerInfo = predefinedLayers.get(draggedKey);
            const targetLayerInfo = predefinedLayers.get(targetKey);
            
            if (!draggedLayerInfo || !targetLayerInfo) {
                console.error('Layer info not found for reordering');
                return;
            }
            
            const layers = viewer.imageryLayers;
            const draggedLayer = draggedLayerInfo.layer;
            const targetLayer = targetLayerInfo.layer;
            
            // Get current indices
            let draggedIndex = -1;
            let targetIndex = -1;
            
            for (let i = 0; i < layers.length; i++) {
                if (layers.get(i) === draggedLayer) draggedIndex = i;
                if (layers.get(i) === targetLayer) targetIndex = i;
            }
            
            if (draggedIndex === -1 || targetIndex === -1) {
                console.error('Layer indices not found');
                return;
            }
            
            console.log(`Moving layer from index ${draggedIndex} to ${targetIndex}`);
            
            // Remove the dragged layer
            layers.remove(draggedLayer, false);
            
            // Re-add it at the target position
            layers.add(draggedLayer, targetIndex);
            
            console.log(`Successfully reordered layer ${draggedKey} to position of ${targetKey}`);
            
            // Update the display order to match the new layer order
            setTimeout(() => {
                updateLayersList();
            }, 100);
        }
        
        /**
         * Reset view orientation to North
         * Maintains current position but sets heading to 0 (north) and standard pitch
         */
        function resetViewToNorth() {
            try {
                const currentPosition = viewer.camera.position;
                const currentCartographic = viewer.camera.positionCartographic;
                
                // Calculate a good viewing height if too close
                let viewHeight = currentCartographic.height;
                if (viewHeight < 2000) {
                    viewHeight = 2000; // Minimum 2km for good overview
                }
                
                // Set camera view with north orientation
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromRadians(
                        currentCartographic.longitude,
                        currentCartographic.latitude,
                        viewHeight
                    ),
                    orientation: {
                        heading: 0.0,  // North direction (0 radians)
                        pitch: Cesium.Math.toRadians(-90),  // Straight down view
                        roll: 0.0
                    }
                });
                
                console.log(' View reset to North orientation');
            } catch (error) {
                console.warn('Error resetting view to North:', error);
                // Fallback to default home view if error occurs
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(15.0, 45.0, 4000000),
                    orientation: {
                        heading: 0.0,
                        pitch: Cesium.Math.toRadians(-90),
                        roll: 0.0
                    }
                });
            }
        }

        // Initialize coordinate tracking after viewer is ready
        setTimeout(() => {
            // Verify all elements exist before initializing
            console.log('Checking elements:');
            const northArrowElement = document.getElementById('northArrowTool');
            const coordinatesInfoElement = document.getElementById('coordinatesInfo');
            const scaleLineElement = document.getElementById('scaleLine');
            const scaleTextElement = document.getElementById('scaleText');
            const baseLayerToggleElement = document.getElementById('baseLayerToggle');
            
            console.log('- northArrow:', !!northArrowElement);
            console.log('- coordinatesInfo:', !!coordinatesInfoElement);
            console.log('- scaleLine:', !!scaleLineElement);
            console.log('- scaleText:', !!scaleTextElement);
            console.log('- baseLayerToggle:', !!baseLayerToggleElement);
            
            initializeCoordinateTracking();
            initializeLayerControls();
            initializeDragAndDrop();
            
            // Enable World Database of Protected Areas by default after all initialization
            setTimeout(() => {
                const protectedAreasCheckbox = document.getElementById('protected_areasWms');
                if (protectedAreasCheckbox && protectedAreasCheckbox.checked) {
                    console.log('Attempting to enable World Database of Protected Areas');
                    togglePredefinedLayer('protected_areas', true);
                }
            }, 1000);
        }, 100);

        /**
         * Interactive Marker Placement System
         * 
         * Enables users to click on the globe to place red markers at specific locations.
         * Each marker displays a label and can be managed through the marker collection.
         */

        // Enhanced Marker Management System with UI Integration
        let markerCounter = 0;
        const markers = new Map(); // Store markers with unique IDs and metadata
        const availableColors = [
            '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
            '#FFA500', '#800080', '#008000', '#000080', '#800000', '#808000',
            '#008080', '#FF69B4', '#DC143C', '#32CD32', '#4169E1', '#FFD700'
        ];

        /**
         * Creates a colored marker billboard at specified coordinates with UI integration
         * @param {number} longitude - Longitude in degrees
         * @param {number} latitude - Latitude in degrees
         * @param {string} label - Display label for the marker
         * @param {string} color - Hex color for the marker (optional, defaults to red)
         * @returns {Object} Created marker entity with metadata
         */
        function createMarker(longitude, latitude, label, color = '#FF0000') {
            const markerId = `marker_${++markerCounter}`;
            
            const marker = viewer.entities.add({
                id: markerId,
                position: Cesium.Cartesian3.fromDegrees(longitude, latitude),
                billboard: {
                    image: createMarkerPin(color), // Custom colored pin graphic
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                    scale: 1.0,
                    pixelOffset: new Cesium.Cartesian2(0, 0),
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                },
                label: {
                    text: label,
                    font: '12pt sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -36),
                    disableDepthTestDistance: Number.POSITIVE_INFINITY
                }
            });

            // Store marker with enhanced metadata
            const markerData = {
                entity: marker,
                coordinates: { longitude, latitude },
                label: label,
                color: color,
                timestamp: new Date(),
                id: markerId
            };
            
            markers.set(markerId, markerData);
            
            // Update UI
            updatePointsUI();
            
            return markerData;
        }

        /**
         * Creates a colored marker pin graphic with precise bottom point positioning
         * @param {string} color - Hex color for the marker pin
         * @returns {HTMLCanvasElement} Canvas element containing the marker graphic
         */
        function createMarkerPin(color = '#FF0000') {
            const canvas = document.createElement('canvas');
            canvas.width = 24;
            canvas.height = 36;
            const ctx = canvas.getContext('2d');

            // Calculate darker stroke color
            const strokeColor = darkenColor(color, 0.3);

            // Draw colored marker pin shape with precise positioning
            ctx.fillStyle = color;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;

            // Main pin body (circle) - positioned higher to accommodate point
            ctx.beginPath();
            ctx.arc(12, 10, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Pin point (triangle) - precise tip at bottom center
            ctx.beginPath();
            ctx.moveTo(12, 36); // Bottom point (exact click position)
            ctx.lineTo(6, 18);  // Left side of point
            ctx.lineTo(18, 18); // Right side of point
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Inner white dot
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(12, 10, 3, 0, 2 * Math.PI);
            ctx.fill();

            return canvas;
        }

        /**
         * Darken a hex color by a percentage
         * @param {string} color - Hex color string
         * @param {number} percent - Percentage to darken (0-1)
         * @returns {string} Darkened hex color
         */
        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent * 100);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }

        /**
         * Handles click events on the globe for marker placement
         * Uses precise ellipsoid intersection for exact positioning
         * @param {ClickEvent} event - Cesium click event
         */
        function handleGlobeClick(event) {
            try {
                // Use direct ellipsoid picking for most accurate positioning
                const ellipsoid = viewer.scene.globe.ellipsoid;
                const cartesian = viewer.camera.pickEllipsoid(event.position, ellipsoid);
                
                if (cartesian) {
                    // Convert Cartesian coordinates to geographic coordinates
                    const cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                    // Create marker with sequential numbering
                    const label = `Point ${markerCounter + 1}`;
                    const marker = createMarker(longitude, latitude, label);

                    console.log(`Marker placed at: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (${label})`);
                } else {
                    // Secondary method: Try scene picking for terrain intersection
                    const pickedObject = viewer.scene.pick(event.position);
                    if (pickedObject && pickedObject.primitive) {
                        const ray = viewer.camera.getPickRay(event.position);
                        const intersection = viewer.scene.globe.pick(ray, viewer.scene);
                        
                        if (intersection) {
                            const cartographic = Cesium.Cartographic.fromCartesian(intersection);
                            const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                            const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                            const label = `Point ${markerCounter + 1}`;
                            const marker = createMarker(longitude, latitude, label);

                            console.log(`Marker placed at: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (${label})`);
                        }
                    } else {
                        console.log('Click position not on globe surface');
                    }
                }
            } catch (error) {
                console.warn('Marker placement error:', error);
            }
        }

        /**
         * Initialize marker placement system with accurate coordinate detection
         * Uses Cesium's built-in screen space event handler for precise positioning
         */
        function initializeMarkerPlacement() {
            // Remove any existing click handlers
            viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
            
            // Set up precise click handling using Cesium's screen space event system
            viewer.cesiumWidget.screenSpaceEventHandler.setInputAction(function(event) {
                // Get the exact click position from the event
                const position = event.position;
                
                // Use Cesium's ellipsoid picking for most accurate surface coordinates
                const ellipsoid = viewer.scene.globe.ellipsoid;
                const cartesian = viewer.camera.pickEllipsoid(position, ellipsoid);
                
                if (cartesian) {
                    // Convert Cartesian to geographic coordinates
                    const cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                    const latitude = Cesium.Math.toDegrees(cartographic.latitude);

                    // Create marker at the exact clicked position
                    const label = `Point ${markerCounter + 1}`;
                    createMarker(longitude, latitude, label);

                    console.log(`Marker placed at: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (${label})`);
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

            console.log('Precise marker placement system initialized');
        }

        // Don't initialize marker placement on page load - only when marker panel is activated
        // initializeMarkerPlacement();

        console.log('CesiumJS Globe Viewer initialized successfully');
        /**
         * Point Marker Management UI Functions
         */
        
        /**
         * Updates the points UI with current marker data
         */
        function updatePointsUI() {
            const pointsList = document.getElementById('pointsList');
            
            if (!pointsList) return;
            
            const markerArray = Array.from(markers.values());
            
            if (markerArray.length === 0) {
                pointsList.innerHTML = '<div style="text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; padding: 20px;">No markers placed</div>';
                return;
            }
            
            // Use simpler UI that matches the existing marker menu style with editable names
            let listHTML = '';
            markerArray.forEach(marker => {
                listHTML += `
                    <div class="marker-item" style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <input type="text" value="${marker.label}" 
                               style="background: transparent; border: 1px solid rgba(255,255,255,0.2); color: white; font-size: 11px; padding: 2px 4px; border-radius: 3px; width: 100px;"
                               onchange="updateMarkerLabel('${marker.id}', this.value)"
                               onblur="updateMarkerLabel('${marker.id}', this.value)">
                        <button onclick="removeMarker('${marker.id}')" style="background: #e74c3c; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 9px; cursor: pointer;">Remove</button>
                    </div>
                `;
            });
            pointsList.innerHTML = listHTML;
        }
        
        /**
         * Creates HTML for a point item in the list
         * @param {Object} marker - Marker data object
         * @returns {string} HTML string for the point item
         */
        function createPointItemHTML(marker) {
            const { id, label, coordinates, color, timestamp } = marker;
            const timeStr = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            return `
                <div class="point-item" data-marker-id="${id}" style="border-left-color: ${color}">
                    <div class="point-header">
                        <input type="text" class="point-name-input" value="${label}" 
                               onchange="updateMarkerLabel('${id}', this.value)" 
                               onblur="updateMarkerLabel('${id}', this.value)">
                        <div class="point-actions">
                            <button class="point-action-btn point-color-btn" 
                                    style="background: ${color}" 
                                    onclick="showColorPicker('${id}', this)" 
                                    title="Change color"></button>
                            <button class="point-action-btn point-delete-btn" 
                                    onclick="deleteMarker('${id}')" 
                                    title="Delete point"></button>
                        </div>
                    </div>
                    <div class="point-coordinates">
                        ${coordinates.latitude.toFixed(6)}, ${coordinates.longitude.toFixed(6)}
                    </div>
                    <div class="point-timestamp">Added at ${timeStr}</div>
                </div>
            `;
        }
        
        /**
         * Shows color picker for a specific marker
         * @param {string} markerId - ID of the marker to change color
         * @param {HTMLElement} buttonElement - Button that triggered the picker
         */
        function showColorPicker(markerId, buttonElement) {
            const colorPicker = document.getElementById('colorPickerDropdown');
            if (!colorPicker) return;
            
            // Position the color picker near the button
            const rect = buttonElement.getBoundingClientRect();
            colorPicker.style.left = (rect.left - 60) + 'px';
            colorPicker.style.top = (rect.bottom + 5) + 'px';
            
            // Create color options
            colorPicker.innerHTML = availableColors.map(color => 
                `<div class="color-option" style="background: ${color}" 
                      onclick="changeMarkerColor('${markerId}', '${color}')" 
                      title="${color}"></div>`
            ).join('');
            
            colorPicker.style.display = 'flex';
            
            // Hide picker when clicking outside
            setTimeout(() => {
                document.addEventListener('click', hideColorPicker, { once: true });
            }, 100);
        }
        
        /**
         * Hides the color picker dropdown
         */
        function hideColorPicker() {
            const colorPicker = document.getElementById('colorPickerDropdown');
            if (colorPicker) {
                colorPicker.style.display = 'none';
            }
        }
        
        /**
         * Changes the color of a specific marker
         * @param {string} markerId - ID of the marker to change
         * @param {string} newColor - New hex color for the marker
         */
        function changeMarkerColor(markerId, newColor) {
            const markerData = markers.get(markerId);
            if (!markerData) return;
            
            // Update marker color in the data
            markerData.color = newColor;
            
            // Recreate the marker with new color
            const { coordinates, label } = markerData;
            const newPin = createMarkerPin(newColor);
            markerData.entity.billboard.image = newPin;
            
            // Update UI
            updatePointsUI();
            hideColorPicker();
            
            console.log(`Marker ${markerId} color changed to ${newColor}`);
        }
        
        /**
         * Updates the label of a specific marker
         * @param {string} markerId - ID of the marker to update
         * @param {string} newLabel - New label text
         */
        function updateMarkerLabel(markerId, newLabel) {
            const markerData = markers.get(markerId);
            if (!markerData || !newLabel.trim()) return;
            
            // Update marker label in the data
            markerData.label = newLabel.trim();
            markerData.entity.label.text = newLabel.trim();
            
            console.log(`Marker ${markerId} label updated to: ${newLabel}`);
        }
        
        /**
         * Deletes a specific marker
         * @param {string} markerId - ID of the marker to delete
         */
        function deleteMarker(markerId) {
            const markerData = markers.get(markerId);
            if (!markerData) return;
            
            // Remove from Cesium viewer
            viewer.entities.remove(markerData.entity);
            
            // Remove from our data store
            markers.delete(markerId);
            
            // Update UI
            updatePointsUI();
            
            console.log(`Marker ${markerId} deleted`);
        }
        
        /**
         * Clears all point markers
         */
        function clearAllPoints() {
            if (markers.size === 0) return;
            
            if (confirm(`Delete all ${markers.size} point markers?`)) {
                console.log('Starting marker cleanup process...');
                
                // Method 1: Remove using stored entity references
                let removedCount = 0;
                markers.forEach((markerData, markerId) => {
                    if (markerData.entity) {
                        try {
                            const removed = viewer.entities.remove(markerData.entity);
                            if (removed) {
                                removedCount++;
                                console.log(`Removed marker ${markerId}`);
                            }
                        } catch (e) {
                            console.warn(`Error removing marker ${markerId}:`, e);
                        }
                    }
                });
                
                // Method 2: Remove by entity ID (markers have IDs like "marker_1", "marker_2")
                const allEntities = viewer.entities.values;
                for (let i = allEntities.length - 1; i >= 0; i--) {
                    const entity = allEntities[i];
                    if (entity.id && entity.id.startsWith('marker_')) {
                        try {
                            viewer.entities.remove(entity);
                            console.log(`Removed entity with ID: ${entity.id}`);
                        } catch (e) {
                            console.warn(`Error removing entity ${entity.id}:`, e);
                        }
                    }
                }
                
                // Method 3: Remove by billboard + canvas image pattern
                const remainingEntities = viewer.entities.values;
                for (let i = remainingEntities.length - 1; i >= 0; i--) {
                    const entity = remainingEntities[i];
                    if (entity.billboard && entity.billboard.image) {
                        const image = entity.billboard.image.getValue();
                        // Check if it's a canvas element (our markers use canvas)
                        if (image && image.tagName === 'CANVAS') {
                            try {
                                viewer.entities.remove(entity);
                                console.log('Removed canvas billboard entity');
                            } catch (e) {
                                console.warn('Error removing canvas entity:', e);
                            }
                        }
                    }
                }
                
                // Method 4: Nuclear option - remove all entities
                if (markers.size > 0) {
                    console.warn('Using nuclear cleanup - removing all entities');
                    viewer.entities.removeAll();
                }
                
                // Clear data store
                markers.clear();
                markerCounter = 0;
                
                // Update UI
                updatePointsUI();
                
                // Force scene re-render
                viewer.scene.requestRender();
                
                console.log(`Marker cleanup completed. Removed ${removedCount} markers.`);
            }
        }

        // Initialize theme system on page load
        initializeTheme();
        
        // Initialize points UI
        updatePointsUI();
        
    </script>
</body>
</html>
